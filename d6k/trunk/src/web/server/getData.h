/* getData.h
   Generated by wsdl2h 2.8.16 from getData.wsdl and typemap.dat
   2015-07-09 02:04:45 GMT

   DO NOT INCLUDE THIS FILE DIRECTLY INTO YOUR PROJECT BUILDS
   USE THE soapcpp2-GENERATED SOURCE CODE FILES FOR YOUR PROJECT BUILDS

   gSOAP XML Web services tools.
   Copyright (C) 2000-2013 Robert van Engelen, Genivia Inc. All Rights Reserved.
   Part of this software is released under one of the following licenses:
   GPL or Genivia's license for commercial use.
*/

/** @page page_notes Usage Notes

NOTE:

 - Run soapcpp2 on getData.h to generate the SOAP/XML processing logic.
   Use soapcpp2 -I to specify paths for #import
   To build with STL, 'stlvector.h' is imported from 'import' dir in package.
   Use soapcpp2 -j to generate improved proxy and server classes.
 - Use wsdl2h -c and -s to generate pure C code or C++ code without STL.
 - Use 'typemap.dat' to control namespace bindings and type mappings.
   It is strongly recommended to customize the names of the namespace prefixes
   generated by wsdl2h. To do so, modify the prefix bindings in the Namespaces
   section below and add the modified lines to 'typemap.dat' to rerun wsdl2h.
 - Use Doxygen (www.doxygen.org) on this file to generate documentation.
 - Use wsdl2h -R to generate REST operations.
 - Use wsdl2h -nname to use name as the base namespace prefix instead of 'ns'.
 - Use wsdl2h -Nname for service prefix and produce multiple service bindings
 - Use wsdl2h -d to enable DOM support for xsd:anyType.
 - Use wsdl2h -g to auto-generate readers and writers for root elements.
 - Use wsdl2h -b to auto-generate bi-directional operations (duplex ops).
 - Struct/class members serialized as XML attributes are annotated with a '@'.
 - Struct/class members that have a special role are annotated with a '$'.

WARNING:

   DO NOT INCLUDE THIS ANNOTATED FILE DIRECTLY IN YOUR PROJECT SOURCE CODE.
   USE THE FILES GENERATED BY soapcpp2 FOR YOUR PROJECT'S SOURCE CODE:
   THE soapStub.h FILE CONTAINS THIS CONTENT WITHOUT ANNOTATIONS.

LICENSE:

@verbatim
--------------------------------------------------------------------------------
gSOAP XML Web services tools
Copyright (C) 2000-2013, Robert van Engelen, Genivia Inc. All Rights Reserved.

This software is released under one of the following licenses:
GPL or Genivia's license for commercial use.
--------------------------------------------------------------------------------
GPL license.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; either version 2 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA 02111-1307 USA

Author contact information:
engelen@genivia.com / engelen@acm.org

This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial-use license is available from Genivia, Inc., contact@genivia.com
--------------------------------------------------------------------------------
@endverbatim

*/


//gsoapopt w

/******************************************************************************\
 *                                                                            *
 * Definitions                                                                *
 *   http://iec.ch/TC57/2011/abstract                                         *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Import                                                                     *
 *                                                                            *
\******************************************************************************/


// STL vector containers (use option -s to remove STL dependency)
#import "stlvector.h"

/******************************************************************************\
 *                                                                            *
 * Schema Namespaces                                                          *
 *                                                                            *
\******************************************************************************/


/* NOTE:

It is strongly recommended to customize the names of the namespace prefixes
generated by wsdl2h. To do so, modify the prefix bindings below and add the
modified lines to typemap.dat to rerun wsdl2h:

ns1 = "http://iec.ch/TC57/2011/abstract"
ns2 = "http://iec.ch/TC57/2011/schema/message"
ns3 = "http://www.sznari.com/2015/schema/message"

*/

#define SOAP_NAMESPACE_OF_ns2	"http://iec.ch/TC57/2011/schema/message"
//gsoap ns2   schema namespace:	http://iec.ch/TC57/2011/schema/message
//gsoap ns2   schema form:	unqualified

#define SOAP_NAMESPACE_OF_ns3	"http://www.sznari.com/2015/schema/message"
//gsoap ns3   schema namespace:	http://www.sznari.com/2015/schema/message
//gsoap ns3   schema elementForm:	qualified
//gsoap ns3   schema attributeForm:	unqualified

/******************************************************************************\
 *                                                                            *
 * Built-in Schema Types and Top-Level Elements and Attributes                *
 *                                                                            *
\******************************************************************************/


/// Built-in type "xs:QName".
typedef std::string xsd__QName;

/// Primitive built-in type "xs:integer"
typedef std::string xsd__integer;

/******************************************************************************\
 *                                                                            *
 * Forward Declarations                                                       *
 *                                                                            *
\******************************************************************************/



//  Forward declaration of class ns2__RequestType.
class ns2__RequestType;

//  Forward declaration of class ns2__ReplyType.
class ns2__ReplyType;

//  Forward declaration of class ns2__PayloadType.
class ns2__PayloadType;

//  Forward declaration of class ns2__OperationType.
class ns2__OperationType;

//  Forward declaration of class ns2__OperationSet.
class ns2__OperationSet;

//  Forward declaration of class ns2__ReplayDetectionType.
class ns2__ReplayDetectionType;

//  Forward declaration of class ns2__UserType.
class ns2__UserType;

//  Forward declaration of class ns2__HeaderType.
class ns2__HeaderType;

//  Forward declaration of class ns2__MessageProperty.
class ns2__MessageProperty;

//  Forward declaration of class ns2__MessageType.
class ns2__MessageType;

//  Forward declaration of class ns2__RequestMessageType.
class ns2__RequestMessageType;

//  Forward declaration of class ns2__ResponseMessageType.
class ns2__ResponseMessageType;

//  Forward declaration of class ns2__FaultMessageType.
class ns2__FaultMessageType;

//  Forward declaration of class ns2__EventMessageType.
class ns2__EventMessageType;

//  Forward declaration of class ns2__ErrorType.
class ns2__ErrorType;

//  Forward declaration of class ns2__OptionType.
class ns2__OptionType;

//  Forward declaration of class ns2__LocationType.
class ns2__LocationType;

//  Forward declaration of class ns2__ObjectType.
class ns2__ObjectType;

//  Forward declaration of class ns2__NameType.
class ns2__NameType;

//  Forward declaration of class ns2__Name.
class ns2__Name;

//  Forward declaration of class ns2__NameTypeAuthority.
class ns2__NameTypeAuthority;

//  Forward declaration of class ns3__ArrayValuesType.
class ns3__ArrayValuesType;

//  Forward declaration of class ns3__DeviceClassType.
class ns3__DeviceClassType;

//  Forward declaration of class ns3__DeviceValuesType.
class ns3__DeviceValuesType;

//  Forward declaration of class ns3__CommonValuesType.
class ns3__CommonValuesType;

/******************************************************************************\
 *                                                                            *
 * Schema Types and Top-Level Elements and Attributes                         *
 *   http://iec.ch/TC57/2011/schema/message                                   *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Schema Types and Top-Level Elements and Attributes                         *
 *   http://www.sznari.com/2015/schema/message                                *
 *                                                                            *
\******************************************************************************/


/// "http://iec.ch/TC57/2011/schema/message":IDKindType is a simpleType restriction of xs:string.
/// Note: enum values are prefixed with 'ns2__IDKindType' to avoid name clashes, please use wsdl2h option -e to omit this prefix
enum ns2__IDKindType
{
	ns2__IDKindType__name,	///< xs:string value="name"
	ns2__IDKindType__uuid,	///< xs:string value="uuid"
	ns2__IDKindType__transaction,	///< xs:string value="transaction"
	ns2__IDKindType__other,	///< xs:string value="other"
};

/******************************************************************************\
 *                                                                            *
 * Schema Types and Top-Level Elements and Attributes                         *
 *   http://www.sznari.com/2015/schema/message                                *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Schema Complex Types and Top-Level Elements                                *
 *   http://iec.ch/TC57/2011/schema/message                                   *
 *                                                                            *
\******************************************************************************/


/// "http://iec.ch/TC57/2011/schema/message":RequestType is a complexType.
/// class ns2__RequestType operations:
/// - soap_new_ns2__RequestType(soap*) allocate
/// - soap_new_ns2__RequestType(soap*, int num) allocate array
/// - soap_new_req_ns2__RequestType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__RequestType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__RequestType(soap*, ns2__RequestType*) deserialize from a stream
/// - int soap_write_ns2__RequestType(soap, ns2__RequestType*) serialize to a stream
class ns2__RequestType
{ public:
/// Element StartTime of type xs:dateTime.
    time_t*                              StartTime                      0;	///< Optional element.
/// Element EndTime of type xs:dateTime.
    time_t*                              EndTime                        0;	///< Optional element.
/// Vector of ns2__OptionType* with length 0..unbounded
    std::vector<ns2__OptionType*       > Option                         0;
/// Vector of ID with length 0..unbounded
    std::vector<
/// class _ns2__RequestType_ID operations:
/// - soap_new__ns2__RequestType_ID(soap*) allocate
/// - soap_new__ns2__RequestType_ID(soap*, int num) allocate array
/// - soap_new_req__ns2__RequestType_ID(soap*, ...) allocate, set required members
/// - soap_new_set__ns2__RequestType_ID(soap*, ...) allocate, set all public members
/// - int soap_read__ns2__RequestType_ID(soap*, _ns2__RequestType_ID*) deserialize from a stream
/// - int soap_write__ns2__RequestType_ID(soap, _ns2__RequestType_ID*) serialize to a stream
    class _ns2__RequestType_ID
    {
/// __item wraps 'xs:string' simpleContent.
    std::string                          __item                        ;
/// Begin attributeGroup IDatts.
/// Attribute idType of type xs:string.
   @std::string*                         idType                         0;	///< Optional attribute.
/// Attribute idAuthority of type xs:string.
   @std::string*                         idAuthority                    0;	///< Optional attribute.
/// Attribute kind of type "http://iec.ch/TC57/2011/schema/message":IDKindType.
   @enum ns2__IDKindType*                kind                           0;	///< Optional attribute.
/// Attribute objectType of type xs:string.
   @std::string*                         objectType                     0;	///< Optional attribute.
/// End of attributeGroup IDatts.
    }>                                  *ID                             0;
/// TODO: <any namespace="##other" minOccurs="0" maxOccurs="unbounded">
/// TODO: Schema extensibility is user-definable.
///       Consult the protocol documentation to change or insert declarations.
///       Use wsdl2h option -x to remove this element.
///       Use wsdl2h option -d for xsd__anyType DOM (soap_dom_element).
/// Size of the array of XML or DOM nodes is 0..unbounded
    std::vector<_XML                   > __any                         0;	///< Catch any element content in XML string.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://iec.ch/TC57/2011/schema/message":ReplyType is a complexType.
/// class ns2__ReplyType operations:
/// - soap_new_ns2__ReplyType(soap*) allocate
/// - soap_new_ns2__ReplyType(soap*, int num) allocate array
/// - soap_new_req_ns2__ReplyType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__ReplyType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__ReplyType(soap*, ns2__ReplyType*) deserialize from a stream
/// - int soap_write_ns2__ReplyType(soap, ns2__ReplyType*) serialize to a stream
class ns2__ReplyType
{ public:
    enum _ns2__ReplyType_Result
    {
	_ns2__ReplyType_Result__OK,	///< xs:string value="OK"
	_ns2__ReplyType_Result__PARTIAL,	///< xs:string value="PARTIAL"
	_ns2__ReplyType_Result__FAILED,	///< xs:string value="FAILED"
    }
                                         Result                         1;	///< Required element.
/// Vector of ns2__ErrorType* with length 0..unbounded
    std::vector<ns2__ErrorType*        > Error                          0;
/// Vector of ID with length 0..unbounded
    std::vector<
/// class _ns2__ReplyType_ID operations:
/// - soap_new__ns2__ReplyType_ID(soap*) allocate
/// - soap_new__ns2__ReplyType_ID(soap*, int num) allocate array
/// - soap_new_req__ns2__ReplyType_ID(soap*, ...) allocate, set required members
/// - soap_new_set__ns2__ReplyType_ID(soap*, ...) allocate, set all public members
/// - int soap_read__ns2__ReplyType_ID(soap*, _ns2__ReplyType_ID*) deserialize from a stream
/// - int soap_write__ns2__ReplyType_ID(soap, _ns2__ReplyType_ID*) serialize to a stream
    class _ns2__ReplyType_ID
    {
/// __item wraps 'xs:string' simpleContent.
    std::string                          __item                        ;
/// Begin attributeGroup IDatts.
/// Attribute idType of type xs:string.
   @std::string*                         idType                         0;	///< Optional attribute.
/// Attribute idAuthority of type xs:string.
   @std::string*                         idAuthority                    0;	///< Optional attribute.
/// Attribute kind of type "http://iec.ch/TC57/2011/schema/message":IDKindType.
   @enum ns2__IDKindType*                kind                           0;	///< Optional attribute.
/// Attribute objectType of type xs:string.
   @std::string*                         objectType                     0;	///< Optional attribute.
/// End of attributeGroup IDatts.
    }>                                  *ID                             0;
/// TODO: <any namespace="##other" minOccurs="0" maxOccurs="unbounded">
/// TODO: Schema extensibility is user-definable.
///       Consult the protocol documentation to change or insert declarations.
///       Use wsdl2h option -x to remove this element.
///       Use wsdl2h option -d for xsd__anyType DOM (soap_dom_element).
/// Size of the array of XML or DOM nodes is 0..unbounded
    std::vector<_XML                   > __any                         0;	///< Catch any element content in XML string.
/// Element operationId of type xs:integer.
    xsd__integer*                        operationId                    0;	///< Optional element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://iec.ch/TC57/2011/schema/message":PayloadType is a complexType.
/// class ns2__PayloadType operations:
/// - soap_new_ns2__PayloadType(soap*) allocate
/// - soap_new_ns2__PayloadType(soap*, int num) allocate array
/// - soap_new_req_ns2__PayloadType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__PayloadType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__PayloadType(soap*, ns2__PayloadType*) deserialize from a stream
/// - int soap_write_ns2__PayloadType(soap, ns2__PayloadType*) serialize to a stream
class ns2__PayloadType
{ public:
/// CHOICE <xs:choice>
   $int                                  __union_PayloadType           ;	///< Union _ns2__union_PayloadType selector: set to SOAP_UNION__ns2__union_PayloadType_<fieldname>
    union _ns2__union_PayloadType
    {
/// Vector of ns3__CommonValuesType* with length 0..unbounded
    std::vector<ns3__CommonValuesType*> *CommonValues                   0;
/// Vector of ns3__DeviceValuesType* with length 0..unbounded
    std::vector<ns3__DeviceValuesType*> *DeviceValues                   0;
/// Vector of ns3__ArrayValuesType* with length 0..unbounded
    std::vector<ns3__ArrayValuesType* > *ArrayValues                    0;
/// Element OperationSet of type "http://iec.ch/TC57/2011/schema/message":OperationSet.
    ns2__OperationSet*                   OperationSet                   0;	///< Optional element.
/// Element Compressed of type xs:string.
    std::string*                         Compressed                     0;	///< Optional element.
/// Vector of ID with length 0..unbounded
    std::vector<
/// class _ns2__PayloadType_ID operations:
/// - soap_new__ns2__PayloadType_ID(soap*) allocate
/// - soap_new__ns2__PayloadType_ID(soap*, int num) allocate array
/// - soap_new_req__ns2__PayloadType_ID(soap*, ...) allocate, set required members
/// - soap_new_set__ns2__PayloadType_ID(soap*, ...) allocate, set all public members
/// - int soap_read__ns2__PayloadType_ID(soap*, _ns2__PayloadType_ID*) deserialize from a stream
/// - int soap_write__ns2__PayloadType_ID(soap, _ns2__PayloadType_ID*) serialize to a stream
    class _ns2__PayloadType_ID
    {
/// __item wraps 'xs:string' simpleContent.
    std::string                          __item                        ;
/// Begin attributeGroup IDatts.
/// Attribute idType of type xs:string.
   @std::string*                         idType                         0;	///< Optional attribute.
/// Attribute idAuthority of type xs:string.
   @std::string*                         idAuthority                    0;	///< Optional attribute.
/// Attribute kind of type "http://iec.ch/TC57/2011/schema/message":IDKindType.
   @enum ns2__IDKindType*                kind                           0;	///< Optional attribute.
/// Attribute objectType of type xs:string.
   @std::string*                         objectType                     0;	///< Optional attribute.
/// End of attributeGroup IDatts.
    }>                                  *ID                             0;
    }                                    union_PayloadType             ;
//  END OF CHOICE
/// Element Format of type xs:string.
    std::string*                         Format                         0;	///< Optional element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://iec.ch/TC57/2011/schema/message":OperationType is a complexType.
/// class ns2__OperationType operations:
/// - soap_new_ns2__OperationType(soap*) allocate
/// - soap_new_ns2__OperationType(soap*, int num) allocate array
/// - soap_new_req_ns2__OperationType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__OperationType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__OperationType(soap*, ns2__OperationType*) deserialize from a stream
/// - int soap_write_ns2__OperationType(soap, ns2__OperationType*) serialize to a stream
class ns2__OperationType
{ public:
/// Element operationId of type xs:integer.
    xsd__integer                         operationId                    1;	///< Required element.
/// Element noun of type xs:string.
    std::string*                         noun                           0;	///< Optional element.
/// Element verb of type xs:string.
    std::string*                         verb                           0;	///< Optional element.
/// Element elementOperation of type xs:boolean.
    bool                                 elementOperation               0 = false;	///< Default value="false".
/// TODO: <any namespace="##other" minOccurs="0">
/// TODO: Schema extensibility is user-definable.
///       Consult the protocol documentation to change or insert declarations.
///       Use wsdl2h option -x to remove this element.
///       Use wsdl2h option -d for xsd__anyType DOM (soap_dom_element).
    _XML                                 __any                         0;	///< Catch any element content in XML string.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://iec.ch/TC57/2011/schema/message":OperationSet is a complexType.
/// class ns2__OperationSet operations:
/// - soap_new_ns2__OperationSet(soap*) allocate
/// - soap_new_ns2__OperationSet(soap*, int num) allocate array
/// - soap_new_req_ns2__OperationSet(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__OperationSet(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__OperationSet(soap*, ns2__OperationSet*) deserialize from a stream
/// - int soap_write_ns2__OperationSet(soap, ns2__OperationSet*) serialize to a stream
class ns2__OperationSet
{ public:
/// Element enforceMsgSequence of type xs:boolean.
    bool*                                enforceMsgSequence             0;	///< Optional element.
/// Element enforceTransactionalIntegrity of type xs:boolean.
    bool*                                enforceTransactionalIntegrity  0;	///< Optional element.
/// Vector of ns2__OperationType* with length 0..unbounded
    std::vector<ns2__OperationType*    > Operation                      0;
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://iec.ch/TC57/2011/schema/message":ReplayDetectionType is a complexType.
/// class ns2__ReplayDetectionType operations:
/// - soap_new_ns2__ReplayDetectionType(soap*) allocate
/// - soap_new_ns2__ReplayDetectionType(soap*, int num) allocate array
/// - soap_new_req_ns2__ReplayDetectionType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__ReplayDetectionType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__ReplayDetectionType(soap*, ns2__ReplayDetectionType*) deserialize from a stream
/// - int soap_write_ns2__ReplayDetectionType(soap, ns2__ReplayDetectionType*) serialize to a stream
class ns2__ReplayDetectionType
{ public:
/// Element Nonce of type xs:string.
    std::string                          Nonce                          1;	///< Required element.
/// Element Created of type xs:dateTime.
    time_t                               Created                        1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://iec.ch/TC57/2011/schema/message":UserType is a complexType.
/// class ns2__UserType operations:
/// - soap_new_ns2__UserType(soap*) allocate
/// - soap_new_ns2__UserType(soap*, int num) allocate array
/// - soap_new_req_ns2__UserType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__UserType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__UserType(soap*, ns2__UserType*) deserialize from a stream
/// - int soap_write_ns2__UserType(soap, ns2__UserType*) serialize to a stream
class ns2__UserType
{ public:
/// Element UserID of type xs:string.
    std::string                          UserID                         1;	///< Required element.
/// Element Organization of type xs:string.
    std::string*                         Organization                   0;	///< Optional element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://iec.ch/TC57/2011/schema/message":HeaderType is a complexType.
/// class ns2__HeaderType operations:
/// - soap_new_ns2__HeaderType(soap*) allocate
/// - soap_new_ns2__HeaderType(soap*, int num) allocate array
/// - soap_new_req_ns2__HeaderType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__HeaderType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__HeaderType(soap*, ns2__HeaderType*) deserialize from a stream
/// - int soap_write_ns2__HeaderType(soap, ns2__HeaderType*) serialize to a stream
class ns2__HeaderType
{ public:
    enum _ns2__HeaderType_Verb
    {
	_ns2__HeaderType_Verb__cancel,	///< xs:string value="cancel"
	_ns2__HeaderType_Verb__canceled,	///< xs:string value="canceled"
	_ns2__HeaderType_Verb__change,	///< xs:string value="change"
	_ns2__HeaderType_Verb__changed,	///< xs:string value="changed"
	_ns2__HeaderType_Verb__create,	///< xs:string value="create"
	_ns2__HeaderType_Verb__created,	///< xs:string value="created"
	_ns2__HeaderType_Verb__close,	///< xs:string value="close"
	_ns2__HeaderType_Verb__closed,	///< xs:string value="closed"
	_ns2__HeaderType_Verb__delete_,	///< xs:string value="delete"
	_ns2__HeaderType_Verb__deleted,	///< xs:string value="deleted"
	_ns2__HeaderType_Verb__get,	///< xs:string value="get"
	_ns2__HeaderType_Verb__reply,	///< xs:string value="reply"
	_ns2__HeaderType_Verb__execute,	///< xs:string value="execute"
	_ns2__HeaderType_Verb__executed,	///< xs:string value="executed"
    }
                                         Verb                           1;	///< Required element.
/// Element Noun of type xs:string.
    std::string                          Noun                           1;	///< Required element.
/// Element Revision of type xs:string.
    std::string*                         Revision                       0;	///< Optional element.
/// Element ReplayDetection of type "http://iec.ch/TC57/2011/schema/message":ReplayDetectionType.
    ns2__ReplayDetectionType*            ReplayDetection                0;	///< Optional element.
/// Element Context of type xs:string.
    std::string*                         Context                        0;	///< Optional element.
/// Element Timestamp of type xs:dateTime.
    time_t*                              Timestamp                      0;	///< Optional element.
/// Element Source of type xs:string.
    std::string*                         Source                         0;	///< Optional element.
/// Element AsyncReplyFlag of type xs:boolean.
    bool*                                AsyncReplyFlag                 0;	///< Optional element.
/// Element ReplyAddress of type xs:string.
    std::string*                         ReplyAddress                   0;	///< Optional element.
/// Element AckRequired of type xs:boolean.
    bool*                                AckRequired                    0;	///< Optional element.
/// Element User of type "http://iec.ch/TC57/2011/schema/message":UserType.
    ns2__UserType*                       User                           0;	///< Optional element.
/// Element MessageID of type xs:string.
    std::string*                         MessageID                      0;	///< Optional element.
/// Element CorrelationID of type xs:string.
    std::string*                         CorrelationID                  0;	///< Optional element.
/// Element Comment of type xs:string.
    std::string*                         Comment                        0;	///< Optional element.
/// Vector of ns2__MessageProperty* with length 0..unbounded
    std::vector<ns2__MessageProperty*  > Property                       0;
/// TODO: <any namespace="##other" minOccurs="0" maxOccurs="unbounded">
/// TODO: Schema extensibility is user-definable.
///       Consult the protocol documentation to change or insert declarations.
///       Use wsdl2h option -x to remove this element.
///       Use wsdl2h option -d for xsd__anyType DOM (soap_dom_element).
/// Size of the array of XML or DOM nodes is 0..unbounded
    std::vector<_XML                   > __any                         0;	///< Catch any element content in XML string.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://iec.ch/TC57/2011/schema/message":MessageProperty is a complexType.
/// class ns2__MessageProperty operations:
/// - soap_new_ns2__MessageProperty(soap*) allocate
/// - soap_new_ns2__MessageProperty(soap*, int num) allocate array
/// - soap_new_req_ns2__MessageProperty(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__MessageProperty(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__MessageProperty(soap*, ns2__MessageProperty*) deserialize from a stream
/// - int soap_write_ns2__MessageProperty(soap, ns2__MessageProperty*) serialize to a stream
class ns2__MessageProperty
{ public:
/// Element Name of type xs:string.
    std::string                          Name                           1;	///< Required element.
/// Element Value of type xs:string.
    std::string*                         Value                          0;	///< Optional element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://iec.ch/TC57/2011/schema/message":MessageType is a complexType.
/// class ns2__MessageType operations:
/// - soap_new_ns2__MessageType(soap*) allocate
/// - soap_new_ns2__MessageType(soap*, int num) allocate array
/// - soap_new_req_ns2__MessageType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__MessageType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__MessageType(soap*, ns2__MessageType*) deserialize from a stream
/// - int soap_write_ns2__MessageType(soap, ns2__MessageType*) serialize to a stream
class ns2__MessageType
{ public:
/// Element Header of type "http://iec.ch/TC57/2011/schema/message":HeaderType.
    ns2__HeaderType*                     Header                         1;	///< Required element.
/// Element Request of type "http://iec.ch/TC57/2011/schema/message":RequestType.
    ns2__RequestType*                    Request                        0;	///< Optional element.
/// Element Reply of type "http://iec.ch/TC57/2011/schema/message":ReplyType.
    ns2__ReplyType*                      Reply                          0;	///< Optional element.
/// Element Payload of type "http://iec.ch/TC57/2011/schema/message":PayloadType.
    ns2__PayloadType*                    Payload                        0;	///< Optional element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://iec.ch/TC57/2011/schema/message":RequestMessageType is a complexType.
/// class ns2__RequestMessageType operations:
/// - soap_new_ns2__RequestMessageType(soap*) allocate
/// - soap_new_ns2__RequestMessageType(soap*, int num) allocate array
/// - soap_new_req_ns2__RequestMessageType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__RequestMessageType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__RequestMessageType(soap*, ns2__RequestMessageType*) deserialize from a stream
/// - int soap_write_ns2__RequestMessageType(soap, ns2__RequestMessageType*) serialize to a stream
class ns2__RequestMessageType
{ public:
/// Element Header of type "http://iec.ch/TC57/2011/schema/message":HeaderType.
    ns2__HeaderType*                     Header                         1;	///< Required element.
/// Element Request of type "http://iec.ch/TC57/2011/schema/message":RequestType.
    ns2__RequestType*                    Request                        0;	///< Optional element.
/// Element Payload of type "http://iec.ch/TC57/2011/schema/message":PayloadType.
    ns2__PayloadType*                    Payload                        0;	///< Optional element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://iec.ch/TC57/2011/schema/message":ResponseMessageType is a complexType.
/// class ns2__ResponseMessageType operations:
/// - soap_new_ns2__ResponseMessageType(soap*) allocate
/// - soap_new_ns2__ResponseMessageType(soap*, int num) allocate array
/// - soap_new_req_ns2__ResponseMessageType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__ResponseMessageType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__ResponseMessageType(soap*, ns2__ResponseMessageType*) deserialize from a stream
/// - int soap_write_ns2__ResponseMessageType(soap, ns2__ResponseMessageType*) serialize to a stream
class ns2__ResponseMessageType
{ public:
/// Element Header of type "http://iec.ch/TC57/2011/schema/message":HeaderType.
    ns2__HeaderType*                     Header                         1;	///< Required element.
/// Element Reply of type "http://iec.ch/TC57/2011/schema/message":ReplyType.
    ns2__ReplyType*                      Reply                          1;	///< Required element.
/// Element Payload of type "http://iec.ch/TC57/2011/schema/message":PayloadType.
    ns2__PayloadType*                    Payload                        0;	///< Optional element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://iec.ch/TC57/2011/schema/message":FaultMessageType is a complexType.
/// class ns2__FaultMessageType operations:
/// - soap_new_ns2__FaultMessageType(soap*) allocate
/// - soap_new_ns2__FaultMessageType(soap*, int num) allocate array
/// - soap_new_req_ns2__FaultMessageType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__FaultMessageType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__FaultMessageType(soap*, ns2__FaultMessageType*) deserialize from a stream
/// - int soap_write_ns2__FaultMessageType(soap, ns2__FaultMessageType*) serialize to a stream
class ns2__FaultMessageType
{ public:
/// Element Reply of type "http://iec.ch/TC57/2011/schema/message":ReplyType.
    ns2__ReplyType*                      Reply                          1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://iec.ch/TC57/2011/schema/message":EventMessageType is a complexType.
/// class ns2__EventMessageType operations:
/// - soap_new_ns2__EventMessageType(soap*) allocate
/// - soap_new_ns2__EventMessageType(soap*, int num) allocate array
/// - soap_new_req_ns2__EventMessageType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__EventMessageType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__EventMessageType(soap*, ns2__EventMessageType*) deserialize from a stream
/// - int soap_write_ns2__EventMessageType(soap, ns2__EventMessageType*) serialize to a stream
class ns2__EventMessageType
{ public:
/// Element Header of type "http://iec.ch/TC57/2011/schema/message":HeaderType.
    ns2__HeaderType*                     Header                         1;	///< Required element.
/// Element Payload of type "http://iec.ch/TC57/2011/schema/message":PayloadType.
    ns2__PayloadType*                    Payload                        0;	///< Optional element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://iec.ch/TC57/2011/schema/message":ErrorType is a complexType.
/// class ns2__ErrorType operations:
/// - soap_new_ns2__ErrorType(soap*) allocate
/// - soap_new_ns2__ErrorType(soap*, int num) allocate array
/// - soap_new_req_ns2__ErrorType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__ErrorType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__ErrorType(soap*, ns2__ErrorType*) deserialize from a stream
/// - int soap_write_ns2__ErrorType(soap, ns2__ErrorType*) serialize to a stream
class ns2__ErrorType
{ public:
/// Element code of type xs:string.
    std::string                          code                           1;	///< Required element.
    enum _ns2__ErrorType_level
    {
	_ns2__ErrorType_level__INFORM,	///< xs:string value="INFORM"
	_ns2__ErrorType_level__WARNING,	///< xs:string value="WARNING"
	_ns2__ErrorType_level__FATAL,	///< xs:string value="FATAL"
	_ns2__ErrorType_level__CATASTROPHIC,	///< xs:string value="CATASTROPHIC"
    }
                                        *level                          0;	///< Optional element.
/// Element reason of type xs:string.
    std::string*                         reason                         0;	///< Optional element.
/// Element details of type xs:string.
    std::string*                         details                        0;	///< Optional element.
/// Element xpath of type xs:QName.
    xsd__QName*                          xpath                          0;	///< Optional element.
/// Element stackTrace of type xs:string.
    std::string*                         stackTrace                     0;	///< Optional element.
/// Element Location of type "http://iec.ch/TC57/2011/schema/message":LocationType.
    ns2__LocationType*                   Location                       0;	///< Optional element.
/// class _ns2__ErrorType_ID operations:
/// - soap_new__ns2__ErrorType_ID(soap*) allocate
/// - soap_new__ns2__ErrorType_ID(soap*, int num) allocate array
/// - soap_new_req__ns2__ErrorType_ID(soap*, ...) allocate, set required members
/// - soap_new_set__ns2__ErrorType_ID(soap*, ...) allocate, set all public members
/// - int soap_read__ns2__ErrorType_ID(soap*, _ns2__ErrorType_ID*) deserialize from a stream
/// - int soap_write__ns2__ErrorType_ID(soap, _ns2__ErrorType_ID*) serialize to a stream
    class _ns2__ErrorType_ID
    {
/// __item wraps 'xs:string' simpleContent.
    std::string                          __item                        ;
/// Begin attributeGroup IDatts.
/// Attribute idType of type xs:string.
   @std::string*                         idType                         0;	///< Optional attribute.
/// Attribute idAuthority of type xs:string.
   @std::string*                         idAuthority                    0;	///< Optional attribute.
/// Attribute kind of type "http://iec.ch/TC57/2011/schema/message":IDKindType.
   @enum ns2__IDKindType*                kind                           0;	///< Optional attribute.
/// Attribute objectType of type xs:string.
   @std::string*                         objectType                     0;	///< Optional attribute.
/// End of attributeGroup IDatts.
    }                                   *ID                             0;	///< Optional element.
/// class _ns2__ErrorType_relatedID operations:
/// - soap_new__ns2__ErrorType_relatedID(soap*) allocate
/// - soap_new__ns2__ErrorType_relatedID(soap*, int num) allocate array
/// - soap_new_req__ns2__ErrorType_relatedID(soap*, ...) allocate, set required members
/// - soap_new_set__ns2__ErrorType_relatedID(soap*, ...) allocate, set all public members
/// - int soap_read__ns2__ErrorType_relatedID(soap*, _ns2__ErrorType_relatedID*) deserialize from a stream
/// - int soap_write__ns2__ErrorType_relatedID(soap, _ns2__ErrorType_relatedID*) serialize to a stream
    class _ns2__ErrorType_relatedID
    {
/// __item wraps 'xs:string' simpleContent.
    std::string                          __item                        ;
/// Begin attributeGroup IDatts.
/// Attribute idType of type xs:string.
   @std::string*                         idType                         0;	///< Optional attribute.
/// Attribute idAuthority of type xs:string.
   @std::string*                         idAuthority                    0;	///< Optional attribute.
/// Attribute kind of type "http://iec.ch/TC57/2011/schema/message":IDKindType.
   @enum ns2__IDKindType*                kind                           0;	///< Optional attribute.
/// Attribute objectType of type xs:string.
   @std::string*                         objectType                     0;	///< Optional attribute.
/// End of attributeGroup IDatts.
    }                                   *relatedID                      0;	///< Optional element.
/// Element object of type "http://iec.ch/TC57/2011/schema/message":ObjectType.
    ns2__ObjectType*                     object                         0;	///< Optional element.
/// Element operationId of type xs:integer.
    xsd__integer*                        operationId                    0;	///< Optional element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://iec.ch/TC57/2011/schema/message":OptionType is a complexType.
/// class ns2__OptionType operations:
/// - soap_new_ns2__OptionType(soap*) allocate
/// - soap_new_ns2__OptionType(soap*, int num) allocate array
/// - soap_new_req_ns2__OptionType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__OptionType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__OptionType(soap*, ns2__OptionType*) deserialize from a stream
/// - int soap_write_ns2__OptionType(soap, ns2__OptionType*) serialize to a stream
class ns2__OptionType
{ public:
/// Element name of type xs:string.
    std::string                          name                           1;	///< Required element.
/// Element value of type xs:string.
    std::string*                         value                          0;	///< Optional element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://iec.ch/TC57/2011/schema/message":LocationType is a complexType.
/// class ns2__LocationType operations:
/// - soap_new_ns2__LocationType(soap*) allocate
/// - soap_new_ns2__LocationType(soap*, int num) allocate array
/// - soap_new_req_ns2__LocationType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__LocationType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__LocationType(soap*, ns2__LocationType*) deserialize from a stream
/// - int soap_write_ns2__LocationType(soap, ns2__LocationType*) serialize to a stream
class ns2__LocationType
{ public:
/// Element node of type xs:string.
    std::string*                         node                           0;	///< Optional element.
/// Element pipeline of type xs:string.
    std::string*                         pipeline                       0;	///< Optional element.
/// Element stage of type xs:string.
    std::string*                         stage                          0;	///< Optional element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://iec.ch/TC57/2011/schema/message":ObjectType is a complexType.
/// class ns2__ObjectType operations:
/// - soap_new_ns2__ObjectType(soap*) allocate
/// - soap_new_ns2__ObjectType(soap*, int num) allocate array
/// - soap_new_req_ns2__ObjectType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__ObjectType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__ObjectType(soap*, ns2__ObjectType*) deserialize from a stream
/// - int soap_write_ns2__ObjectType(soap, ns2__ObjectType*) serialize to a stream
class ns2__ObjectType
{ public:
/// Element mRID of type xs:string.
    std::string*                         mRID                           0;	///< Optional element.
/// Vector of ns2__Name* with length 0..unbounded
    std::vector<ns2__Name*             > Name                           0;
/// Element objectType of type xs:string.
    std::string*                         objectType                     0;	///< Optional element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://iec.ch/TC57/2011/schema/message":NameType is a complexType.
/// class ns2__NameType operations:
/// - soap_new_ns2__NameType(soap*) allocate
/// - soap_new_ns2__NameType(soap*, int num) allocate array
/// - soap_new_req_ns2__NameType(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__NameType(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__NameType(soap*, ns2__NameType*) deserialize from a stream
/// - int soap_write_ns2__NameType(soap, ns2__NameType*) serialize to a stream
class ns2__NameType
{ public:
/// Element name of type xs:string.
    std::string                          name                           1;	///< Required element.
/// Element description of type xs:string.
    std::string*                         description                    0;	///< Optional element.
/// Element NameTypeAuthority of type "http://iec.ch/TC57/2011/schema/message":NameTypeAuthority.
    ns2__NameTypeAuthority*              NameTypeAuthority              0;	///< Optional element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://iec.ch/TC57/2011/schema/message":Name is a complexType.
/// class ns2__Name operations:
/// - soap_new_ns2__Name(soap*) allocate
/// - soap_new_ns2__Name(soap*, int num) allocate array
/// - soap_new_req_ns2__Name(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__Name(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__Name(soap*, ns2__Name*) deserialize from a stream
/// - int soap_write_ns2__Name(soap, ns2__Name*) serialize to a stream
class ns2__Name
{ public:
/// Element name of type xs:string.
    std::string                          name                           1;	///< Required element.
/// Element NameType of type "http://iec.ch/TC57/2011/schema/message":NameType.
    ns2__NameType*                       NameType                       0;	///< Optional element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://iec.ch/TC57/2011/schema/message":NameTypeAuthority is a complexType.
/// class ns2__NameTypeAuthority operations:
/// - soap_new_ns2__NameTypeAuthority(soap*) allocate
/// - soap_new_ns2__NameTypeAuthority(soap*, int num) allocate array
/// - soap_new_req_ns2__NameTypeAuthority(soap*, ...) allocate, set required members
/// - soap_new_set_ns2__NameTypeAuthority(soap*, ...) allocate, set all public members
/// - int soap_read_ns2__NameTypeAuthority(soap*, ns2__NameTypeAuthority*) deserialize from a stream
/// - int soap_write_ns2__NameTypeAuthority(soap, ns2__NameTypeAuthority*) serialize to a stream
class ns2__NameTypeAuthority
{ public:
/// Element name of type xs:string.
    std::string                          name                           1;	///< Required element.
/// Element description of type xs:string.
    std::string*                         description                    0;	///< Optional element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/******************************************************************************\
 *                                                                            *
 * Schema Complex Types and Top-Level Elements                                *
 *   http://www.sznari.com/2015/schema/message                                *
 *                                                                            *
\******************************************************************************/


/// "http://www.sznari.com/2015/schema/message":ArrayValuesType is a complexType.
/// @brief
/// class ns3__ArrayValuesType operations:
/// - soap_new_ns3__ArrayValuesType(soap*) allocate
/// - soap_new_ns3__ArrayValuesType(soap*, int num) allocate array
/// - soap_new_req_ns3__ArrayValuesType(soap*, ...) allocate, set required members
/// - soap_new_set_ns3__ArrayValuesType(soap*, ...) allocate, set all public members
/// - int soap_read_ns3__ArrayValuesType(soap*, ns3__ArrayValuesType*) deserialize from a stream
/// - int soap_write_ns3__ArrayValuesType(soap, ns3__ArrayValuesType*) serialize to a stream
class ns3__ArrayValuesType
{ public:
/// Element ArrayCode of type xs:string.
    std::string                          ArrayCode                      1;	///< Required element.
/// Vector of ns3__DeviceClassType* with length 0..unbounded
    std::vector<ns3__DeviceClassType*  > DeviceClasses                  0;
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://www.sznari.com/2015/schema/message":DeviceClassType is a complexType.
/// @brief
/// class ns3__DeviceClassType operations:
/// - soap_new_ns3__DeviceClassType(soap*) allocate
/// - soap_new_ns3__DeviceClassType(soap*, int num) allocate array
/// - soap_new_req_ns3__DeviceClassType(soap*, ...) allocate, set required members
/// - soap_new_set_ns3__DeviceClassType(soap*, ...) allocate, set all public members
/// - int soap_read_ns3__DeviceClassType(soap*, ns3__DeviceClassType*) deserialize from a stream
/// - int soap_write_ns3__DeviceClassType(soap, ns3__DeviceClassType*) serialize to a stream
class ns3__DeviceClassType
{ public:
/// Element ClassName of type xs:string.
    std::string                          ClassName                      1;	///< Required element.
/// Vector of ns3__DeviceValuesType* with length 0..unbounded
    std::vector<ns3__DeviceValuesType* > Devices                        0;
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://www.sznari.com/2015/schema/message":DeviceValuesType is a complexType.
/// @brief
/// class ns3__DeviceValuesType operations:
/// - soap_new_ns3__DeviceValuesType(soap*) allocate
/// - soap_new_ns3__DeviceValuesType(soap*, int num) allocate array
/// - soap_new_req_ns3__DeviceValuesType(soap*, ...) allocate, set required members
/// - soap_new_set_ns3__DeviceValuesType(soap*, ...) allocate, set all public members
/// - int soap_read_ns3__DeviceValuesType(soap*, ns3__DeviceValuesType*) deserialize from a stream
/// - int soap_write_ns3__DeviceValuesType(soap, ns3__DeviceValuesType*) serialize to a stream
class ns3__DeviceValuesType
{ public:
/// Element Code of type xs:string.
    std::string                          Code                           1;	///< Required element.
/// Vector of ns3__CommonValuesType* with length 0..unbounded
    std::vector<ns3__CommonValuesType* > RemoteSignal                   0;
/// Vector of ns3__CommonValuesType* with length 0..unbounded
    std::vector<ns3__CommonValuesType* > RemoteMeasure                  0;
/// Vector of ns3__CommonValuesType* with length 0..unbounded
    std::vector<ns3__CommonValuesType* > RemoteDegree                   0;
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://www.sznari.com/2015/schema/message":CommonValuesType is a complexType.
/// class ns3__CommonValuesType operations:
/// - soap_new_ns3__CommonValuesType(soap*) allocate
/// - soap_new_ns3__CommonValuesType(soap*, int num) allocate array
/// - soap_new_req_ns3__CommonValuesType(soap*, ...) allocate, set required members
/// - soap_new_set_ns3__CommonValuesType(soap*, ...) allocate, set all public members
/// - int soap_read_ns3__CommonValuesType(soap*, ns3__CommonValuesType*) deserialize from a stream
/// - int soap_write_ns3__CommonValuesType(soap, ns3__CommonValuesType*) serialize to a stream
class ns3__CommonValuesType
{ public:
/// Element Key of type xs:string.
    std::string                          Key                            1;	///< Required element.
/// Element Value of type xs:string.
    std::string*                         Value                          0;	///< Optional element.
/// Element UpperLimit of type xs:boolean.
    bool*                                UpperLimit                     0;	///< Optional element.
/// Element UpperUpperLimit of type xs:boolean.
    bool*                                UpperUpperLimit                0;	///< Optional element.
/// Element LowerLimit of type xs:boolean.
    bool*                                LowerLimit                     0;	///< Optional element.
/// Element LowerLowerLimit of type xs:boolean.
    bool*                                LowerLowerLimit                0;	///< Optional element.
/// Element Dead of type xs:boolean.
    bool*                                Dead                           0;	///< Optional element.
/// Element Invalid of type xs:boolean.
    bool*                                Invalid                        0;	///< Optional element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/******************************************************************************\
 *                                                                            *
 * Additional Top-Level Elements                                              *
 *   http://iec.ch/TC57/2011/schema/message                                   *
 *                                                                            *
\******************************************************************************/


/// Top-level root element "http://iec.ch/TC57/2011/schema/message":PublishEvent of type "http://iec.ch/TC57/2011/schema/message":EventMessageType.
/// Note: use wsdl2h option -g to auto-generate a top-level root element declaration and processing code.

/// Top-level root element "http://iec.ch/TC57/2011/schema/message":Request of type "http://iec.ch/TC57/2011/schema/message":RequestMessageType.
/// Note: use wsdl2h option -g to auto-generate a top-level root element declaration and processing code.

/// Top-level root element "http://iec.ch/TC57/2011/schema/message":Response of type "http://iec.ch/TC57/2011/schema/message":ResponseMessageType.
/// Note: use wsdl2h option -g to auto-generate a top-level root element declaration and processing code.

/// Top-level root element "http://iec.ch/TC57/2011/schema/message":Message of type "http://iec.ch/TC57/2011/schema/message":MessageType.
/// Note: use wsdl2h option -g to auto-generate a top-level root element declaration and processing code.

/// Top-level root element "http://iec.ch/TC57/2011/schema/message":RequestMessage of type "http://iec.ch/TC57/2011/schema/message":RequestMessageType.
/// Note: use wsdl2h option -g to auto-generate a top-level root element declaration and processing code.

/// Top-level root element "http://iec.ch/TC57/2011/schema/message":ResponseMessage of type "http://iec.ch/TC57/2011/schema/message":ResponseMessageType.
/// Note: use wsdl2h option -g to auto-generate a top-level root element declaration and processing code.

/// Top-level root element "http://iec.ch/TC57/2011/schema/message":EventMessage of type "http://iec.ch/TC57/2011/schema/message":EventMessageType.
/// Note: use wsdl2h option -g to auto-generate a top-level root element declaration and processing code.

/// Top-level root element "http://iec.ch/TC57/2011/schema/message":FaultMessage of type "http://iec.ch/TC57/2011/schema/message":FaultMessageType.
/// Note: use wsdl2h option -g to auto-generate a top-level root element declaration and processing code.

/******************************************************************************\
 *                                                                            *
 * Additional Top-Level Attributes                                            *
 *   http://iec.ch/TC57/2011/schema/message                                   *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Additional Top-Level Elements                                              *
 *   http://www.sznari.com/2015/schema/message                                *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Additional Top-Level Attributes                                            *
 *   http://www.sznari.com/2015/schema/message                                *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Services                                                                   *
 *                                                                            *
\******************************************************************************/


//gsoap ns1  service name:	SOAP 
//gsoap ns1  service type:	Operations 
//gsoap ns1  service port:	http://iec.ch/61968/ 
//gsoap ns1  service namespace:	http://iec.ch/TC57/2011/abstract 
//gsoap ns1  service transport:	http://schemas.xmlsoap.org/soap/http 

/** @mainpage Service Definitions

@section Service_bindings Service Bindings

  - @ref SOAP

@section Service_more More Information

  - @ref page_notes "Usage Notes"

  - @ref page_XMLDataBinding "XML Data Binding"

  - @ref SOAP_ENV__Header "SOAP Header Content" (when applicable)

  - @ref SOAP_ENV__Detail "SOAP Fault Detail Content" (when applicable)


*/

/**

@page SOAP Binding "SOAP"

@section SOAP_operations Operations of Binding  "SOAP"

  - @ref __ns1__PublishEvent

  - @ref __ns1__Request

  - @ref __ns1__Response

@section SOAP_ports Endpoints of Binding  "SOAP"

  - http://iec.ch/61968/

Note: use wsdl2h option -Nname to change the service binding prefix name


*/

/******************************************************************************\
 *                                                                            *
 * Service Binding                                                            *
 *   SOAP                                                                     *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Service Operation                                                          *
 *   __ns1__PublishEvent                                                      *
 *                                                                            *
\******************************************************************************/


/// Operation "__ns1__PublishEvent" of service binding "SOAP"

/**

Operation details:

  - SOAP document/literal style messaging

  - Action: "http://iec.ch/61968/PublishEvent"

  - Addressing input action: "http://iec.ch/61968/PublishEvent"

  - Addressing output action: "http://iec.ch/61968/PublishEventResponse"

C stub function (defined in soapClient.c[pp] generated by soapcpp2):
@code
  int soap_call___ns1__PublishEvent(
    struct soap *soap,
    NULL, // char *endpoint = NULL selects default endpoint for this operation
    NULL, // char *action = NULL selects default action for this operation
    // input parameters:
    ns2__EventMessageType*              ns2__EventMessage,
    // output parameters:
    ns2__ResponseMessageType*           ns2__ResponseMessage
  );
@endcode

C server function (called from the service dispatcher defined in soapServer.c[pp]):
@code
  int __ns1__PublishEvent(
    struct soap *soap,
    // input parameters:
    ns2__EventMessageType*              ns2__EventMessage,
    // output parameters:
    ns2__ResponseMessageType*           ns2__ResponseMessage
  );
@endcode

C++ proxy class (defined in soapSOAPProxy.h):
@code
  class SOAPProxy;
@endcode
Important: use soapcpp2 option '-j' (or '-i') to generate greatly improved and easy-to-use proxy classes;

C++ service class (defined in soapSOAPService.h):
@code
  class SOAPService;
@endcode
Important: use soapcpp2 option '-j' (or '-i') to generate greatly improved and easy-to-use service classes;

*/

//gsoap ns1  service method-protocol:	PublishEvent SOAP
//gsoap ns1  service method-style:	PublishEvent document
//gsoap ns1  service method-encoding:	PublishEvent literal
//gsoap ns1  service method-input-action:	PublishEvent http://iec.ch/61968/PublishEvent
//gsoap ns1  service method-output-action:	PublishEvent http://iec.ch/61968/PublishEventResponse
int __ns1__PublishEvent(
    ns2__EventMessageType*              ns2__EventMessage,	///< Input parameter
    ns2__ResponseMessageType*           ns2__ResponseMessage	///< Output parameter
);

/******************************************************************************\
 *                                                                            *
 * Service Operation                                                          *
 *   __ns1__Request                                                           *
 *                                                                            *
\******************************************************************************/


/// Operation "__ns1__Request" of service binding "SOAP"

/**

Operation details:

  - SOAP document/literal style messaging

  - Action: "http://iec.ch/61968/Requ est"

  - Addressing input action: "http://iec.ch/61968/Requ est"

  - Addressing output action: "http://iec.ch/61968/Requ estResponse"

C stub function (defined in soapClient.c[pp] generated by soapcpp2):
@code
  int soap_call___ns1__Request(
    struct soap *soap,
    NULL, // char *endpoint = NULL selects default endpoint for this operation
    NULL, // char *action = NULL selects default action for this operation
    // input parameters:
    ns2__RequestMessageType*            ns2__RequestMessage,
    // output parameters:
    ns2__ResponseMessageType*           ns2__ResponseMessage
  );
@endcode

C server function (called from the service dispatcher defined in soapServer.c[pp]):
@code
  int __ns1__Request(
    struct soap *soap,
    // input parameters:
    ns2__RequestMessageType*            ns2__RequestMessage,
    // output parameters:
    ns2__ResponseMessageType*           ns2__ResponseMessage
  );
@endcode

C++ proxy class (defined in soapSOAPProxy.h):
@code
  class SOAPProxy;
@endcode
Important: use soapcpp2 option '-j' (or '-i') to generate greatly improved and easy-to-use proxy classes;

C++ service class (defined in soapSOAPService.h):
@code
  class SOAPService;
@endcode
Important: use soapcpp2 option '-j' (or '-i') to generate greatly improved and easy-to-use service classes;

*/

//gsoap ns1  service method-protocol:	Request SOAP
//gsoap ns1  service method-style:	Request document
//gsoap ns1  service method-encoding:	Request literal
//gsoap ns1  service method-input-action:	Request http://iec.ch/61968/Requ est
//gsoap ns1  service method-output-action:	Request http://iec.ch/61968/Requ estResponse
int __ns1__Request(
    ns2__RequestMessageType*            ns2__RequestMessage,	///< Input parameter
    ns2__ResponseMessageType*           ns2__ResponseMessage	///< Output parameter
);

/******************************************************************************\
 *                                                                            *
 * Service Operation                                                          *
 *   __ns1__Response                                                          *
 *                                                                            *
\******************************************************************************/

/// Operation response struct "__ns1__ResponseResponse" of operation "__ns1__Response"
struct __ns1__ResponseResponse
{
    ns2__ResponseMessageType*           ns2__ResponseMessage;
};

/// Operation "__ns1__Response" of service binding "SOAP"

/**

Operation details:

  - SOAP document/literal style messaging

  - Action: "http://iec.ch/61968/Response"

  - Addressing input action: "http://iec.ch/61968/Response"

  - Addressing output action: "http://iec.ch/61968/ResponseResponse"

C stub function (defined in soapClient.c[pp] generated by soapcpp2):
@code
  int soap_call___ns1__Response(
    struct soap *soap,
    NULL, // char *endpoint = NULL selects default endpoint for this operation
    NULL, // char *action = NULL selects default action for this operation
    // input parameters:
    ns2__ResponseMessageType*           ns2__ResponseMessage,
    // output parameters:
    struct __ns1__ResponseResponse&
  );
@endcode

C server function (called from the service dispatcher defined in soapServer.c[pp]):
@code
  int __ns1__Response(
    struct soap *soap,
    // input parameters:
    ns2__ResponseMessageType*           ns2__ResponseMessage,
    // output parameters:
    struct __ns1__ResponseResponse&
  );
@endcode

C++ proxy class (defined in soapSOAPProxy.h):
@code
  class SOAPProxy;
@endcode
Important: use soapcpp2 option '-j' (or '-i') to generate greatly improved and easy-to-use proxy classes;

C++ service class (defined in soapSOAPService.h):
@code
  class SOAPService;
@endcode
Important: use soapcpp2 option '-j' (or '-i') to generate greatly improved and easy-to-use service classes;

*/

//gsoap ns1  service method-protocol:	Response SOAP
//gsoap ns1  service method-style:	Response document
//gsoap ns1  service method-encoding:	Response literal
//gsoap ns1  service method-input-action:	Response http://iec.ch/61968/Response
//gsoap ns1  service method-output-action:	Response http://iec.ch/61968/ResponseResponse
int __ns1__Response(
    ns2__ResponseMessageType*           ns2__ResponseMessage,	///< Input parameter
    struct __ns1__ResponseResponse     &	///< Output response struct parameter
);

/**

@page SOAP Binding "SOAP"

@section SOAP_policy_enablers Policy Enablers of Binding  "SOAP"

Based on policies, this service imports

  - WS-Policy reminders and enablers:
    - WS-Addressing 1.0 (2005/08, accepts 2004/08):
	@code
	#import "wsa5.h" // to be added to this header file for the soapcpp2 build step
	@endcode
	@code
	#include "plugin/wsaapi.h"
	soap_register_plugin(soap, soap_wsa); // register the wsa plugin in your code
	// See the user guide gsoap/doc/wsa/html/index.html
	@endcode
    - WS-Addressing (2004/08):
	@code
	#import "wsa.h" // to be added to this header file for the soapcpp2 build step
	@endcode
	@code
	#include "plugin/wsaapi.h"
	soap_register_plugin(soap, soap_wsa); // register the wsa plugin in your code
	// See the user guide gsoap/doc/wsa/html/index.html
	@endcode
    - WS-ReliableMessaging 1.0:
	@code
	#import "wsrm5.h" // to be added to this header file for the soapcpp2 build step
	@endcode
	@code
	#include "plugin/wsrmapi.h"
	soap_register_plugin(soap, soap_wsa); // register the wsa plugin in your code
	soap_register_plugin(soap, soap_wsrm); // register the wsrm plugin in your code
	// See the user guide gsoap/doc/wsrm/html/index.html
	@endcode
    - WS-ReliableMessaging 1.1:
	@code
	#import "wsrm.h" // to be added to this header file for the soapcpp2 build step
	@endcode
	@code
	#include "plugin/wsrmapi.h"
	soap_register_plugin(soap, soap_wsa); // register the wsa plugin in your code
	soap_register_plugin(soap, soap_wsrm); // register the wsrm plugin in your code
	// See the user guide gsoap/doc/wsrm/html/index.html
	@endcode
    - WS-Security (SOAP Message Security) 1.0 (accepts 1.1):
	@code
	#import "wsse.h" // to be added to this header file for the soapcpp2 build step
	@endcode
	@code
	#include "plugin/wsseapi.h"
	soap_register_plugin(soap, soap_wsse); // register the wsse plugin in your code
	// See the user guide gsoap/doc/wsse/html/index.html
	@endcode
    - WS-Security (SOAP Message Security) 1.1 (accepts 1.0):
	@code
	#import "wsse11.h" // to be added to this header file for the soapcpp2 build step
	@endcode
	@code
	#include "plugin/wsseapi.h"
	soap_register_plugin(soap, soap_wsse); // register the wsse plugin in your code
	// See the user guide gsoap/doc/wsse/html/index.html
	@endcode
    - HTTP Digest Authentication:
	@code
	#include "plugin/httpda.h"
	soap_register_plugin(soap, soap_http_da); // register the HTTP DA plugin in your code
	// See the user guide gsoap/doc/httpda/html/index.html
	@endcode
*/


/******************************************************************************\
 *                                                                            *
 * XML Data Binding                                                           *
 *                                                                            *
\******************************************************************************/


/**

@page page_XMLDataBinding XML Data Binding

SOAP/XML services use data bindings contractually bound by WSDL and auto-
generated by wsdl2h and soapcpp2 (see Service Bindings). Plain data bindings
are adopted from XML schemas as part of the WSDL types section or when running
wsdl2h on a set of schemas to produce non-SOAP-based XML data bindings.

The following readers and writers are C/C++ data type (de)serializers auto-
generated by wsdl2h and soapcpp2. Run soapcpp2 on this file to generate the
(de)serialization code, which is stored in soapC.c[pp]. Include "soapH.h" in
your code to import these data type and function declarations. Only use the
soapcpp2-generated files in your project build. Do not include the wsdl2h-
generated .h file in your code.

Data can be read in XML and deserialized from:
  - a file descriptor, using soap->recvfd = fd
  - a socket, using soap->socket = ...
  - a C++ stream, using soap->is = ...
  - a buffer, using the soap->frecv() callback

Data can be serialized in XML and written to:
  - a file descriptor, using soap->sendfd = fd
  - a socket, using soap->socket = ...
  - a C++ stream, using soap->os = ...
  - a buffer, using the soap->fsend() callback

The following options are available for (de)serialization control:
  - soap->encodingStyle = NULL; to remove SOAP 1.1/1.2 encodingStyle
  - soap_mode(soap, SOAP_XML_TREE); XML without id-ref (no cycles!)
  - soap_mode(soap, SOAP_XML_GRAPH); XML with id-ref (including cycles)
  - soap_set_namespaces(soap, struct Namespace *nsmap); to set xmlns bindings


@section ns2 Top-level root elements of schema "http://iec.ch/TC57/2011/schema/message"

  - <ns2:PublishEvent> (use wsdl2h option -g to auto-generate)

  - <ns2:Request> (use wsdl2h option -g to auto-generate)

  - <ns2:Response> (use wsdl2h option -g to auto-generate)

  - <ns2:Message> (use wsdl2h option -g to auto-generate)

  - <ns2:RequestMessage> (use wsdl2h option -g to auto-generate)

  - <ns2:ResponseMessage> (use wsdl2h option -g to auto-generate)

  - <ns2:EventMessage> (use wsdl2h option -g to auto-generate)

  - <ns2:FaultMessage> (use wsdl2h option -g to auto-generate)

@section ns3 Top-level root elements of schema "http://www.sznari.com/2015/schema/message"

*/

/* End of getData.h */
