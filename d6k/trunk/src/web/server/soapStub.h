/* soapStub.h
   Generated by gSOAP 2.8.16 from getData.h

Copyright(C) 2000-2013, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
GPL or Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#ifndef soapStub_H
#define soapStub_H
#include <vector>
#define SOAP_NAMESPACE_OF_ns2	"http://iec.ch/TC57/2011/schema/message"
#define SOAP_NAMESPACE_OF_ns3	"http://www.sznari.com/2015/schema/message"
#include "stdsoap2.h"
#if GSOAP_VERSION != 20816
# error "GSOAP VERSION MISMATCH IN GENERATED CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Enumerations                                                               *
 *                                                                            *
\******************************************************************************/


#ifndef SOAP_TYPE_ns2__IDKindType
#define SOAP_TYPE_ns2__IDKindType (36)
/* ns2:IDKindType */
enum ns2__IDKindType { ns2__IDKindType__name = 0, ns2__IDKindType__uuid = 1, ns2__IDKindType__transaction = 2, ns2__IDKindType__other = 3 };
#endif

#ifndef SOAP_TYPE__ns2__ReplyType_Result
#define SOAP_TYPE__ns2__ReplyType_Result (48)
/* ns2:ReplyType-Result */
enum _ns2__ReplyType_Result { _ns2__ReplyType_Result__OK = 0, _ns2__ReplyType_Result__PARTIAL = 1, _ns2__ReplyType_Result__FAILED = 2 };
#endif

#ifndef SOAP_TYPE__ns2__HeaderType_Verb
#define SOAP_TYPE__ns2__HeaderType_Verb (73)
/* ns2:HeaderType-Verb */
enum _ns2__HeaderType_Verb { _ns2__HeaderType_Verb__cancel = 0, _ns2__HeaderType_Verb__canceled = 1, _ns2__HeaderType_Verb__change = 2, _ns2__HeaderType_Verb__changed = 3, _ns2__HeaderType_Verb__create = 4, _ns2__HeaderType_Verb__created = 5, _ns2__HeaderType_Verb__close = 6, _ns2__HeaderType_Verb__closed = 7, _ns2__HeaderType_Verb__delete_ = 8, _ns2__HeaderType_Verb__deleted = 9, _ns2__HeaderType_Verb__get = 10, _ns2__HeaderType_Verb__reply = 11, _ns2__HeaderType_Verb__execute = 12, _ns2__HeaderType_Verb__executed = 13 };
#endif

#ifndef SOAP_TYPE__ns2__ErrorType_level
#define SOAP_TYPE__ns2__ErrorType_level (82)
/* ns2:ErrorType-level */
enum _ns2__ErrorType_level { _ns2__ErrorType_level__INFORM = 0, _ns2__ErrorType_level__WARNING = 1, _ns2__ErrorType_level__FATAL = 2, _ns2__ErrorType_level__CATASTROPHIC = 3 };
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/

#ifndef SOAP_TYPE_xsd__QName
#define SOAP_TYPE_xsd__QName (9)
typedef std::string xsd__QName;
#endif


/******************************************************************************\
 *                                                                            *
 * Classes and Structs                                                        *
 *                                                                            *
\******************************************************************************/


#if 0 /* volatile type: do not declare here, declared elsewhere */

#endif

#if 0 /* volatile type: do not declare here, declared elsewhere */

#endif

#ifndef SOAP_TYPE__ns2__RequestType_ID
#define SOAP_TYPE__ns2__RequestType_ID (41)
/* Primitive ns2:RequestType-ID schema type: */
class SOAP_CMAC _ns2__RequestType_ID
{
public:
	std::string __item;
	std::string *idType;	/* optional attribute */
	std::string *idAuthority;	/* optional attribute */
	enum ns2__IDKindType *kind;	/* optional attribute */
	std::string *objectType;	/* optional attribute */
public:
	virtual int soap_type() const { return 41; } /* = unique id SOAP_TYPE__ns2__RequestType_ID */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__RequestType_ID() { _ns2__RequestType_ID::soap_default(NULL); }
	virtual ~_ns2__RequestType_ID() { }
};
#endif

#ifndef SOAP_TYPE_ns2__RequestType
#define SOAP_TYPE_ns2__RequestType (11)
/* ns2:RequestType */
class SOAP_CMAC ns2__RequestType
{
public:
	time_t *StartTime;	/* optional element of type xsd:dateTime */
	time_t *EndTime;	/* optional element of type xsd:dateTime */
	std::vector<class ns2__OptionType * >Option;	/* optional element of type ns2:OptionType */
	std::vector<_ns2__RequestType_ID >*ID;	/* optional element of type ns2:RequestType-ID */
	std::vector<char * >__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 11; } /* = unique id SOAP_TYPE_ns2__RequestType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__RequestType() { ns2__RequestType::soap_default(NULL); }
	virtual ~ns2__RequestType() { }
};
#endif

#ifndef SOAP_TYPE__ns2__ReplyType_ID
#define SOAP_TYPE__ns2__ReplyType_ID (51)
/* Primitive ns2:ReplyType-ID schema type: */
class SOAP_CMAC _ns2__ReplyType_ID
{
public:
	std::string __item;
	std::string *idType;	/* optional attribute */
	std::string *idAuthority;	/* optional attribute */
	enum ns2__IDKindType *kind;	/* optional attribute */
	std::string *objectType;	/* optional attribute */
public:
	virtual int soap_type() const { return 51; } /* = unique id SOAP_TYPE__ns2__ReplyType_ID */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__ReplyType_ID() { _ns2__ReplyType_ID::soap_default(NULL); }
	virtual ~_ns2__ReplyType_ID() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ReplyType
#define SOAP_TYPE_ns2__ReplyType (12)
/* ns2:ReplyType */
class SOAP_CMAC ns2__ReplyType
{
public:
	enum _ns2__ReplyType_Result Result;	/* required element of type ns2:ReplyType-Result */
	std::vector<class ns2__ErrorType * >Error;	/* optional element of type ns2:ErrorType */
	std::vector<_ns2__ReplyType_ID >*ID;	/* optional element of type ns2:ReplyType-ID */
	std::vector<char * >__any;
	std::string *operationId;	/* optional element of type xsd:integer */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 12; } /* = unique id SOAP_TYPE_ns2__ReplyType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ReplyType() { ns2__ReplyType::soap_default(NULL); }
	virtual ~ns2__ReplyType() { }
};
#endif

#ifndef SOAP_TYPE__ns2__PayloadType_ID
#define SOAP_TYPE__ns2__PayloadType_ID (65)
/* Primitive ns2:PayloadType-ID schema type: */
class SOAP_CMAC _ns2__PayloadType_ID
{
public:
	std::string __item;
	std::string *idType;	/* optional attribute */
	std::string *idAuthority;	/* optional attribute */
	enum ns2__IDKindType *kind;	/* optional attribute */
	std::string *objectType;	/* optional attribute */
public:
	virtual int soap_type() const { return 65; } /* = unique id SOAP_TYPE__ns2__PayloadType_ID */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__PayloadType_ID() { _ns2__PayloadType_ID::soap_default(NULL); }
	virtual ~_ns2__PayloadType_ID() { }
};
#endif

#ifndef SOAP_TYPE__ns2__union_PayloadType
#define SOAP_TYPE__ns2__union_PayloadType (68)
/* xsd:choice */
union _ns2__union_PayloadType
{
#define SOAP_UNION__ns2__union_PayloadType_CommonValues	(1)
	std::vector<class ns3__CommonValuesType * >*CommonValues;
#define SOAP_UNION__ns2__union_PayloadType_DeviceValues	(2)
	std::vector<class ns3__DeviceValuesType * >*DeviceValues;
#define SOAP_UNION__ns2__union_PayloadType_ArrayValues	(3)
	std::vector<class ns3__ArrayValuesType * >*ArrayValues;
#define SOAP_UNION__ns2__union_PayloadType_OperationSet	(4)
	class ns2__OperationSet *OperationSet;
#define SOAP_UNION__ns2__union_PayloadType_Compressed	(5)
	std::string *Compressed;
#define SOAP_UNION__ns2__union_PayloadType_ID	(6)
	std::vector<_ns2__PayloadType_ID >*ID;
};
#endif

#ifndef SOAP_TYPE_ns2__PayloadType
#define SOAP_TYPE_ns2__PayloadType (13)
/* ns2:PayloadType */
class SOAP_CMAC ns2__PayloadType
{
public:
	int __union_PayloadType;	/* union discriminant (of union defined below) */
	union _ns2__union_PayloadType union_PayloadType;	/* required element of type xsd:choice */
	std::string *Format;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 13; } /* = unique id SOAP_TYPE_ns2__PayloadType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__PayloadType() { ns2__PayloadType::soap_default(NULL); }
	virtual ~ns2__PayloadType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__OperationType
#define SOAP_TYPE_ns2__OperationType (14)
/* ns2:OperationType */
class SOAP_CMAC ns2__OperationType
{
public:
	std::string operationId;	/* required element of type xsd:integer */
	std::string *noun;	/* optional element of type xsd:string */
	std::string *verb;	/* optional element of type xsd:string */
	bool elementOperation;	/* optional element of type xsd:boolean */
	char *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 14; } /* = unique id SOAP_TYPE_ns2__OperationType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__OperationType() { ns2__OperationType::soap_default(NULL); }
	virtual ~ns2__OperationType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__OperationSet
#define SOAP_TYPE_ns2__OperationSet (15)
/* ns2:OperationSet */
class SOAP_CMAC ns2__OperationSet
{
public:
	bool *enforceMsgSequence;	/* optional element of type xsd:boolean */
	bool *enforceTransactionalIntegrity;	/* optional element of type xsd:boolean */
	std::vector<ns2__OperationType * >Operation;	/* optional element of type ns2:OperationType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 15; } /* = unique id SOAP_TYPE_ns2__OperationSet */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__OperationSet() { ns2__OperationSet::soap_default(NULL); }
	virtual ~ns2__OperationSet() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ReplayDetectionType
#define SOAP_TYPE_ns2__ReplayDetectionType (16)
/* ns2:ReplayDetectionType */
class SOAP_CMAC ns2__ReplayDetectionType
{
public:
	std::string Nonce;	/* required element of type xsd:string */
	time_t Created;	/* required element of type xsd:dateTime */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 16; } /* = unique id SOAP_TYPE_ns2__ReplayDetectionType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ReplayDetectionType() { ns2__ReplayDetectionType::soap_default(NULL); }
	virtual ~ns2__ReplayDetectionType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__UserType
#define SOAP_TYPE_ns2__UserType (17)
/* ns2:UserType */
class SOAP_CMAC ns2__UserType
{
public:
	std::string UserID;	/* required element of type xsd:string */
	std::string *Organization;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 17; } /* = unique id SOAP_TYPE_ns2__UserType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__UserType() { ns2__UserType::soap_default(NULL); }
	virtual ~ns2__UserType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__HeaderType
#define SOAP_TYPE_ns2__HeaderType (18)
/* ns2:HeaderType */
class SOAP_CMAC ns2__HeaderType
{
public:
	enum _ns2__HeaderType_Verb Verb;	/* required element of type ns2:HeaderType-Verb */
	std::string Noun;	/* required element of type xsd:string */
	std::string *Revision;	/* optional element of type xsd:string */
	ns2__ReplayDetectionType *ReplayDetection;	/* optional element of type ns2:ReplayDetectionType */
	std::string *Context;	/* optional element of type xsd:string */
	time_t *Timestamp;	/* optional element of type xsd:dateTime */
	std::string *Source;	/* optional element of type xsd:string */
	bool *AsyncReplyFlag;	/* optional element of type xsd:boolean */
	std::string *ReplyAddress;	/* optional element of type xsd:string */
	bool *AckRequired;	/* optional element of type xsd:boolean */
	ns2__UserType *User;	/* optional element of type ns2:UserType */
	std::string *MessageID;	/* optional element of type xsd:string */
	std::string *CorrelationID;	/* optional element of type xsd:string */
	std::string *Comment;	/* optional element of type xsd:string */
	std::vector<class ns2__MessageProperty * >Property;	/* optional element of type ns2:MessageProperty */
	std::vector<char * >__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 18; } /* = unique id SOAP_TYPE_ns2__HeaderType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__HeaderType() { ns2__HeaderType::soap_default(NULL); }
	virtual ~ns2__HeaderType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__MessageProperty
#define SOAP_TYPE_ns2__MessageProperty (19)
/* ns2:MessageProperty */
class SOAP_CMAC ns2__MessageProperty
{
public:
	std::string Name;	/* required element of type xsd:string */
	std::string *Value;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 19; } /* = unique id SOAP_TYPE_ns2__MessageProperty */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__MessageProperty() { ns2__MessageProperty::soap_default(NULL); }
	virtual ~ns2__MessageProperty() { }
};
#endif

#ifndef SOAP_TYPE_ns2__MessageType
#define SOAP_TYPE_ns2__MessageType (20)
/* ns2:MessageType */
class SOAP_CMAC ns2__MessageType
{
public:
	ns2__HeaderType *Header;	/* required element of type ns2:HeaderType */
	ns2__RequestType *Request;	/* optional element of type ns2:RequestType */
	ns2__ReplyType *Reply;	/* optional element of type ns2:ReplyType */
	ns2__PayloadType *Payload;	/* optional element of type ns2:PayloadType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 20; } /* = unique id SOAP_TYPE_ns2__MessageType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__MessageType() { ns2__MessageType::soap_default(NULL); }
	virtual ~ns2__MessageType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__RequestMessageType
#define SOAP_TYPE_ns2__RequestMessageType (21)
/* ns2:RequestMessageType */
class SOAP_CMAC ns2__RequestMessageType
{
public:
	ns2__HeaderType *Header;	/* required element of type ns2:HeaderType */
	ns2__RequestType *Request;	/* optional element of type ns2:RequestType */
	ns2__PayloadType *Payload;	/* optional element of type ns2:PayloadType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 21; } /* = unique id SOAP_TYPE_ns2__RequestMessageType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__RequestMessageType() { ns2__RequestMessageType::soap_default(NULL); }
	virtual ~ns2__RequestMessageType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ResponseMessageType
#define SOAP_TYPE_ns2__ResponseMessageType (22)
/* ns2:ResponseMessageType */
class SOAP_CMAC ns2__ResponseMessageType
{
public:
	ns2__HeaderType *Header;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns2:HeaderType */
	ns2__ReplyType *Reply;	/* required element of type ns2:ReplyType */
	ns2__PayloadType *Payload;	/* optional element of type ns2:PayloadType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 22; } /* = unique id SOAP_TYPE_ns2__ResponseMessageType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ResponseMessageType() { ns2__ResponseMessageType::soap_default(NULL); }
	virtual ~ns2__ResponseMessageType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__FaultMessageType
#define SOAP_TYPE_ns2__FaultMessageType (23)
/* ns2:FaultMessageType */
class SOAP_CMAC ns2__FaultMessageType
{
public:
	ns2__ReplyType *Reply;	/* required element of type ns2:ReplyType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 23; } /* = unique id SOAP_TYPE_ns2__FaultMessageType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__FaultMessageType() { ns2__FaultMessageType::soap_default(NULL); }
	virtual ~ns2__FaultMessageType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__EventMessageType
#define SOAP_TYPE_ns2__EventMessageType (24)
/* ns2:EventMessageType */
class SOAP_CMAC ns2__EventMessageType
{
public:
	ns2__HeaderType *Header;	/* required element of type ns2:HeaderType */
	ns2__PayloadType *Payload;	/* optional element of type ns2:PayloadType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 24; } /* = unique id SOAP_TYPE_ns2__EventMessageType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__EventMessageType() { ns2__EventMessageType::soap_default(NULL); }
	virtual ~ns2__EventMessageType() { }
};
#endif

#ifndef SOAP_TYPE__ns2__ErrorType_ID
#define SOAP_TYPE__ns2__ErrorType_ID (86)
/* Primitive ns2:ErrorType-ID schema type: */
class SOAP_CMAC _ns2__ErrorType_ID
{
public:
	std::string __item;
	std::string *idType;	/* optional attribute */
	std::string *idAuthority;	/* optional attribute */
	enum ns2__IDKindType *kind;	/* optional attribute */
	std::string *objectType;	/* optional attribute */
public:
	virtual int soap_type() const { return 86; } /* = unique id SOAP_TYPE__ns2__ErrorType_ID */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__ErrorType_ID() { _ns2__ErrorType_ID::soap_default(NULL); }
	virtual ~_ns2__ErrorType_ID() { }
};
#endif

#ifndef SOAP_TYPE__ns2__ErrorType_relatedID
#define SOAP_TYPE__ns2__ErrorType_relatedID (88)
/* Primitive ns2:ErrorType-relatedID schema type: */
class SOAP_CMAC _ns2__ErrorType_relatedID
{
public:
	std::string __item;
	std::string *idType;	/* optional attribute */
	std::string *idAuthority;	/* optional attribute */
	enum ns2__IDKindType *kind;	/* optional attribute */
	std::string *objectType;	/* optional attribute */
public:
	virtual int soap_type() const { return 88; } /* = unique id SOAP_TYPE__ns2__ErrorType_relatedID */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__ErrorType_relatedID() { _ns2__ErrorType_relatedID::soap_default(NULL); }
	virtual ~_ns2__ErrorType_relatedID() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ErrorType
#define SOAP_TYPE_ns2__ErrorType (25)
/* ns2:ErrorType */
class SOAP_CMAC ns2__ErrorType
{
public:
	std::string code;	/* required element of type xsd:string */
	enum _ns2__ErrorType_level *level;	/* optional element of type ns2:ErrorType-level */
	std::string *reason;	/* optional element of type xsd:string */
	std::string *details;	/* optional element of type xsd:string */
	std::string *xpath;	/* optional element of type xsd:QName */
	std::string *stackTrace;	/* optional element of type xsd:string */
	class ns2__LocationType *Location;	/* optional element of type ns2:LocationType */
	_ns2__ErrorType_ID *ID;	/* optional element of type ns2:ErrorType-ID */
	_ns2__ErrorType_relatedID *relatedID;	/* optional element of type ns2:ErrorType-relatedID */
	class ns2__ObjectType *object;	/* optional element of type ns2:ObjectType */
	std::string *operationId;	/* optional element of type xsd:integer */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 25; } /* = unique id SOAP_TYPE_ns2__ErrorType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ErrorType() { ns2__ErrorType::soap_default(NULL); }
	virtual ~ns2__ErrorType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__OptionType
#define SOAP_TYPE_ns2__OptionType (26)
/* ns2:OptionType */
class SOAP_CMAC ns2__OptionType
{
public:
	std::string name;	/* required element of type xsd:string */
	std::string *value;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 26; } /* = unique id SOAP_TYPE_ns2__OptionType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__OptionType() { ns2__OptionType::soap_default(NULL); }
	virtual ~ns2__OptionType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__LocationType
#define SOAP_TYPE_ns2__LocationType (27)
/* ns2:LocationType */
class SOAP_CMAC ns2__LocationType
{
public:
	std::string *node;	/* optional element of type xsd:string */
	std::string *pipeline;	/* optional element of type xsd:string */
	std::string *stage;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 27; } /* = unique id SOAP_TYPE_ns2__LocationType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__LocationType() { ns2__LocationType::soap_default(NULL); }
	virtual ~ns2__LocationType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ObjectType
#define SOAP_TYPE_ns2__ObjectType (28)
/* ns2:ObjectType */
class SOAP_CMAC ns2__ObjectType
{
public:
	std::string *mRID;	/* optional element of type xsd:string */
	std::vector<class ns2__Name * >Name;	/* optional element of type ns2:Name */
	std::string *objectType;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 28; } /* = unique id SOAP_TYPE_ns2__ObjectType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ObjectType() { ns2__ObjectType::soap_default(NULL); }
	virtual ~ns2__ObjectType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__NameType
#define SOAP_TYPE_ns2__NameType (29)
/* ns2:NameType */
class SOAP_CMAC ns2__NameType
{
public:
	std::string name;	/* required element of type xsd:string */
	std::string *description;	/* optional element of type xsd:string */
	class ns2__NameTypeAuthority *NameTypeAuthority;	/* optional element of type ns2:NameTypeAuthority */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 29; } /* = unique id SOAP_TYPE_ns2__NameType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__NameType() { ns2__NameType::soap_default(NULL); }
	virtual ~ns2__NameType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__Name
#define SOAP_TYPE_ns2__Name (30)
/* ns2:Name */
class SOAP_CMAC ns2__Name
{
public:
	std::string name;	/* required element of type xsd:string */
	ns2__NameType *NameType;	/* optional element of type ns2:NameType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 30; } /* = unique id SOAP_TYPE_ns2__Name */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__Name() { ns2__Name::soap_default(NULL); }
	virtual ~ns2__Name() { }
};
#endif

#ifndef SOAP_TYPE_ns2__NameTypeAuthority
#define SOAP_TYPE_ns2__NameTypeAuthority (31)
/* ns2:NameTypeAuthority */
class SOAP_CMAC ns2__NameTypeAuthority
{
public:
	std::string name;	/* required element of type xsd:string */
	std::string *description;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 31; } /* = unique id SOAP_TYPE_ns2__NameTypeAuthority */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__NameTypeAuthority() { ns2__NameTypeAuthority::soap_default(NULL); }
	virtual ~ns2__NameTypeAuthority() { }
};
#endif

#ifndef SOAP_TYPE_ns3__ArrayValuesType
#define SOAP_TYPE_ns3__ArrayValuesType (32)
/* ns3:ArrayValuesType */
class SOAP_CMAC ns3__ArrayValuesType
{
public:
	std::string ArrayCode;	/* required element of type xsd:string */
	std::vector<class ns3__DeviceClassType * >DeviceClasses;	/* optional element of type ns3:DeviceClassType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 32; } /* = unique id SOAP_TYPE_ns3__ArrayValuesType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__ArrayValuesType() { ns3__ArrayValuesType::soap_default(NULL); }
	virtual ~ns3__ArrayValuesType() { }
};
#endif

#ifndef SOAP_TYPE_ns3__DeviceClassType
#define SOAP_TYPE_ns3__DeviceClassType (33)
/* ns3:DeviceClassType */
class SOAP_CMAC ns3__DeviceClassType
{
public:
	std::string ClassName;	/* required element of type xsd:string */
	std::vector<ns3__DeviceValuesType * >Devices;	/* optional element of type ns3:DeviceValuesType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 33; } /* = unique id SOAP_TYPE_ns3__DeviceClassType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__DeviceClassType() { ns3__DeviceClassType::soap_default(NULL); }
	virtual ~ns3__DeviceClassType() { }
};
#endif

#ifndef SOAP_TYPE_ns3__DeviceValuesType
#define SOAP_TYPE_ns3__DeviceValuesType (34)
/* ns3:DeviceValuesType */
class SOAP_CMAC ns3__DeviceValuesType
{
public:
	std::string Code;	/* required element of type xsd:string */
	std::vector<ns3__CommonValuesType * >RemoteSignal;	/* optional element of type ns3:CommonValuesType */
	std::vector<ns3__CommonValuesType * >RemoteMeasure;	/* optional element of type ns3:CommonValuesType */
	std::vector<ns3__CommonValuesType * >RemoteDegree;	/* optional element of type ns3:CommonValuesType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 34; } /* = unique id SOAP_TYPE_ns3__DeviceValuesType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__DeviceValuesType() { ns3__DeviceValuesType::soap_default(NULL); }
	virtual ~ns3__DeviceValuesType() { }
};
#endif

#ifndef SOAP_TYPE_ns3__CommonValuesType
#define SOAP_TYPE_ns3__CommonValuesType (35)
/* ns3:CommonValuesType */
class SOAP_CMAC ns3__CommonValuesType
{
public:
	std::string Key;	/* required element of type xsd:string */
	std::string *Value;	/* optional element of type xsd:string */
	bool *UpperLimit;	/* optional element of type xsd:boolean */
	bool *UpperUpperLimit;	/* optional element of type xsd:boolean */
	bool *LowerLimit;	/* optional element of type xsd:boolean */
	bool *LowerLowerLimit;	/* optional element of type xsd:boolean */
	bool *Dead;	/* optional element of type xsd:boolean */
	bool *Invalid;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 35; } /* = unique id SOAP_TYPE_ns3__CommonValuesType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__CommonValuesType() { ns3__CommonValuesType::soap_default(NULL); }
	virtual ~ns3__CommonValuesType() { }
};
#endif

#ifndef SOAP_TYPE___ns1__PublishEvent
#define SOAP_TYPE___ns1__PublishEvent (100)
/* Operation wrapper: */
struct __ns1__PublishEvent
{
public:
	ns2__EventMessageType *ns2__EventMessage;	/* optional element of type ns2:EventMessageType */
public:
	int soap_type() const { return 100; } /* = unique id SOAP_TYPE___ns1__PublishEvent */
};
#endif

#ifndef SOAP_TYPE___ns1__Request
#define SOAP_TYPE___ns1__Request (103)
/* Operation wrapper: */
struct __ns1__Request
{
public:
	ns2__RequestMessageType *ns2__RequestMessage;	/* optional element of type ns2:RequestMessageType */
public:
	int soap_type() const { return 103; } /* = unique id SOAP_TYPE___ns1__Request */
};
#endif

#ifndef SOAP_TYPE___ns1__ResponseResponse
#define SOAP_TYPE___ns1__ResponseResponse (104)
/* Operation wrapper: */
struct __ns1__ResponseResponse
{
public:
	ns2__ResponseMessageType *ns2__ResponseMessage;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns2:ResponseMessageType */
public:
	int soap_type() const { return 104; } /* = unique id SOAP_TYPE___ns1__ResponseResponse */
};
#endif

#ifndef SOAP_TYPE___ns1__Response
#define SOAP_TYPE___ns1__Response (107)
/* Operation wrapper: */
struct __ns1__Response
{
public:
	ns2__ResponseMessageType *ns2__ResponseMessage;	/* optional element of type ns2:ResponseMessageType */
public:
	int soap_type() const { return 107; } /* = unique id SOAP_TYPE___ns1__Response */
};
#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (108)
/* SOAP Header: */
struct SOAP_ENV__Header
{
public:
	int soap_type() const { return 108; } /* = unique id SOAP_TYPE_SOAP_ENV__Header */
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (109)
/* SOAP Fault Code: */
struct SOAP_ENV__Code
{
public:
	char *SOAP_ENV__Value;	/* optional element of type xsd:QName */
	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of type SOAP-ENV:Code */
public:
	int soap_type() const { return 109; } /* = unique id SOAP_TYPE_SOAP_ENV__Code */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (111)
/* SOAP-ENV:Detail */
struct SOAP_ENV__Detail
{
public:
	char *__any;
	int __type;	/* any type of element <fault> (defined below) */
	void *fault;	/* transient */
public:
	int soap_type() const { return 111; } /* = unique id SOAP_TYPE_SOAP_ENV__Detail */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (114)
/* SOAP-ENV:Reason */
struct SOAP_ENV__Reason
{
public:
	char *SOAP_ENV__Text;	/* optional element of type xsd:string */
public:
	int soap_type() const { return 114; } /* = unique id SOAP_TYPE_SOAP_ENV__Reason */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (115)
/* SOAP Fault: */
struct SOAP_ENV__Fault
{
public:
	char *faultcode;	/* optional element of type xsd:QName */
	char *faultstring;	/* optional element of type xsd:string */
	char *faultactor;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *detail;	/* optional element of type SOAP-ENV:Detail */
	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of type SOAP-ENV:Code */
	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of type SOAP-ENV:Reason */
	char *SOAP_ENV__Node;	/* optional element of type xsd:string */
	char *SOAP_ENV__Role;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of type SOAP-ENV:Detail */
public:
	int soap_type() const { return 115; } /* = unique id SOAP_TYPE_SOAP_ENV__Fault */
};
#endif

#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/

#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif

#ifndef SOAP_TYPE_xsd__integer
#define SOAP_TYPE_xsd__integer (10)
typedef std::string xsd__integer;
#endif


/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Server-Side Operations                                                     *
 *                                                                            *
\******************************************************************************/


SOAP_FMAC5 int SOAP_FMAC6 __ns1__PublishEvent(struct soap*, ns2__EventMessageType *ns2__EventMessage, ns2__ResponseMessageType *ns2__ResponseMessage);

SOAP_FMAC5 int SOAP_FMAC6 __ns1__Request(struct soap*, ns2__RequestMessageType *ns2__RequestMessage, ns2__ResponseMessageType *ns2__ResponseMessage);

SOAP_FMAC5 int SOAP_FMAC6 __ns1__Response(struct soap*, ns2__ResponseMessageType *ns2__ResponseMessage, struct __ns1__ResponseResponse &_param_1);

/******************************************************************************\
 *                                                                            *
 * Server-Side Skeletons to Invoke Service Operations                         *
 *                                                                            *
\******************************************************************************/

extern "C" SOAP_FMAC5 int SOAP_FMAC6 soap_serve(struct soap*);

extern "C" SOAP_FMAC5 int SOAP_FMAC6 soap_serve_request(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__PublishEvent(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__Request(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__Response(struct soap*);

/******************************************************************************\
 *                                                                            *
 * Client-Side Call Stubs                                                     *
 *                                                                            *
\******************************************************************************/


SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__PublishEvent(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns2__EventMessageType *ns2__EventMessage, ns2__ResponseMessageType *ns2__ResponseMessage);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__Request(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns2__RequestMessageType *ns2__RequestMessage, ns2__ResponseMessageType *ns2__ResponseMessage);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__Response(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns2__ResponseMessageType *ns2__ResponseMessage, struct __ns1__ResponseResponse &_param_1);

#endif

/* End of soapStub.h */
