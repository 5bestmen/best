/* soapC.cpp
   Generated by gSOAP 2.8.16 from getData.h

Copyright(C) 2000-2013, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
GPL or Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.8.16 2015-07-09 02:04:45 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap, -1)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (soap->fault == NULL)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
			return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
		return NULL;
	}
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
		{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
			soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
		}
		return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
	{	soap->fault->detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
	}
	return (const char**)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Detail)
		return soap->fault->SOAP_ENV__Detail->__any;
	if (soap->fault->detail)
		return soap->fault->detail->__any;
	return NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if (soap->error || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_time:
		return soap_in_time(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE__ns2__ErrorType_level:
		return soap_in__ns2__ErrorType_level(soap, NULL, NULL, "ns2:ErrorType-level");
	case SOAP_TYPE__ns2__HeaderType_Verb:
		return soap_in__ns2__HeaderType_Verb(soap, NULL, NULL, "ns2:HeaderType-Verb");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE__ns2__ReplyType_Result:
		return soap_in__ns2__ReplyType_Result(soap, NULL, NULL, "ns2:ReplyType-Result");
	case SOAP_TYPE_ns2__IDKindType:
		return soap_in_ns2__IDKindType(soap, NULL, NULL, "ns2:IDKindType");
	case SOAP_TYPE_ns3__CommonValuesType:
		return soap_in_ns3__CommonValuesType(soap, NULL, NULL, "ns3:CommonValuesType");
	case SOAP_TYPE_ns3__DeviceValuesType:
		return soap_in_ns3__DeviceValuesType(soap, NULL, NULL, "ns3:DeviceValuesType");
	case SOAP_TYPE_ns3__DeviceClassType:
		return soap_in_ns3__DeviceClassType(soap, NULL, NULL, "ns3:DeviceClassType");
	case SOAP_TYPE_ns3__ArrayValuesType:
		return soap_in_ns3__ArrayValuesType(soap, NULL, NULL, "ns3:ArrayValuesType");
	case SOAP_TYPE_ns2__NameTypeAuthority:
		return soap_in_ns2__NameTypeAuthority(soap, NULL, NULL, "ns2:NameTypeAuthority");
	case SOAP_TYPE_ns2__Name:
		return soap_in_ns2__Name(soap, NULL, NULL, "ns2:Name");
	case SOAP_TYPE_ns2__NameType:
		return soap_in_ns2__NameType(soap, NULL, NULL, "ns2:NameType");
	case SOAP_TYPE_ns2__ObjectType:
		return soap_in_ns2__ObjectType(soap, NULL, NULL, "ns2:ObjectType");
	case SOAP_TYPE_ns2__LocationType:
		return soap_in_ns2__LocationType(soap, NULL, NULL, "ns2:LocationType");
	case SOAP_TYPE_ns2__OptionType:
		return soap_in_ns2__OptionType(soap, NULL, NULL, "ns2:OptionType");
	case SOAP_TYPE_ns2__ErrorType:
		return soap_in_ns2__ErrorType(soap, NULL, NULL, "ns2:ErrorType");
	case SOAP_TYPE_ns2__EventMessageType:
		return soap_in_ns2__EventMessageType(soap, NULL, NULL, "ns2:EventMessageType");
	case SOAP_TYPE_ns2__FaultMessageType:
		return soap_in_ns2__FaultMessageType(soap, NULL, NULL, "ns2:FaultMessageType");
	case SOAP_TYPE_ns2__ResponseMessageType:
		return soap_in_ns2__ResponseMessageType(soap, NULL, NULL, "ns2:ResponseMessageType");
	case SOAP_TYPE_ns2__RequestMessageType:
		return soap_in_ns2__RequestMessageType(soap, NULL, NULL, "ns2:RequestMessageType");
	case SOAP_TYPE_ns2__MessageType:
		return soap_in_ns2__MessageType(soap, NULL, NULL, "ns2:MessageType");
	case SOAP_TYPE_ns2__MessageProperty:
		return soap_in_ns2__MessageProperty(soap, NULL, NULL, "ns2:MessageProperty");
	case SOAP_TYPE_ns2__HeaderType:
		return soap_in_ns2__HeaderType(soap, NULL, NULL, "ns2:HeaderType");
	case SOAP_TYPE_ns2__UserType:
		return soap_in_ns2__UserType(soap, NULL, NULL, "ns2:UserType");
	case SOAP_TYPE_ns2__ReplayDetectionType:
		return soap_in_ns2__ReplayDetectionType(soap, NULL, NULL, "ns2:ReplayDetectionType");
	case SOAP_TYPE_ns2__OperationSet:
		return soap_in_ns2__OperationSet(soap, NULL, NULL, "ns2:OperationSet");
	case SOAP_TYPE_ns2__OperationType:
		return soap_in_ns2__OperationType(soap, NULL, NULL, "ns2:OperationType");
	case SOAP_TYPE_ns2__PayloadType:
		return soap_in_ns2__PayloadType(soap, NULL, NULL, "ns2:PayloadType");
	case SOAP_TYPE_ns2__ReplyType:
		return soap_in_ns2__ReplyType(soap, NULL, NULL, "ns2:ReplyType");
	case SOAP_TYPE_ns2__RequestType:
		return soap_in_ns2__RequestType(soap, NULL, NULL, "ns2:RequestType");
	case SOAP_TYPE_xsd__integer:
		return soap_in_xsd__integer(soap, NULL, NULL, "xsd:integer");
	case SOAP_TYPE_xsd__QName:
		return soap_in_xsd__QName(soap, NULL, NULL, "xsd:QName");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerTons2__RequestMessageType:
		return soap_in_PointerTons2__RequestMessageType(soap, NULL, NULL, "ns2:RequestMessageType");
	case SOAP_TYPE_PointerTons2__ResponseMessageType:
		return soap_in_PointerTons2__ResponseMessageType(soap, NULL, NULL, "ns2:ResponseMessageType");
	case SOAP_TYPE_PointerTons2__EventMessageType:
		return soap_in_PointerTons2__EventMessageType(soap, NULL, NULL, "ns2:EventMessageType");
	case SOAP_TYPE_PointerTons3__DeviceClassType:
		return soap_in_PointerTons3__DeviceClassType(soap, NULL, NULL, "ns3:DeviceClassType");
	case SOAP_TYPE_PointerTons2__NameType:
		return soap_in_PointerTons2__NameType(soap, NULL, NULL, "ns2:NameType");
	case SOAP_TYPE_PointerTons2__NameTypeAuthority:
		return soap_in_PointerTons2__NameTypeAuthority(soap, NULL, NULL, "ns2:NameTypeAuthority");
	case SOAP_TYPE_PointerTons2__Name:
		return soap_in_PointerTons2__Name(soap, NULL, NULL, "ns2:Name");
	case SOAP_TYPE_PointerTons2__ObjectType:
		return soap_in_PointerTons2__ObjectType(soap, NULL, NULL, "ns2:ObjectType");
	case SOAP_TYPE_PointerTo_ns2__ErrorType_relatedID:
		return soap_in_PointerTo_ns2__ErrorType_relatedID(soap, NULL, NULL, "ns2:ErrorType-relatedID");
	case SOAP_TYPE_PointerTo_ns2__ErrorType_ID:
		return soap_in_PointerTo_ns2__ErrorType_ID(soap, NULL, NULL, "ns2:ErrorType-ID");
	case SOAP_TYPE_PointerTons2__LocationType:
		return soap_in_PointerTons2__LocationType(soap, NULL, NULL, "ns2:LocationType");
	case SOAP_TYPE_PointerToxsd__QName:
		return soap_in_PointerToxsd__QName(soap, NULL, NULL, "xsd:QName");
	case SOAP_TYPE_PointerTo_ns2__ErrorType_level:
		return soap_in_PointerTo_ns2__ErrorType_level(soap, NULL, NULL, "ns2:ErrorType-level");
	case SOAP_TYPE_PointerTons2__PayloadType:
		return soap_in_PointerTons2__PayloadType(soap, NULL, NULL, "ns2:PayloadType");
	case SOAP_TYPE_PointerTons2__ReplyType:
		return soap_in_PointerTons2__ReplyType(soap, NULL, NULL, "ns2:ReplyType");
	case SOAP_TYPE_PointerTons2__RequestType:
		return soap_in_PointerTons2__RequestType(soap, NULL, NULL, "ns2:RequestType");
	case SOAP_TYPE_PointerTons2__HeaderType:
		return soap_in_PointerTons2__HeaderType(soap, NULL, NULL, "ns2:HeaderType");
	case SOAP_TYPE_PointerTons2__MessageProperty:
		return soap_in_PointerTons2__MessageProperty(soap, NULL, NULL, "ns2:MessageProperty");
	case SOAP_TYPE_PointerTons2__UserType:
		return soap_in_PointerTons2__UserType(soap, NULL, NULL, "ns2:UserType");
	case SOAP_TYPE_PointerTons2__ReplayDetectionType:
		return soap_in_PointerTons2__ReplayDetectionType(soap, NULL, NULL, "ns2:ReplayDetectionType");
	case SOAP_TYPE_PointerTons2__OperationType:
		return soap_in_PointerTons2__OperationType(soap, NULL, NULL, "ns2:OperationType");
	case SOAP_TYPE_PointerTobool:
		return soap_in_PointerTobool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_PointerTons2__OperationSet:
		return soap_in_PointerTons2__OperationSet(soap, NULL, NULL, "ns2:OperationSet");
	case SOAP_TYPE_PointerTons3__ArrayValuesType:
		return soap_in_PointerTons3__ArrayValuesType(soap, NULL, NULL, "ns3:ArrayValuesType");
	case SOAP_TYPE_PointerTons3__DeviceValuesType:
		return soap_in_PointerTons3__DeviceValuesType(soap, NULL, NULL, "ns3:DeviceValuesType");
	case SOAP_TYPE_PointerTons3__CommonValuesType:
		return soap_in_PointerTons3__CommonValuesType(soap, NULL, NULL, "ns3:CommonValuesType");
	case SOAP_TYPE_PointerToxsd__integer:
		return soap_in_PointerToxsd__integer(soap, NULL, NULL, "xsd:integer");
	case SOAP_TYPE_PointerTons2__ErrorType:
		return soap_in_PointerTons2__ErrorType(soap, NULL, NULL, "ns2:ErrorType");
	case SOAP_TYPE_PointerTons2__IDKindType:
		return soap_in_PointerTons2__IDKindType(soap, NULL, NULL, "ns2:IDKindType");
	case SOAP_TYPE_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerTons2__OptionType:
		return soap_in_PointerTons2__OptionType(soap, NULL, NULL, "ns2:OptionType");
	case SOAP_TYPE_PointerTotime:
		return soap_in_PointerTotime(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "ns3:CommonValuesType"))
		{	*type = SOAP_TYPE_ns3__CommonValuesType;
			return soap_in_ns3__CommonValuesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:DeviceValuesType"))
		{	*type = SOAP_TYPE_ns3__DeviceValuesType;
			return soap_in_ns3__DeviceValuesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:DeviceClassType"))
		{	*type = SOAP_TYPE_ns3__DeviceClassType;
			return soap_in_ns3__DeviceClassType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:ArrayValuesType"))
		{	*type = SOAP_TYPE_ns3__ArrayValuesType;
			return soap_in_ns3__ArrayValuesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:NameTypeAuthority"))
		{	*type = SOAP_TYPE_ns2__NameTypeAuthority;
			return soap_in_ns2__NameTypeAuthority(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Name"))
		{	*type = SOAP_TYPE_ns2__Name;
			return soap_in_ns2__Name(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:NameType"))
		{	*type = SOAP_TYPE_ns2__NameType;
			return soap_in_ns2__NameType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ObjectType"))
		{	*type = SOAP_TYPE_ns2__ObjectType;
			return soap_in_ns2__ObjectType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:LocationType"))
		{	*type = SOAP_TYPE_ns2__LocationType;
			return soap_in_ns2__LocationType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:OptionType"))
		{	*type = SOAP_TYPE_ns2__OptionType;
			return soap_in_ns2__OptionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ErrorType"))
		{	*type = SOAP_TYPE_ns2__ErrorType;
			return soap_in_ns2__ErrorType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:EventMessageType"))
		{	*type = SOAP_TYPE_ns2__EventMessageType;
			return soap_in_ns2__EventMessageType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:FaultMessageType"))
		{	*type = SOAP_TYPE_ns2__FaultMessageType;
			return soap_in_ns2__FaultMessageType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ResponseMessageType"))
		{	*type = SOAP_TYPE_ns2__ResponseMessageType;
			return soap_in_ns2__ResponseMessageType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:RequestMessageType"))
		{	*type = SOAP_TYPE_ns2__RequestMessageType;
			return soap_in_ns2__RequestMessageType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:MessageType"))
		{	*type = SOAP_TYPE_ns2__MessageType;
			return soap_in_ns2__MessageType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:MessageProperty"))
		{	*type = SOAP_TYPE_ns2__MessageProperty;
			return soap_in_ns2__MessageProperty(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:HeaderType"))
		{	*type = SOAP_TYPE_ns2__HeaderType;
			return soap_in_ns2__HeaderType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:UserType"))
		{	*type = SOAP_TYPE_ns2__UserType;
			return soap_in_ns2__UserType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ReplayDetectionType"))
		{	*type = SOAP_TYPE_ns2__ReplayDetectionType;
			return soap_in_ns2__ReplayDetectionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:OperationSet"))
		{	*type = SOAP_TYPE_ns2__OperationSet;
			return soap_in_ns2__OperationSet(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:OperationType"))
		{	*type = SOAP_TYPE_ns2__OperationType;
			return soap_in_ns2__OperationType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PayloadType"))
		{	*type = SOAP_TYPE_ns2__PayloadType;
			return soap_in_ns2__PayloadType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ReplyType"))
		{	*type = SOAP_TYPE_ns2__ReplyType;
			return soap_in_ns2__ReplyType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:RequestType"))
		{	*type = SOAP_TYPE_ns2__RequestType;
			return soap_in_ns2__RequestType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:integer"))
		{	*type = SOAP_TYPE_xsd__integer;
			return soap_in_xsd__integer(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	*type = SOAP_TYPE_xsd__QName;
			return soap_in_xsd__QName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_time;
			return soap_in_time(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ErrorType-level"))
		{	*type = SOAP_TYPE__ns2__ErrorType_level;
			return soap_in__ns2__ErrorType_level(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:HeaderType-Verb"))
		{	*type = SOAP_TYPE__ns2__HeaderType_Verb;
			return soap_in__ns2__HeaderType_Verb(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ReplyType-Result"))
		{	*type = SOAP_TYPE__ns2__ReplyType_Result;
			return soap_in__ns2__ReplyType_Result(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:IDKindType"))
		{	*type = SOAP_TYPE_ns2__IDKindType;
			return soap_in_ns2__IDKindType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "ns2:ErrorType-relatedID"))
		{	*type = SOAP_TYPE__ns2__ErrorType_relatedID;
			return soap_in__ns2__ErrorType_relatedID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ErrorType-ID"))
		{	*type = SOAP_TYPE__ns2__ErrorType_ID;
			return soap_in__ns2__ErrorType_ID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PayloadType-ID"))
		{	*type = SOAP_TYPE__ns2__PayloadType_ID;
			return soap_in__ns2__PayloadType_ID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ReplyType-ID"))
		{	*type = SOAP_TYPE__ns2__ReplyType_ID;
			return soap_in__ns2__ReplyType_ID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:RequestType-ID"))
		{	*type = SOAP_TYPE__ns2__RequestType_ID;
			return soap_in__ns2__RequestType_ID(soap, NULL, NULL, NULL);
		}
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_time:
		return soap_out_time(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE__ns2__ErrorType_level:
		return soap_out__ns2__ErrorType_level(soap, tag, id, (const enum _ns2__ErrorType_level *)ptr, "ns2:ErrorType-level");
	case SOAP_TYPE__ns2__HeaderType_Verb:
		return soap_out__ns2__HeaderType_Verb(soap, tag, id, (const enum _ns2__HeaderType_Verb *)ptr, "ns2:HeaderType-Verb");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE__ns2__ReplyType_Result:
		return soap_out__ns2__ReplyType_Result(soap, tag, id, (const enum _ns2__ReplyType_Result *)ptr, "ns2:ReplyType-Result");
	case SOAP_TYPE_ns2__IDKindType:
		return soap_out_ns2__IDKindType(soap, tag, id, (const enum ns2__IDKindType *)ptr, "ns2:IDKindType");
	case SOAP_TYPE__ns2__ErrorType_relatedID:
		return ((_ns2__ErrorType_relatedID *)ptr)->soap_out(soap, "ns2:ErrorType-relatedID", id, NULL);
	case SOAP_TYPE__ns2__ErrorType_ID:
		return ((_ns2__ErrorType_ID *)ptr)->soap_out(soap, "ns2:ErrorType-ID", id, NULL);
	case SOAP_TYPE__ns2__PayloadType_ID:
		return ((_ns2__PayloadType_ID *)ptr)->soap_out(soap, "ns2:PayloadType-ID", id, NULL);
	case SOAP_TYPE__ns2__ReplyType_ID:
		return ((_ns2__ReplyType_ID *)ptr)->soap_out(soap, "ns2:ReplyType-ID", id, NULL);
	case SOAP_TYPE__ns2__RequestType_ID:
		return ((_ns2__RequestType_ID *)ptr)->soap_out(soap, "ns2:RequestType-ID", id, NULL);
	case SOAP_TYPE_ns3__CommonValuesType:
		return ((ns3__CommonValuesType *)ptr)->soap_out(soap, tag, id, "ns3:CommonValuesType");
	case SOAP_TYPE_ns3__DeviceValuesType:
		return ((ns3__DeviceValuesType *)ptr)->soap_out(soap, tag, id, "ns3:DeviceValuesType");
	case SOAP_TYPE_ns3__DeviceClassType:
		return ((ns3__DeviceClassType *)ptr)->soap_out(soap, tag, id, "ns3:DeviceClassType");
	case SOAP_TYPE_ns3__ArrayValuesType:
		return ((ns3__ArrayValuesType *)ptr)->soap_out(soap, tag, id, "ns3:ArrayValuesType");
	case SOAP_TYPE_ns2__NameTypeAuthority:
		return ((ns2__NameTypeAuthority *)ptr)->soap_out(soap, tag, id, "ns2:NameTypeAuthority");
	case SOAP_TYPE_ns2__Name:
		return ((ns2__Name *)ptr)->soap_out(soap, tag, id, "ns2:Name");
	case SOAP_TYPE_ns2__NameType:
		return ((ns2__NameType *)ptr)->soap_out(soap, tag, id, "ns2:NameType");
	case SOAP_TYPE_ns2__ObjectType:
		return ((ns2__ObjectType *)ptr)->soap_out(soap, tag, id, "ns2:ObjectType");
	case SOAP_TYPE_ns2__LocationType:
		return ((ns2__LocationType *)ptr)->soap_out(soap, tag, id, "ns2:LocationType");
	case SOAP_TYPE_ns2__OptionType:
		return ((ns2__OptionType *)ptr)->soap_out(soap, tag, id, "ns2:OptionType");
	case SOAP_TYPE_ns2__ErrorType:
		return ((ns2__ErrorType *)ptr)->soap_out(soap, tag, id, "ns2:ErrorType");
	case SOAP_TYPE_ns2__EventMessageType:
		return ((ns2__EventMessageType *)ptr)->soap_out(soap, tag, id, "ns2:EventMessageType");
	case SOAP_TYPE_ns2__FaultMessageType:
		return ((ns2__FaultMessageType *)ptr)->soap_out(soap, tag, id, "ns2:FaultMessageType");
	case SOAP_TYPE_ns2__ResponseMessageType:
		return ((ns2__ResponseMessageType *)ptr)->soap_out(soap, tag, id, "ns2:ResponseMessageType");
	case SOAP_TYPE_ns2__RequestMessageType:
		return ((ns2__RequestMessageType *)ptr)->soap_out(soap, tag, id, "ns2:RequestMessageType");
	case SOAP_TYPE_ns2__MessageType:
		return ((ns2__MessageType *)ptr)->soap_out(soap, tag, id, "ns2:MessageType");
	case SOAP_TYPE_ns2__MessageProperty:
		return ((ns2__MessageProperty *)ptr)->soap_out(soap, tag, id, "ns2:MessageProperty");
	case SOAP_TYPE_ns2__HeaderType:
		return ((ns2__HeaderType *)ptr)->soap_out(soap, tag, id, "ns2:HeaderType");
	case SOAP_TYPE_ns2__UserType:
		return ((ns2__UserType *)ptr)->soap_out(soap, tag, id, "ns2:UserType");
	case SOAP_TYPE_ns2__ReplayDetectionType:
		return ((ns2__ReplayDetectionType *)ptr)->soap_out(soap, tag, id, "ns2:ReplayDetectionType");
	case SOAP_TYPE_ns2__OperationSet:
		return ((ns2__OperationSet *)ptr)->soap_out(soap, tag, id, "ns2:OperationSet");
	case SOAP_TYPE_ns2__OperationType:
		return ((ns2__OperationType *)ptr)->soap_out(soap, tag, id, "ns2:OperationType");
	case SOAP_TYPE_ns2__PayloadType:
		return ((ns2__PayloadType *)ptr)->soap_out(soap, tag, id, "ns2:PayloadType");
	case SOAP_TYPE_ns2__ReplyType:
		return ((ns2__ReplyType *)ptr)->soap_out(soap, tag, id, "ns2:ReplyType");
	case SOAP_TYPE_ns2__RequestType:
		return ((ns2__RequestType *)ptr)->soap_out(soap, tag, id, "ns2:RequestType");
	case SOAP_TYPE_xsd__integer:
		return soap_out_xsd__integer(soap, tag, id, (const std::string *)ptr, "xsd:integer");
	case SOAP_TYPE_xsd__QName:
		return soap_out_xsd__QName(soap, tag, id, (const std::string *)ptr, "xsd:QName");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_PointerTons2__RequestMessageType:
		return soap_out_PointerTons2__RequestMessageType(soap, tag, id, (ns2__RequestMessageType *const*)ptr, "ns2:RequestMessageType");
	case SOAP_TYPE_PointerTons2__ResponseMessageType:
		return soap_out_PointerTons2__ResponseMessageType(soap, tag, id, (ns2__ResponseMessageType *const*)ptr, "ns2:ResponseMessageType");
	case SOAP_TYPE_PointerTons2__EventMessageType:
		return soap_out_PointerTons2__EventMessageType(soap, tag, id, (ns2__EventMessageType *const*)ptr, "ns2:EventMessageType");
	case SOAP_TYPE_PointerTons3__DeviceClassType:
		return soap_out_PointerTons3__DeviceClassType(soap, tag, id, (ns3__DeviceClassType *const*)ptr, "ns3:DeviceClassType");
	case SOAP_TYPE_PointerTons2__NameType:
		return soap_out_PointerTons2__NameType(soap, tag, id, (ns2__NameType *const*)ptr, "ns2:NameType");
	case SOAP_TYPE_PointerTons2__NameTypeAuthority:
		return soap_out_PointerTons2__NameTypeAuthority(soap, tag, id, (ns2__NameTypeAuthority *const*)ptr, "ns2:NameTypeAuthority");
	case SOAP_TYPE_PointerTons2__Name:
		return soap_out_PointerTons2__Name(soap, tag, id, (ns2__Name *const*)ptr, "ns2:Name");
	case SOAP_TYPE_PointerTons2__ObjectType:
		return soap_out_PointerTons2__ObjectType(soap, tag, id, (ns2__ObjectType *const*)ptr, "ns2:ObjectType");
	case SOAP_TYPE_PointerTo_ns2__ErrorType_relatedID:
		return soap_out_PointerTo_ns2__ErrorType_relatedID(soap, tag, id, (_ns2__ErrorType_relatedID *const*)ptr, "ns2:ErrorType-relatedID");
	case SOAP_TYPE_PointerTo_ns2__ErrorType_ID:
		return soap_out_PointerTo_ns2__ErrorType_ID(soap, tag, id, (_ns2__ErrorType_ID *const*)ptr, "ns2:ErrorType-ID");
	case SOAP_TYPE_PointerTons2__LocationType:
		return soap_out_PointerTons2__LocationType(soap, tag, id, (ns2__LocationType *const*)ptr, "ns2:LocationType");
	case SOAP_TYPE_PointerToxsd__QName:
		return soap_out_PointerToxsd__QName(soap, tag, id, (std::string *const*)ptr, "xsd:QName");
	case SOAP_TYPE_PointerTo_ns2__ErrorType_level:
		return soap_out_PointerTo_ns2__ErrorType_level(soap, tag, id, (enum _ns2__ErrorType_level *const*)ptr, "ns2:ErrorType-level");
	case SOAP_TYPE_PointerTons2__PayloadType:
		return soap_out_PointerTons2__PayloadType(soap, tag, id, (ns2__PayloadType *const*)ptr, "ns2:PayloadType");
	case SOAP_TYPE_PointerTons2__ReplyType:
		return soap_out_PointerTons2__ReplyType(soap, tag, id, (ns2__ReplyType *const*)ptr, "ns2:ReplyType");
	case SOAP_TYPE_PointerTons2__RequestType:
		return soap_out_PointerTons2__RequestType(soap, tag, id, (ns2__RequestType *const*)ptr, "ns2:RequestType");
	case SOAP_TYPE_PointerTons2__HeaderType:
		return soap_out_PointerTons2__HeaderType(soap, tag, id, (ns2__HeaderType *const*)ptr, "ns2:HeaderType");
	case SOAP_TYPE_PointerTons2__MessageProperty:
		return soap_out_PointerTons2__MessageProperty(soap, tag, id, (ns2__MessageProperty *const*)ptr, "ns2:MessageProperty");
	case SOAP_TYPE_PointerTons2__UserType:
		return soap_out_PointerTons2__UserType(soap, tag, id, (ns2__UserType *const*)ptr, "ns2:UserType");
	case SOAP_TYPE_PointerTons2__ReplayDetectionType:
		return soap_out_PointerTons2__ReplayDetectionType(soap, tag, id, (ns2__ReplayDetectionType *const*)ptr, "ns2:ReplayDetectionType");
	case SOAP_TYPE_PointerTons2__OperationType:
		return soap_out_PointerTons2__OperationType(soap, tag, id, (ns2__OperationType *const*)ptr, "ns2:OperationType");
	case SOAP_TYPE_PointerTobool:
		return soap_out_PointerTobool(soap, tag, id, (bool *const*)ptr, "xsd:boolean");
	case SOAP_TYPE_PointerTons2__OperationSet:
		return soap_out_PointerTons2__OperationSet(soap, tag, id, (ns2__OperationSet *const*)ptr, "ns2:OperationSet");
	case SOAP_TYPE_PointerTons3__ArrayValuesType:
		return soap_out_PointerTons3__ArrayValuesType(soap, tag, id, (ns3__ArrayValuesType *const*)ptr, "ns3:ArrayValuesType");
	case SOAP_TYPE_PointerTons3__DeviceValuesType:
		return soap_out_PointerTons3__DeviceValuesType(soap, tag, id, (ns3__DeviceValuesType *const*)ptr, "ns3:DeviceValuesType");
	case SOAP_TYPE_PointerTons3__CommonValuesType:
		return soap_out_PointerTons3__CommonValuesType(soap, tag, id, (ns3__CommonValuesType *const*)ptr, "ns3:CommonValuesType");
	case SOAP_TYPE_PointerToxsd__integer:
		return soap_out_PointerToxsd__integer(soap, tag, id, (std::string *const*)ptr, "xsd:integer");
	case SOAP_TYPE_PointerTons2__ErrorType:
		return soap_out_PointerTons2__ErrorType(soap, tag, id, (ns2__ErrorType *const*)ptr, "ns2:ErrorType");
	case SOAP_TYPE_PointerTons2__IDKindType:
		return soap_out_PointerTons2__IDKindType(soap, tag, id, (enum ns2__IDKindType *const*)ptr, "ns2:IDKindType");
	case SOAP_TYPE_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerTons2__OptionType:
		return soap_out_PointerTons2__OptionType(soap, tag, id, (ns2__OptionType *const*)ptr, "ns2:OptionType");
	case SOAP_TYPE_PointerTotime:
		return soap_out_PointerTotime(soap, tag, id, (time_t *const*)ptr, "xsd:dateTime");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE__ns2__ErrorType_relatedID:
		((_ns2__ErrorType_relatedID *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns2__ErrorType_ID:
		((_ns2__ErrorType_ID *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns2__PayloadType_ID:
		((_ns2__PayloadType_ID *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns2__ReplyType_ID:
		((_ns2__ReplyType_ID *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns2__RequestType_ID:
		((_ns2__RequestType_ID *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__CommonValuesType:
		((ns3__CommonValuesType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__DeviceValuesType:
		((ns3__DeviceValuesType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__DeviceClassType:
		((ns3__DeviceClassType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__ArrayValuesType:
		((ns3__ArrayValuesType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__NameTypeAuthority:
		((ns2__NameTypeAuthority *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__Name:
		((ns2__Name *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__NameType:
		((ns2__NameType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ObjectType:
		((ns2__ObjectType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__LocationType:
		((ns2__LocationType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__OptionType:
		((ns2__OptionType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ErrorType:
		((ns2__ErrorType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__EventMessageType:
		((ns2__EventMessageType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__FaultMessageType:
		((ns2__FaultMessageType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ResponseMessageType:
		((ns2__ResponseMessageType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__RequestMessageType:
		((ns2__RequestMessageType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__MessageType:
		((ns2__MessageType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__MessageProperty:
		((ns2__MessageProperty *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__HeaderType:
		((ns2__HeaderType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__UserType:
		((ns2__UserType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ReplayDetectionType:
		((ns2__ReplayDetectionType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__OperationSet:
		((ns2__OperationSet *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__OperationType:
		((ns2__OperationType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PayloadType:
		((ns2__PayloadType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ReplyType:
		((ns2__ReplyType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__RequestType:
		((ns2__RequestType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__integer:
		soap_serialize_xsd__integer(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__QName:
		soap_serialize_xsd__QName(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE___ns1__Response:
		soap_serialize___ns1__Response(soap, (const struct __ns1__Response *)ptr);
		break;
	case SOAP_TYPE___ns1__ResponseResponse:
		soap_serialize___ns1__ResponseResponse(soap, (const struct __ns1__ResponseResponse *)ptr);
		break;
	case SOAP_TYPE___ns1__Request:
		soap_serialize___ns1__Request(soap, (const struct __ns1__Request *)ptr);
		break;
	case SOAP_TYPE___ns1__PublishEvent:
		soap_serialize___ns1__PublishEvent(soap, (const struct __ns1__PublishEvent *)ptr);
		break;
	case SOAP_TYPE_PointerTons2__RequestMessageType:
		soap_serialize_PointerTons2__RequestMessageType(soap, (ns2__RequestMessageType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ResponseMessageType:
		soap_serialize_PointerTons2__ResponseMessageType(soap, (ns2__ResponseMessageType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__EventMessageType:
		soap_serialize_PointerTons2__EventMessageType(soap, (ns2__EventMessageType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__DeviceClassType:
		soap_serialize_PointerTons3__DeviceClassType(soap, (ns3__DeviceClassType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__NameType:
		soap_serialize_PointerTons2__NameType(soap, (ns2__NameType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__NameTypeAuthority:
		soap_serialize_PointerTons2__NameTypeAuthority(soap, (ns2__NameTypeAuthority *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__Name:
		soap_serialize_PointerTons2__Name(soap, (ns2__Name *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ObjectType:
		soap_serialize_PointerTons2__ObjectType(soap, (ns2__ObjectType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__ErrorType_relatedID:
		soap_serialize_PointerTo_ns2__ErrorType_relatedID(soap, (_ns2__ErrorType_relatedID *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__ErrorType_ID:
		soap_serialize_PointerTo_ns2__ErrorType_ID(soap, (_ns2__ErrorType_ID *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__LocationType:
		soap_serialize_PointerTons2__LocationType(soap, (ns2__LocationType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__QName:
		soap_serialize_PointerToxsd__QName(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__ErrorType_level:
		soap_serialize_PointerTo_ns2__ErrorType_level(soap, (enum _ns2__ErrorType_level *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PayloadType:
		soap_serialize_PointerTons2__PayloadType(soap, (ns2__PayloadType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ReplyType:
		soap_serialize_PointerTons2__ReplyType(soap, (ns2__ReplyType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__RequestType:
		soap_serialize_PointerTons2__RequestType(soap, (ns2__RequestType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__HeaderType:
		soap_serialize_PointerTons2__HeaderType(soap, (ns2__HeaderType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__MessageProperty:
		soap_serialize_PointerTons2__MessageProperty(soap, (ns2__MessageProperty *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__UserType:
		soap_serialize_PointerTons2__UserType(soap, (ns2__UserType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ReplayDetectionType:
		soap_serialize_PointerTons2__ReplayDetectionType(soap, (ns2__ReplayDetectionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__OperationType:
		soap_serialize_PointerTons2__OperationType(soap, (ns2__OperationType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobool:
		soap_serialize_PointerTobool(soap, (bool *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__OperationSet:
		soap_serialize_PointerTons2__OperationSet(soap, (ns2__OperationSet *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__ArrayValuesType:
		soap_serialize_PointerTons3__ArrayValuesType(soap, (ns3__ArrayValuesType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__DeviceValuesType:
		soap_serialize_PointerTons3__DeviceValuesType(soap, (ns3__DeviceValuesType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__CommonValuesType:
		soap_serialize_PointerTons3__CommonValuesType(soap, (ns3__CommonValuesType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__integer:
		soap_serialize_PointerToxsd__integer(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ErrorType:
		soap_serialize_PointerTons2__ErrorType(soap, (ns2__ErrorType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__IDKindType:
		soap_serialize_PointerTons2__IDKindType(soap, (enum ns2__IDKindType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__OptionType:
		soap_serialize_PointerTons2__OptionType(soap, (ns2__OptionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotime:
		soap_serialize_PointerTotime(soap, (time_t *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__RequestType_ID:
		return (void*)soap_instantiate__ns2__RequestType_ID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__RequestType:
		return (void*)soap_instantiate_ns2__RequestType(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__ReplyType_ID:
		return (void*)soap_instantiate__ns2__ReplyType_ID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ReplyType:
		return (void*)soap_instantiate_ns2__ReplyType(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__PayloadType_ID:
		return (void*)soap_instantiate__ns2__PayloadType_ID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PayloadType:
		return (void*)soap_instantiate_ns2__PayloadType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__OperationType:
		return (void*)soap_instantiate_ns2__OperationType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__OperationSet:
		return (void*)soap_instantiate_ns2__OperationSet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ReplayDetectionType:
		return (void*)soap_instantiate_ns2__ReplayDetectionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__UserType:
		return (void*)soap_instantiate_ns2__UserType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__HeaderType:
		return (void*)soap_instantiate_ns2__HeaderType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__MessageProperty:
		return (void*)soap_instantiate_ns2__MessageProperty(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__MessageType:
		return (void*)soap_instantiate_ns2__MessageType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__RequestMessageType:
		return (void*)soap_instantiate_ns2__RequestMessageType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ResponseMessageType:
		return (void*)soap_instantiate_ns2__ResponseMessageType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__FaultMessageType:
		return (void*)soap_instantiate_ns2__FaultMessageType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__EventMessageType:
		return (void*)soap_instantiate_ns2__EventMessageType(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__ErrorType_ID:
		return (void*)soap_instantiate__ns2__ErrorType_ID(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__ErrorType_relatedID:
		return (void*)soap_instantiate__ns2__ErrorType_relatedID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ErrorType:
		return (void*)soap_instantiate_ns2__ErrorType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__OptionType:
		return (void*)soap_instantiate_ns2__OptionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__LocationType:
		return (void*)soap_instantiate_ns2__LocationType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ObjectType:
		return (void*)soap_instantiate_ns2__ObjectType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__NameType:
		return (void*)soap_instantiate_ns2__NameType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__Name:
		return (void*)soap_instantiate_ns2__Name(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__NameTypeAuthority:
		return (void*)soap_instantiate_ns2__NameTypeAuthority(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__ArrayValuesType:
		return (void*)soap_instantiate_ns3__ArrayValuesType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__DeviceClassType:
		return (void*)soap_instantiate_ns3__DeviceClassType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__DeviceValuesType:
		return (void*)soap_instantiate_ns3__DeviceValuesType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__CommonValuesType:
		return (void*)soap_instantiate_ns3__CommonValuesType(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__PublishEvent:
		return (void*)soap_instantiate___ns1__PublishEvent(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__Request:
		return (void*)soap_instantiate___ns1__Request(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__ResponseResponse:
		return (void*)soap_instantiate___ns1__ResponseResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__Response:
		return (void*)soap_instantiate___ns1__Response(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_xsd__QName:
		return (void*)soap_instantiate_xsd__QName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__integer:
		return (void*)soap_instantiate_xsd__integer(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__DeviceClassType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons3__DeviceClassType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__Name:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__Name(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__MessageProperty:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__MessageProperty(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__OperationType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__OperationType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOf_ns2__PayloadType_ID:
		return (void*)soap_instantiate_std__vectorTemplateOf_ns2__PayloadType_ID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__ArrayValuesType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons3__ArrayValuesType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__DeviceValuesType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons3__DeviceValuesType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__CommonValuesType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons3__CommonValuesType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOf_ns2__ReplyType_ID:
		return (void*)soap_instantiate_std__vectorTemplateOf_ns2__ReplyType_ID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__ErrorType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__ErrorType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOf_XML:
		return (void*)soap_instantiate_std__vectorTemplateOf_XML(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOf_ns2__RequestType_ID:
		return (void*)soap_instantiate_std__vectorTemplateOf_ns2__RequestType_ID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__OptionType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__OptionType(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE__ns2__RequestType_ID:
		if (p->size < 0)
			SOAP_DELETE((_ns2__RequestType_ID*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns2__RequestType_ID*)p->ptr);
		break;
	case SOAP_TYPE_ns2__RequestType:
		if (p->size < 0)
			SOAP_DELETE((ns2__RequestType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__RequestType*)p->ptr);
		break;
	case SOAP_TYPE__ns2__ReplyType_ID:
		if (p->size < 0)
			SOAP_DELETE((_ns2__ReplyType_ID*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns2__ReplyType_ID*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ReplyType:
		if (p->size < 0)
			SOAP_DELETE((ns2__ReplyType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ReplyType*)p->ptr);
		break;
	case SOAP_TYPE__ns2__PayloadType_ID:
		if (p->size < 0)
			SOAP_DELETE((_ns2__PayloadType_ID*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns2__PayloadType_ID*)p->ptr);
		break;
	case SOAP_TYPE_ns2__PayloadType:
		if (p->size < 0)
			SOAP_DELETE((ns2__PayloadType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__PayloadType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__OperationType:
		if (p->size < 0)
			SOAP_DELETE((ns2__OperationType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__OperationType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__OperationSet:
		if (p->size < 0)
			SOAP_DELETE((ns2__OperationSet*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__OperationSet*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ReplayDetectionType:
		if (p->size < 0)
			SOAP_DELETE((ns2__ReplayDetectionType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ReplayDetectionType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__UserType:
		if (p->size < 0)
			SOAP_DELETE((ns2__UserType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__UserType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__HeaderType:
		if (p->size < 0)
			SOAP_DELETE((ns2__HeaderType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__HeaderType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__MessageProperty:
		if (p->size < 0)
			SOAP_DELETE((ns2__MessageProperty*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__MessageProperty*)p->ptr);
		break;
	case SOAP_TYPE_ns2__MessageType:
		if (p->size < 0)
			SOAP_DELETE((ns2__MessageType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__MessageType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__RequestMessageType:
		if (p->size < 0)
			SOAP_DELETE((ns2__RequestMessageType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__RequestMessageType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ResponseMessageType:
		if (p->size < 0)
			SOAP_DELETE((ns2__ResponseMessageType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ResponseMessageType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__FaultMessageType:
		if (p->size < 0)
			SOAP_DELETE((ns2__FaultMessageType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__FaultMessageType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__EventMessageType:
		if (p->size < 0)
			SOAP_DELETE((ns2__EventMessageType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__EventMessageType*)p->ptr);
		break;
	case SOAP_TYPE__ns2__ErrorType_ID:
		if (p->size < 0)
			SOAP_DELETE((_ns2__ErrorType_ID*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns2__ErrorType_ID*)p->ptr);
		break;
	case SOAP_TYPE__ns2__ErrorType_relatedID:
		if (p->size < 0)
			SOAP_DELETE((_ns2__ErrorType_relatedID*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns2__ErrorType_relatedID*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ErrorType:
		if (p->size < 0)
			SOAP_DELETE((ns2__ErrorType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ErrorType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__OptionType:
		if (p->size < 0)
			SOAP_DELETE((ns2__OptionType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__OptionType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__LocationType:
		if (p->size < 0)
			SOAP_DELETE((ns2__LocationType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__LocationType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ObjectType:
		if (p->size < 0)
			SOAP_DELETE((ns2__ObjectType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ObjectType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__NameType:
		if (p->size < 0)
			SOAP_DELETE((ns2__NameType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__NameType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__Name:
		if (p->size < 0)
			SOAP_DELETE((ns2__Name*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__Name*)p->ptr);
		break;
	case SOAP_TYPE_ns2__NameTypeAuthority:
		if (p->size < 0)
			SOAP_DELETE((ns2__NameTypeAuthority*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__NameTypeAuthority*)p->ptr);
		break;
	case SOAP_TYPE_ns3__ArrayValuesType:
		if (p->size < 0)
			SOAP_DELETE((ns3__ArrayValuesType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__ArrayValuesType*)p->ptr);
		break;
	case SOAP_TYPE_ns3__DeviceClassType:
		if (p->size < 0)
			SOAP_DELETE((ns3__DeviceClassType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__DeviceClassType*)p->ptr);
		break;
	case SOAP_TYPE_ns3__DeviceValuesType:
		if (p->size < 0)
			SOAP_DELETE((ns3__DeviceValuesType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__DeviceValuesType*)p->ptr);
		break;
	case SOAP_TYPE_ns3__CommonValuesType:
		if (p->size < 0)
			SOAP_DELETE((ns3__CommonValuesType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__CommonValuesType*)p->ptr);
		break;
	case SOAP_TYPE___ns1__PublishEvent:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__PublishEvent*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__PublishEvent*)p->ptr);
		break;
	case SOAP_TYPE___ns1__Request:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__Request*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__Request*)p->ptr);
		break;
	case SOAP_TYPE___ns1__ResponseResponse:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__ResponseResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__ResponseResponse*)p->ptr);
		break;
	case SOAP_TYPE___ns1__Response:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__Response*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__Response*)p->ptr);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Header*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Header*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Code*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Code*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Detail*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Detail*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Reason*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Reason*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Fault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Fault*)p->ptr);
		break;
#endif
	case SOAP_TYPE_xsd__QName:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__integer:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__DeviceClassType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns3__DeviceClassType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns3__DeviceClassType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__Name:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__Name * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__Name * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__MessageProperty:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__MessageProperty * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__MessageProperty * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__OperationType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__OperationType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__OperationType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOf_ns2__PayloadType_ID:
		if (p->size < 0)
			SOAP_DELETE((std::vector<_ns2__PayloadType_ID >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<_ns2__PayloadType_ID >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__ArrayValuesType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns3__ArrayValuesType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns3__ArrayValuesType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__DeviceValuesType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns3__DeviceValuesType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns3__DeviceValuesType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__CommonValuesType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns3__CommonValuesType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns3__CommonValuesType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOf_ns2__ReplyType_ID:
		if (p->size < 0)
			SOAP_DELETE((std::vector<_ns2__ReplyType_ID >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<_ns2__ReplyType_ID >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__ErrorType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__ErrorType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__ErrorType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOf_XML:
		if (p->size < 0)
			SOAP_DELETE((std::vector<char * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<char * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOf_ns2__RequestType_ID:
		if (p->size < 0)
			SOAP_DELETE((std::vector<_ns2__RequestType_ID >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<_ns2__RequestType_ID >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__OptionType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__OptionType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__OptionType * >*)p->ptr);
		break;
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_container_id_forward(struct soap *soap, const char *href, void *p, size_t len, int st, int tt, size_t n, unsigned int k)
{	return soap_id_forward(soap, href, p, len, st, tt, n, k, soap_container_insert);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_container_insert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
#ifdef WIN32
#pragma warning(push)
#pragma warning(disable:4065)
#endif
{
	(void)soap; (void)st; (void)p; (void)len; (void)q; (void)n; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__DeviceClassType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns3__DeviceClassType * >*)p)[len] = *(ns3__DeviceClassType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__Name:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__Name * >*)p)[len] = *(ns2__Name **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__MessageProperty:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__MessageProperty * >*)p)[len] = *(ns2__MessageProperty **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__OperationType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__OperationType * >*)p)[len] = *(ns2__OperationType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOf_ns2__PayloadType_ID:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<_ns2__PayloadType_ID >*)p)[len] = *(_ns2__PayloadType_ID *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__ArrayValuesType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns3__ArrayValuesType * >*)p)[len] = *(ns3__ArrayValuesType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__DeviceValuesType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns3__DeviceValuesType * >*)p)[len] = *(ns3__DeviceValuesType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__CommonValuesType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns3__CommonValuesType * >*)p)[len] = *(ns3__CommonValuesType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOf_ns2__ReplyType_ID:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<_ns2__ReplyType_ID >*)p)[len] = *(_ns2__ReplyType_ID *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__ErrorType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__ErrorType * >*)p)[len] = *(ns2__ErrorType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOf_XML:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<char * >*)p)[len] = *(char **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOf_ns2__RequestType_ID:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<_ns2__RequestType_ID >*)p)[len] = *(_ns2__RequestType_ID *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__OptionType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__OptionType * >*)p)[len] = *(ns2__OptionType **)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", st, tt));
	}
#ifdef WIN32
#pragma warning(pop)
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_time(struct soap *soap, time_t *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_time
	*a = SOAP_DEFAULT_time;
#else
	*a = (time_t)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_time(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_time);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_time(struct soap *soap, const char *tag, time_t *a, const char *type)
{	time_t *p;
	p = soap_indateTime(soap, tag, a, type, SOAP_TYPE_time);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_time(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_time);
	if (soap_out_time(soap, tag?tag:"dateTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_time(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_time(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns2__ErrorType_level(struct soap *soap, enum _ns2__ErrorType_level *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT__ns2__ErrorType_level
	*a = SOAP_DEFAULT__ns2__ErrorType_level;
#else
	*a = (enum _ns2__ErrorType_level)0;
#endif
}

static const struct soap_code_map soap_codes__ns2__ErrorType_level[] =
{	{ (long)_ns2__ErrorType_level__INFORM, "INFORM" },
	{ (long)_ns2__ErrorType_level__WARNING, "WARNING" },
	{ (long)_ns2__ErrorType_level__FATAL, "FATAL" },
	{ (long)_ns2__ErrorType_level__CATASTROPHIC, "CATASTROPHIC" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__ns2__ErrorType_level2s(struct soap *soap, enum _ns2__ErrorType_level n)
{	const char *s = soap_code_str(soap_codes__ns2__ErrorType_level, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__ErrorType_level(struct soap *soap, const char *tag, int id, const enum _ns2__ErrorType_level *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__ErrorType_level), type) || soap_send(soap, soap__ns2__ErrorType_level2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_ns2__ErrorType_level(struct soap *soap, const char *s, enum _ns2__ErrorType_level *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes__ns2__ErrorType_level, s);
	if (map)
		*a = (enum _ns2__ErrorType_level)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum _ns2__ErrorType_level)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _ns2__ErrorType_level * SOAP_FMAC4 soap_in__ns2__ErrorType_level(struct soap *soap, const char *tag, enum _ns2__ErrorType_level *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _ns2__ErrorType_level *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__ErrorType_level, sizeof(enum _ns2__ErrorType_level), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2_ns2__ErrorType_level(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum _ns2__ErrorType_level *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__ErrorType_level, 0, sizeof(enum _ns2__ErrorType_level), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns2__ErrorType_level(struct soap *soap, const enum _ns2__ErrorType_level *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns2__ErrorType_level);
	if (soap_out__ns2__ErrorType_level(soap, tag?tag:"ns2:ErrorType-level", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum _ns2__ErrorType_level * SOAP_FMAC4 soap_get__ns2__ErrorType_level(struct soap *soap, enum _ns2__ErrorType_level *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__ErrorType_level(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns2__HeaderType_Verb(struct soap *soap, enum _ns2__HeaderType_Verb *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT__ns2__HeaderType_Verb
	*a = SOAP_DEFAULT__ns2__HeaderType_Verb;
#else
	*a = (enum _ns2__HeaderType_Verb)0;
#endif
}

static const struct soap_code_map soap_codes__ns2__HeaderType_Verb[] =
{	{ (long)_ns2__HeaderType_Verb__cancel, "cancel" },
	{ (long)_ns2__HeaderType_Verb__canceled, "canceled" },
	{ (long)_ns2__HeaderType_Verb__change, "change" },
	{ (long)_ns2__HeaderType_Verb__changed, "changed" },
	{ (long)_ns2__HeaderType_Verb__create, "create" },
	{ (long)_ns2__HeaderType_Verb__created, "created" },
	{ (long)_ns2__HeaderType_Verb__close, "close" },
	{ (long)_ns2__HeaderType_Verb__closed, "closed" },
	{ (long)_ns2__HeaderType_Verb__delete_, "delete" },
	{ (long)_ns2__HeaderType_Verb__deleted, "deleted" },
	{ (long)_ns2__HeaderType_Verb__get, "get" },
	{ (long)_ns2__HeaderType_Verb__reply, "reply" },
	{ (long)_ns2__HeaderType_Verb__execute, "execute" },
	{ (long)_ns2__HeaderType_Verb__executed, "executed" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__ns2__HeaderType_Verb2s(struct soap *soap, enum _ns2__HeaderType_Verb n)
{	const char *s = soap_code_str(soap_codes__ns2__HeaderType_Verb, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__HeaderType_Verb(struct soap *soap, const char *tag, int id, const enum _ns2__HeaderType_Verb *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__HeaderType_Verb), type) || soap_send(soap, soap__ns2__HeaderType_Verb2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_ns2__HeaderType_Verb(struct soap *soap, const char *s, enum _ns2__HeaderType_Verb *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes__ns2__HeaderType_Verb, s);
	if (map)
		*a = (enum _ns2__HeaderType_Verb)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 13)))
			return soap->error = SOAP_TYPE;
		*a = (enum _ns2__HeaderType_Verb)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _ns2__HeaderType_Verb * SOAP_FMAC4 soap_in__ns2__HeaderType_Verb(struct soap *soap, const char *tag, enum _ns2__HeaderType_Verb *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _ns2__HeaderType_Verb *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__HeaderType_Verb, sizeof(enum _ns2__HeaderType_Verb), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2_ns2__HeaderType_Verb(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum _ns2__HeaderType_Verb *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__HeaderType_Verb, 0, sizeof(enum _ns2__HeaderType_Verb), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns2__HeaderType_Verb(struct soap *soap, const enum _ns2__HeaderType_Verb *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns2__HeaderType_Verb);
	if (soap_out__ns2__HeaderType_Verb(soap, tag?tag:"ns2:HeaderType-Verb", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum _ns2__HeaderType_Verb * SOAP_FMAC4 soap_get__ns2__HeaderType_Verb(struct soap *soap, enum _ns2__HeaderType_Verb *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__HeaderType_Verb(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{
	(void)soap; /* appease -Wall -Werror */
return soap_code_str(soap_codes_bool, n!=0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, 0, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bool);
	if (soap_out_bool(soap, tag?tag:"boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns2__ReplyType_Result(struct soap *soap, enum _ns2__ReplyType_Result *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT__ns2__ReplyType_Result
	*a = SOAP_DEFAULT__ns2__ReplyType_Result;
#else
	*a = (enum _ns2__ReplyType_Result)0;
#endif
}

static const struct soap_code_map soap_codes__ns2__ReplyType_Result[] =
{	{ (long)_ns2__ReplyType_Result__OK, "OK" },
	{ (long)_ns2__ReplyType_Result__PARTIAL, "PARTIAL" },
	{ (long)_ns2__ReplyType_Result__FAILED, "FAILED" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__ns2__ReplyType_Result2s(struct soap *soap, enum _ns2__ReplyType_Result n)
{	const char *s = soap_code_str(soap_codes__ns2__ReplyType_Result, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__ReplyType_Result(struct soap *soap, const char *tag, int id, const enum _ns2__ReplyType_Result *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__ReplyType_Result), type) || soap_send(soap, soap__ns2__ReplyType_Result2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_ns2__ReplyType_Result(struct soap *soap, const char *s, enum _ns2__ReplyType_Result *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes__ns2__ReplyType_Result, s);
	if (map)
		*a = (enum _ns2__ReplyType_Result)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum _ns2__ReplyType_Result)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _ns2__ReplyType_Result * SOAP_FMAC4 soap_in__ns2__ReplyType_Result(struct soap *soap, const char *tag, enum _ns2__ReplyType_Result *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _ns2__ReplyType_Result *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__ReplyType_Result, sizeof(enum _ns2__ReplyType_Result), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2_ns2__ReplyType_Result(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum _ns2__ReplyType_Result *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__ReplyType_Result, 0, sizeof(enum _ns2__ReplyType_Result), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns2__ReplyType_Result(struct soap *soap, const enum _ns2__ReplyType_Result *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns2__ReplyType_Result);
	if (soap_out__ns2__ReplyType_Result(soap, tag?tag:"ns2:ReplyType-Result", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum _ns2__ReplyType_Result * SOAP_FMAC4 soap_get__ns2__ReplyType_Result(struct soap *soap, enum _ns2__ReplyType_Result *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__ReplyType_Result(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__IDKindType(struct soap *soap, enum ns2__IDKindType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__IDKindType
	*a = SOAP_DEFAULT_ns2__IDKindType;
#else
	*a = (enum ns2__IDKindType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__IDKindType[] =
{	{ (long)ns2__IDKindType__name, "name" },
	{ (long)ns2__IDKindType__uuid, "uuid" },
	{ (long)ns2__IDKindType__transaction, "transaction" },
	{ (long)ns2__IDKindType__other, "other" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__IDKindType2s(struct soap *soap, enum ns2__IDKindType n)
{	const char *s = soap_code_str(soap_codes_ns2__IDKindType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__IDKindType(struct soap *soap, const char *tag, int id, const enum ns2__IDKindType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__IDKindType), type) || soap_send(soap, soap_ns2__IDKindType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__IDKindType(struct soap *soap, const char *s, enum ns2__IDKindType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__IDKindType, s);
	if (map)
		*a = (enum ns2__IDKindType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__IDKindType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__IDKindType * SOAP_FMAC4 soap_in_ns2__IDKindType(struct soap *soap, const char *tag, enum ns2__IDKindType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__IDKindType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__IDKindType, sizeof(enum ns2__IDKindType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__IDKindType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__IDKindType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__IDKindType, 0, sizeof(enum ns2__IDKindType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__IDKindType(struct soap *soap, const enum ns2__IDKindType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__IDKindType);
	if (soap_out_ns2__IDKindType(soap, tag?tag:"ns2:IDKindType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__IDKindType * SOAP_FMAC4 soap_get_ns2__IDKindType(struct soap *soap, enum ns2__IDKindType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__IDKindType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns2__ErrorType_relatedID::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__string(soap, &this->_ns2__ErrorType_relatedID::__item);
	this->_ns2__ErrorType_relatedID::idType = NULL;
	this->_ns2__ErrorType_relatedID::idAuthority = NULL;
	this->_ns2__ErrorType_relatedID::kind = NULL;
	this->_ns2__ErrorType_relatedID::objectType = NULL;
}

void _ns2__ErrorType_relatedID::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns2__ErrorType_relatedID::__item, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns2__ErrorType_relatedID::__item);
#endif
}

int _ns2__ErrorType_relatedID::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns2__ErrorType_relatedID(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__ErrorType_relatedID(struct soap *soap, const char *tag, int id, const _ns2__ErrorType_relatedID *a, const char *type)
{
	if (((_ns2__ErrorType_relatedID*)a)->idType)
		soap_set_attr(soap, "idType", ((_ns2__ErrorType_relatedID*)a)->idType->c_str(), 1);
	if (((_ns2__ErrorType_relatedID*)a)->idAuthority)
		soap_set_attr(soap, "idAuthority", ((_ns2__ErrorType_relatedID*)a)->idAuthority->c_str(), 1);
	if (((_ns2__ErrorType_relatedID*)a)->kind)
		soap_set_attr(soap, "kind", soap_ns2__IDKindType2s(soap, *((_ns2__ErrorType_relatedID*)a)->kind), 1);
	if (((_ns2__ErrorType_relatedID*)a)->objectType)
		soap_set_attr(soap, "objectType", ((_ns2__ErrorType_relatedID*)a)->objectType->c_str(), 1);
	return soap_out_std__string(soap, tag, id, &a->_ns2__ErrorType_relatedID::__item, "");
}

void *_ns2__ErrorType_relatedID::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns2__ErrorType_relatedID(soap, tag, this, type);
}

SOAP_FMAC3 _ns2__ErrorType_relatedID * SOAP_FMAC4 soap_in__ns2__ErrorType_relatedID(struct soap *soap, const char *tag, _ns2__ErrorType_relatedID *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (_ns2__ErrorType_relatedID *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__ErrorType_relatedID, sizeof(_ns2__ErrorType_relatedID), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns2__ErrorType_relatedID)
			return (_ns2__ErrorType_relatedID *)a->soap_in(soap, tag, type);
	}
	{	const char *t = soap_attr_value(soap, "idType", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_ns2__ErrorType_relatedID*)a)->idType = soap_new_std__string(soap, -1);
				((_ns2__ErrorType_relatedID*)a)->idType->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "idAuthority", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_ns2__ErrorType_relatedID*)a)->idAuthority = soap_new_std__string(soap, -1);
				((_ns2__ErrorType_relatedID*)a)->idAuthority->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "kind", 0);
		if (t)
		{
			if (!(((_ns2__ErrorType_relatedID*)a)->kind = (enum ns2__IDKindType *)soap_malloc(soap, sizeof(enum ns2__IDKindType))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2ns2__IDKindType(soap, t, ((_ns2__ErrorType_relatedID*)a)->kind))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "objectType", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_ns2__ErrorType_relatedID*)a)->objectType = soap_new_std__string(soap, -1);
				((_ns2__ErrorType_relatedID*)a)->objectType->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (!soap_in_std__string(soap, tag, &(a->_ns2__ErrorType_relatedID::__item), ""))
		return NULL;
	return a;
}

int _ns2__ErrorType_relatedID::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns2__ErrorType_relatedID);
	if (this->soap_out(soap, tag?tag:"ns2:ErrorType-relatedID", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns2__ErrorType_relatedID::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns2__ErrorType_relatedID(soap, this, tag, type);
}

SOAP_FMAC3 _ns2__ErrorType_relatedID * SOAP_FMAC4 soap_get__ns2__ErrorType_relatedID(struct soap *soap, _ns2__ErrorType_relatedID *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__ErrorType_relatedID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns2__ErrorType_relatedID * SOAP_FMAC2 soap_instantiate__ns2__ErrorType_relatedID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__ErrorType_relatedID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns2__ErrorType_relatedID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns2__ErrorType_relatedID);
		if (size)
			*size = sizeof(_ns2__ErrorType_relatedID);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns2__ErrorType_relatedID, n);
		if (size)
			*size = n * sizeof(_ns2__ErrorType_relatedID);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns2__ErrorType_relatedID*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns2__ErrorType_relatedID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns2__ErrorType_relatedID %p -> %p\n", q, p));
	*(_ns2__ErrorType_relatedID*)p = *(_ns2__ErrorType_relatedID*)q;
}

void _ns2__ErrorType_ID::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__string(soap, &this->_ns2__ErrorType_ID::__item);
	this->_ns2__ErrorType_ID::idType = NULL;
	this->_ns2__ErrorType_ID::idAuthority = NULL;
	this->_ns2__ErrorType_ID::kind = NULL;
	this->_ns2__ErrorType_ID::objectType = NULL;
}

void _ns2__ErrorType_ID::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns2__ErrorType_ID::__item, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns2__ErrorType_ID::__item);
#endif
}

int _ns2__ErrorType_ID::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns2__ErrorType_ID(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__ErrorType_ID(struct soap *soap, const char *tag, int id, const _ns2__ErrorType_ID *a, const char *type)
{
	if (((_ns2__ErrorType_ID*)a)->idType)
		soap_set_attr(soap, "idType", ((_ns2__ErrorType_ID*)a)->idType->c_str(), 1);
	if (((_ns2__ErrorType_ID*)a)->idAuthority)
		soap_set_attr(soap, "idAuthority", ((_ns2__ErrorType_ID*)a)->idAuthority->c_str(), 1);
	if (((_ns2__ErrorType_ID*)a)->kind)
		soap_set_attr(soap, "kind", soap_ns2__IDKindType2s(soap, *((_ns2__ErrorType_ID*)a)->kind), 1);
	if (((_ns2__ErrorType_ID*)a)->objectType)
		soap_set_attr(soap, "objectType", ((_ns2__ErrorType_ID*)a)->objectType->c_str(), 1);
	return soap_out_std__string(soap, tag, id, &a->_ns2__ErrorType_ID::__item, "");
}

void *_ns2__ErrorType_ID::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns2__ErrorType_ID(soap, tag, this, type);
}

SOAP_FMAC3 _ns2__ErrorType_ID * SOAP_FMAC4 soap_in__ns2__ErrorType_ID(struct soap *soap, const char *tag, _ns2__ErrorType_ID *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (_ns2__ErrorType_ID *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__ErrorType_ID, sizeof(_ns2__ErrorType_ID), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns2__ErrorType_ID)
			return (_ns2__ErrorType_ID *)a->soap_in(soap, tag, type);
	}
	{	const char *t = soap_attr_value(soap, "idType", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_ns2__ErrorType_ID*)a)->idType = soap_new_std__string(soap, -1);
				((_ns2__ErrorType_ID*)a)->idType->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "idAuthority", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_ns2__ErrorType_ID*)a)->idAuthority = soap_new_std__string(soap, -1);
				((_ns2__ErrorType_ID*)a)->idAuthority->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "kind", 0);
		if (t)
		{
			if (!(((_ns2__ErrorType_ID*)a)->kind = (enum ns2__IDKindType *)soap_malloc(soap, sizeof(enum ns2__IDKindType))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2ns2__IDKindType(soap, t, ((_ns2__ErrorType_ID*)a)->kind))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "objectType", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_ns2__ErrorType_ID*)a)->objectType = soap_new_std__string(soap, -1);
				((_ns2__ErrorType_ID*)a)->objectType->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (!soap_in_std__string(soap, tag, &(a->_ns2__ErrorType_ID::__item), ""))
		return NULL;
	return a;
}

int _ns2__ErrorType_ID::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns2__ErrorType_ID);
	if (this->soap_out(soap, tag?tag:"ns2:ErrorType-ID", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns2__ErrorType_ID::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns2__ErrorType_ID(soap, this, tag, type);
}

SOAP_FMAC3 _ns2__ErrorType_ID * SOAP_FMAC4 soap_get__ns2__ErrorType_ID(struct soap *soap, _ns2__ErrorType_ID *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__ErrorType_ID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns2__ErrorType_ID * SOAP_FMAC2 soap_instantiate__ns2__ErrorType_ID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__ErrorType_ID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns2__ErrorType_ID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns2__ErrorType_ID);
		if (size)
			*size = sizeof(_ns2__ErrorType_ID);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns2__ErrorType_ID, n);
		if (size)
			*size = n * sizeof(_ns2__ErrorType_ID);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns2__ErrorType_ID*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns2__ErrorType_ID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns2__ErrorType_ID %p -> %p\n", q, p));
	*(_ns2__ErrorType_ID*)p = *(_ns2__ErrorType_ID*)q;
}

void _ns2__PayloadType_ID::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__string(soap, &this->_ns2__PayloadType_ID::__item);
	this->_ns2__PayloadType_ID::idType = NULL;
	this->_ns2__PayloadType_ID::idAuthority = NULL;
	this->_ns2__PayloadType_ID::kind = NULL;
	this->_ns2__PayloadType_ID::objectType = NULL;
}

void _ns2__PayloadType_ID::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns2__PayloadType_ID::__item, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns2__PayloadType_ID::__item);
#endif
}

int _ns2__PayloadType_ID::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns2__PayloadType_ID(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__PayloadType_ID(struct soap *soap, const char *tag, int id, const _ns2__PayloadType_ID *a, const char *type)
{
	if (((_ns2__PayloadType_ID*)a)->idType)
		soap_set_attr(soap, "idType", ((_ns2__PayloadType_ID*)a)->idType->c_str(), 1);
	if (((_ns2__PayloadType_ID*)a)->idAuthority)
		soap_set_attr(soap, "idAuthority", ((_ns2__PayloadType_ID*)a)->idAuthority->c_str(), 1);
	if (((_ns2__PayloadType_ID*)a)->kind)
		soap_set_attr(soap, "kind", soap_ns2__IDKindType2s(soap, *((_ns2__PayloadType_ID*)a)->kind), 1);
	if (((_ns2__PayloadType_ID*)a)->objectType)
		soap_set_attr(soap, "objectType", ((_ns2__PayloadType_ID*)a)->objectType->c_str(), 1);
	return soap_out_std__string(soap, tag, id, &a->_ns2__PayloadType_ID::__item, "");
}

void *_ns2__PayloadType_ID::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns2__PayloadType_ID(soap, tag, this, type);
}

SOAP_FMAC3 _ns2__PayloadType_ID * SOAP_FMAC4 soap_in__ns2__PayloadType_ID(struct soap *soap, const char *tag, _ns2__PayloadType_ID *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (_ns2__PayloadType_ID *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__PayloadType_ID, sizeof(_ns2__PayloadType_ID), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns2__PayloadType_ID)
			return (_ns2__PayloadType_ID *)a->soap_in(soap, tag, type);
	}
	{	const char *t = soap_attr_value(soap, "idType", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_ns2__PayloadType_ID*)a)->idType = soap_new_std__string(soap, -1);
				((_ns2__PayloadType_ID*)a)->idType->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "idAuthority", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_ns2__PayloadType_ID*)a)->idAuthority = soap_new_std__string(soap, -1);
				((_ns2__PayloadType_ID*)a)->idAuthority->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "kind", 0);
		if (t)
		{
			if (!(((_ns2__PayloadType_ID*)a)->kind = (enum ns2__IDKindType *)soap_malloc(soap, sizeof(enum ns2__IDKindType))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2ns2__IDKindType(soap, t, ((_ns2__PayloadType_ID*)a)->kind))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "objectType", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_ns2__PayloadType_ID*)a)->objectType = soap_new_std__string(soap, -1);
				((_ns2__PayloadType_ID*)a)->objectType->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (!soap_in_std__string(soap, tag, &(a->_ns2__PayloadType_ID::__item), ""))
		return NULL;
	return a;
}

int _ns2__PayloadType_ID::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns2__PayloadType_ID);
	if (this->soap_out(soap, tag?tag:"ns2:PayloadType-ID", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns2__PayloadType_ID::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns2__PayloadType_ID(soap, this, tag, type);
}

SOAP_FMAC3 _ns2__PayloadType_ID * SOAP_FMAC4 soap_get__ns2__PayloadType_ID(struct soap *soap, _ns2__PayloadType_ID *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__PayloadType_ID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns2__PayloadType_ID * SOAP_FMAC2 soap_instantiate__ns2__PayloadType_ID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__PayloadType_ID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns2__PayloadType_ID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns2__PayloadType_ID);
		if (size)
			*size = sizeof(_ns2__PayloadType_ID);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns2__PayloadType_ID, n);
		if (size)
			*size = n * sizeof(_ns2__PayloadType_ID);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns2__PayloadType_ID*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns2__PayloadType_ID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns2__PayloadType_ID %p -> %p\n", q, p));
	*(_ns2__PayloadType_ID*)p = *(_ns2__PayloadType_ID*)q;
}

void _ns2__ReplyType_ID::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__string(soap, &this->_ns2__ReplyType_ID::__item);
	this->_ns2__ReplyType_ID::idType = NULL;
	this->_ns2__ReplyType_ID::idAuthority = NULL;
	this->_ns2__ReplyType_ID::kind = NULL;
	this->_ns2__ReplyType_ID::objectType = NULL;
}

void _ns2__ReplyType_ID::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns2__ReplyType_ID::__item, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns2__ReplyType_ID::__item);
#endif
}

int _ns2__ReplyType_ID::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns2__ReplyType_ID(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__ReplyType_ID(struct soap *soap, const char *tag, int id, const _ns2__ReplyType_ID *a, const char *type)
{
	if (((_ns2__ReplyType_ID*)a)->idType)
		soap_set_attr(soap, "idType", ((_ns2__ReplyType_ID*)a)->idType->c_str(), 1);
	if (((_ns2__ReplyType_ID*)a)->idAuthority)
		soap_set_attr(soap, "idAuthority", ((_ns2__ReplyType_ID*)a)->idAuthority->c_str(), 1);
	if (((_ns2__ReplyType_ID*)a)->kind)
		soap_set_attr(soap, "kind", soap_ns2__IDKindType2s(soap, *((_ns2__ReplyType_ID*)a)->kind), 1);
	if (((_ns2__ReplyType_ID*)a)->objectType)
		soap_set_attr(soap, "objectType", ((_ns2__ReplyType_ID*)a)->objectType->c_str(), 1);
	return soap_out_std__string(soap, tag, id, &a->_ns2__ReplyType_ID::__item, "");
}

void *_ns2__ReplyType_ID::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns2__ReplyType_ID(soap, tag, this, type);
}

SOAP_FMAC3 _ns2__ReplyType_ID * SOAP_FMAC4 soap_in__ns2__ReplyType_ID(struct soap *soap, const char *tag, _ns2__ReplyType_ID *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (_ns2__ReplyType_ID *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__ReplyType_ID, sizeof(_ns2__ReplyType_ID), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns2__ReplyType_ID)
			return (_ns2__ReplyType_ID *)a->soap_in(soap, tag, type);
	}
	{	const char *t = soap_attr_value(soap, "idType", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_ns2__ReplyType_ID*)a)->idType = soap_new_std__string(soap, -1);
				((_ns2__ReplyType_ID*)a)->idType->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "idAuthority", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_ns2__ReplyType_ID*)a)->idAuthority = soap_new_std__string(soap, -1);
				((_ns2__ReplyType_ID*)a)->idAuthority->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "kind", 0);
		if (t)
		{
			if (!(((_ns2__ReplyType_ID*)a)->kind = (enum ns2__IDKindType *)soap_malloc(soap, sizeof(enum ns2__IDKindType))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2ns2__IDKindType(soap, t, ((_ns2__ReplyType_ID*)a)->kind))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "objectType", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_ns2__ReplyType_ID*)a)->objectType = soap_new_std__string(soap, -1);
				((_ns2__ReplyType_ID*)a)->objectType->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (!soap_in_std__string(soap, tag, &(a->_ns2__ReplyType_ID::__item), ""))
		return NULL;
	return a;
}

int _ns2__ReplyType_ID::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns2__ReplyType_ID);
	if (this->soap_out(soap, tag?tag:"ns2:ReplyType-ID", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns2__ReplyType_ID::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns2__ReplyType_ID(soap, this, tag, type);
}

SOAP_FMAC3 _ns2__ReplyType_ID * SOAP_FMAC4 soap_get__ns2__ReplyType_ID(struct soap *soap, _ns2__ReplyType_ID *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__ReplyType_ID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns2__ReplyType_ID * SOAP_FMAC2 soap_instantiate__ns2__ReplyType_ID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__ReplyType_ID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns2__ReplyType_ID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns2__ReplyType_ID);
		if (size)
			*size = sizeof(_ns2__ReplyType_ID);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns2__ReplyType_ID, n);
		if (size)
			*size = n * sizeof(_ns2__ReplyType_ID);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns2__ReplyType_ID*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns2__ReplyType_ID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns2__ReplyType_ID %p -> %p\n", q, p));
	*(_ns2__ReplyType_ID*)p = *(_ns2__ReplyType_ID*)q;
}

void _ns2__RequestType_ID::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__string(soap, &this->_ns2__RequestType_ID::__item);
	this->_ns2__RequestType_ID::idType = NULL;
	this->_ns2__RequestType_ID::idAuthority = NULL;
	this->_ns2__RequestType_ID::kind = NULL;
	this->_ns2__RequestType_ID::objectType = NULL;
}

void _ns2__RequestType_ID::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns2__RequestType_ID::__item, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns2__RequestType_ID::__item);
#endif
}

int _ns2__RequestType_ID::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns2__RequestType_ID(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__RequestType_ID(struct soap *soap, const char *tag, int id, const _ns2__RequestType_ID *a, const char *type)
{
	if (((_ns2__RequestType_ID*)a)->idType)
		soap_set_attr(soap, "idType", ((_ns2__RequestType_ID*)a)->idType->c_str(), 1);
	if (((_ns2__RequestType_ID*)a)->idAuthority)
		soap_set_attr(soap, "idAuthority", ((_ns2__RequestType_ID*)a)->idAuthority->c_str(), 1);
	if (((_ns2__RequestType_ID*)a)->kind)
		soap_set_attr(soap, "kind", soap_ns2__IDKindType2s(soap, *((_ns2__RequestType_ID*)a)->kind), 1);
	if (((_ns2__RequestType_ID*)a)->objectType)
		soap_set_attr(soap, "objectType", ((_ns2__RequestType_ID*)a)->objectType->c_str(), 1);
	return soap_out_std__string(soap, tag, id, &a->_ns2__RequestType_ID::__item, "");
}

void *_ns2__RequestType_ID::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns2__RequestType_ID(soap, tag, this, type);
}

SOAP_FMAC3 _ns2__RequestType_ID * SOAP_FMAC4 soap_in__ns2__RequestType_ID(struct soap *soap, const char *tag, _ns2__RequestType_ID *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (_ns2__RequestType_ID *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__RequestType_ID, sizeof(_ns2__RequestType_ID), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns2__RequestType_ID)
			return (_ns2__RequestType_ID *)a->soap_in(soap, tag, type);
	}
	{	const char *t = soap_attr_value(soap, "idType", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_ns2__RequestType_ID*)a)->idType = soap_new_std__string(soap, -1);
				((_ns2__RequestType_ID*)a)->idType->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "idAuthority", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_ns2__RequestType_ID*)a)->idAuthority = soap_new_std__string(soap, -1);
				((_ns2__RequestType_ID*)a)->idAuthority->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "kind", 0);
		if (t)
		{
			if (!(((_ns2__RequestType_ID*)a)->kind = (enum ns2__IDKindType *)soap_malloc(soap, sizeof(enum ns2__IDKindType))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2ns2__IDKindType(soap, t, ((_ns2__RequestType_ID*)a)->kind))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "objectType", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_ns2__RequestType_ID*)a)->objectType = soap_new_std__string(soap, -1);
				((_ns2__RequestType_ID*)a)->objectType->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (!soap_in_std__string(soap, tag, &(a->_ns2__RequestType_ID::__item), ""))
		return NULL;
	return a;
}

int _ns2__RequestType_ID::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns2__RequestType_ID);
	if (this->soap_out(soap, tag?tag:"ns2:RequestType-ID", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns2__RequestType_ID::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns2__RequestType_ID(soap, this, tag, type);
}

SOAP_FMAC3 _ns2__RequestType_ID * SOAP_FMAC4 soap_get__ns2__RequestType_ID(struct soap *soap, _ns2__RequestType_ID *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__RequestType_ID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns2__RequestType_ID * SOAP_FMAC2 soap_instantiate__ns2__RequestType_ID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__RequestType_ID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns2__RequestType_ID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns2__RequestType_ID);
		if (size)
			*size = sizeof(_ns2__RequestType_ID);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns2__RequestType_ID, n);
		if (size)
			*size = n * sizeof(_ns2__RequestType_ID);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns2__RequestType_ID*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns2__RequestType_ID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns2__RequestType_ID %p -> %p\n", q, p));
	*(_ns2__RequestType_ID*)p = *(_ns2__RequestType_ID*)q;
}

void ns3__CommonValuesType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns3__CommonValuesType::Key);
	this->ns3__CommonValuesType::Value = NULL;
	this->ns3__CommonValuesType::UpperLimit = NULL;
	this->ns3__CommonValuesType::UpperUpperLimit = NULL;
	this->ns3__CommonValuesType::LowerLimit = NULL;
	this->ns3__CommonValuesType::LowerLowerLimit = NULL;
	this->ns3__CommonValuesType::Dead = NULL;
	this->ns3__CommonValuesType::Invalid = NULL;
	/* transient soap skipped */
}

void ns3__CommonValuesType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns3__CommonValuesType::Key, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns3__CommonValuesType::Key);
	soap_serialize_PointerTostd__string(soap, &this->ns3__CommonValuesType::Value);
	soap_serialize_PointerTobool(soap, &this->ns3__CommonValuesType::UpperLimit);
	soap_serialize_PointerTobool(soap, &this->ns3__CommonValuesType::UpperUpperLimit);
	soap_serialize_PointerTobool(soap, &this->ns3__CommonValuesType::LowerLimit);
	soap_serialize_PointerTobool(soap, &this->ns3__CommonValuesType::LowerLowerLimit);
	soap_serialize_PointerTobool(soap, &this->ns3__CommonValuesType::Dead);
	soap_serialize_PointerTobool(soap, &this->ns3__CommonValuesType::Invalid);
	/* transient soap skipped */
#endif
}

int ns3__CommonValuesType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__CommonValuesType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__CommonValuesType(struct soap *soap, const char *tag, int id, const ns3__CommonValuesType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__CommonValuesType), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns3:Key", -1, &(a->ns3__CommonValuesType::Key), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:Value", -1, &(a->ns3__CommonValuesType::Value), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns3:UpperLimit", -1, &(a->ns3__CommonValuesType::UpperLimit), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns3:UpperUpperLimit", -1, &(a->ns3__CommonValuesType::UpperUpperLimit), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns3:LowerLimit", -1, &(a->ns3__CommonValuesType::LowerLimit), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns3:LowerLowerLimit", -1, &(a->ns3__CommonValuesType::LowerLowerLimit), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns3:Dead", -1, &(a->ns3__CommonValuesType::Dead), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns3:Invalid", -1, &(a->ns3__CommonValuesType::Invalid), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__CommonValuesType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__CommonValuesType(soap, tag, this, type);
}

SOAP_FMAC3 ns3__CommonValuesType * SOAP_FMAC4 soap_in_ns3__CommonValuesType(struct soap *soap, const char *tag, ns3__CommonValuesType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__CommonValuesType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__CommonValuesType, sizeof(ns3__CommonValuesType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__CommonValuesType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__CommonValuesType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Key1 = 1;
	size_t soap_flag_Value1 = 1;
	size_t soap_flag_UpperLimit1 = 1;
	size_t soap_flag_UpperUpperLimit1 = 1;
	size_t soap_flag_LowerLimit1 = 1;
	size_t soap_flag_LowerLowerLimit1 = 1;
	size_t soap_flag_Dead1 = 1;
	size_t soap_flag_Invalid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Key1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns3:Key", &(a->ns3__CommonValuesType::Key), "xsd:string"))
				{	soap_flag_Key1--;
					continue;
				}
			if (soap_flag_Value1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns3:Value", &(a->ns3__CommonValuesType::Value), "xsd:string"))
				{	soap_flag_Value1--;
					continue;
				}
			if (soap_flag_UpperLimit1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ns3:UpperLimit", &(a->ns3__CommonValuesType::UpperLimit), "xsd:boolean"))
				{	soap_flag_UpperLimit1--;
					continue;
				}
			if (soap_flag_UpperUpperLimit1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ns3:UpperUpperLimit", &(a->ns3__CommonValuesType::UpperUpperLimit), "xsd:boolean"))
				{	soap_flag_UpperUpperLimit1--;
					continue;
				}
			if (soap_flag_LowerLimit1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ns3:LowerLimit", &(a->ns3__CommonValuesType::LowerLimit), "xsd:boolean"))
				{	soap_flag_LowerLimit1--;
					continue;
				}
			if (soap_flag_LowerLowerLimit1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ns3:LowerLowerLimit", &(a->ns3__CommonValuesType::LowerLowerLimit), "xsd:boolean"))
				{	soap_flag_LowerLowerLimit1--;
					continue;
				}
			if (soap_flag_Dead1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ns3:Dead", &(a->ns3__CommonValuesType::Dead), "xsd:boolean"))
				{	soap_flag_Dead1--;
					continue;
				}
			if (soap_flag_Invalid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ns3:Invalid", &(a->ns3__CommonValuesType::Invalid), "xsd:boolean"))
				{	soap_flag_Invalid1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__CommonValuesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__CommonValuesType, 0, sizeof(ns3__CommonValuesType), 0, soap_copy_ns3__CommonValuesType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Key1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns3__CommonValuesType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__CommonValuesType);
	if (this->soap_out(soap, tag?tag:"ns3:CommonValuesType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__CommonValuesType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__CommonValuesType(soap, this, tag, type);
}

SOAP_FMAC3 ns3__CommonValuesType * SOAP_FMAC4 soap_get_ns3__CommonValuesType(struct soap *soap, ns3__CommonValuesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__CommonValuesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__CommonValuesType * SOAP_FMAC2 soap_instantiate_ns3__CommonValuesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__CommonValuesType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__CommonValuesType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__CommonValuesType);
		if (size)
			*size = sizeof(ns3__CommonValuesType);
		((ns3__CommonValuesType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__CommonValuesType, n);
		if (size)
			*size = n * sizeof(ns3__CommonValuesType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns3__CommonValuesType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__CommonValuesType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__CommonValuesType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__CommonValuesType %p -> %p\n", q, p));
	*(ns3__CommonValuesType*)p = *(ns3__CommonValuesType*)q;
}

void ns3__DeviceValuesType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns3__DeviceValuesType::Code);
	soap_default_std__vectorTemplateOfPointerTons3__CommonValuesType(soap, &this->ns3__DeviceValuesType::RemoteSignal);
	soap_default_std__vectorTemplateOfPointerTons3__CommonValuesType(soap, &this->ns3__DeviceValuesType::RemoteMeasure);
	soap_default_std__vectorTemplateOfPointerTons3__CommonValuesType(soap, &this->ns3__DeviceValuesType::RemoteDegree);
	/* transient soap skipped */
}

void ns3__DeviceValuesType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns3__DeviceValuesType::Code, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns3__DeviceValuesType::Code);
	soap_serialize_std__vectorTemplateOfPointerTons3__CommonValuesType(soap, &this->ns3__DeviceValuesType::RemoteSignal);
	soap_serialize_std__vectorTemplateOfPointerTons3__CommonValuesType(soap, &this->ns3__DeviceValuesType::RemoteMeasure);
	soap_serialize_std__vectorTemplateOfPointerTons3__CommonValuesType(soap, &this->ns3__DeviceValuesType::RemoteDegree);
	/* transient soap skipped */
#endif
}

int ns3__DeviceValuesType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__DeviceValuesType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__DeviceValuesType(struct soap *soap, const char *tag, int id, const ns3__DeviceValuesType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__DeviceValuesType), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns3:Code", -1, &(a->ns3__DeviceValuesType::Code), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons3__CommonValuesType(soap, "ns3:RemoteSignal", -1, &(a->ns3__DeviceValuesType::RemoteSignal), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons3__CommonValuesType(soap, "ns3:RemoteMeasure", -1, &(a->ns3__DeviceValuesType::RemoteMeasure), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons3__CommonValuesType(soap, "ns3:RemoteDegree", -1, &(a->ns3__DeviceValuesType::RemoteDegree), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__DeviceValuesType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__DeviceValuesType(soap, tag, this, type);
}

SOAP_FMAC3 ns3__DeviceValuesType * SOAP_FMAC4 soap_in_ns3__DeviceValuesType(struct soap *soap, const char *tag, ns3__DeviceValuesType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__DeviceValuesType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__DeviceValuesType, sizeof(ns3__DeviceValuesType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__DeviceValuesType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__DeviceValuesType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Code1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Code1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns3:Code", &(a->ns3__DeviceValuesType::Code), "xsd:string"))
				{	soap_flag_Code1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons3__CommonValuesType(soap, "ns3:RemoteSignal", &(a->ns3__DeviceValuesType::RemoteSignal), "ns3:CommonValuesType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons3__CommonValuesType(soap, "ns3:RemoteMeasure", &(a->ns3__DeviceValuesType::RemoteMeasure), "ns3:CommonValuesType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons3__CommonValuesType(soap, "ns3:RemoteDegree", &(a->ns3__DeviceValuesType::RemoteDegree), "ns3:CommonValuesType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__DeviceValuesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__DeviceValuesType, 0, sizeof(ns3__DeviceValuesType), 0, soap_copy_ns3__DeviceValuesType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Code1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns3__DeviceValuesType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__DeviceValuesType);
	if (this->soap_out(soap, tag?tag:"ns3:DeviceValuesType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__DeviceValuesType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__DeviceValuesType(soap, this, tag, type);
}

SOAP_FMAC3 ns3__DeviceValuesType * SOAP_FMAC4 soap_get_ns3__DeviceValuesType(struct soap *soap, ns3__DeviceValuesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__DeviceValuesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__DeviceValuesType * SOAP_FMAC2 soap_instantiate_ns3__DeviceValuesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__DeviceValuesType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__DeviceValuesType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__DeviceValuesType);
		if (size)
			*size = sizeof(ns3__DeviceValuesType);
		((ns3__DeviceValuesType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__DeviceValuesType, n);
		if (size)
			*size = n * sizeof(ns3__DeviceValuesType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns3__DeviceValuesType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__DeviceValuesType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__DeviceValuesType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__DeviceValuesType %p -> %p\n", q, p));
	*(ns3__DeviceValuesType*)p = *(ns3__DeviceValuesType*)q;
}

void ns3__DeviceClassType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns3__DeviceClassType::ClassName);
	soap_default_std__vectorTemplateOfPointerTons3__DeviceValuesType(soap, &this->ns3__DeviceClassType::Devices);
	/* transient soap skipped */
}

void ns3__DeviceClassType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns3__DeviceClassType::ClassName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns3__DeviceClassType::ClassName);
	soap_serialize_std__vectorTemplateOfPointerTons3__DeviceValuesType(soap, &this->ns3__DeviceClassType::Devices);
	/* transient soap skipped */
#endif
}

int ns3__DeviceClassType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__DeviceClassType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__DeviceClassType(struct soap *soap, const char *tag, int id, const ns3__DeviceClassType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__DeviceClassType), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns3:ClassName", -1, &(a->ns3__DeviceClassType::ClassName), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons3__DeviceValuesType(soap, "ns3:Devices", -1, &(a->ns3__DeviceClassType::Devices), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__DeviceClassType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__DeviceClassType(soap, tag, this, type);
}

SOAP_FMAC3 ns3__DeviceClassType * SOAP_FMAC4 soap_in_ns3__DeviceClassType(struct soap *soap, const char *tag, ns3__DeviceClassType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__DeviceClassType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__DeviceClassType, sizeof(ns3__DeviceClassType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__DeviceClassType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__DeviceClassType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ClassName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ClassName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns3:ClassName", &(a->ns3__DeviceClassType::ClassName), "xsd:string"))
				{	soap_flag_ClassName1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons3__DeviceValuesType(soap, "ns3:Devices", &(a->ns3__DeviceClassType::Devices), "ns3:DeviceValuesType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__DeviceClassType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__DeviceClassType, 0, sizeof(ns3__DeviceClassType), 0, soap_copy_ns3__DeviceClassType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ClassName1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns3__DeviceClassType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__DeviceClassType);
	if (this->soap_out(soap, tag?tag:"ns3:DeviceClassType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__DeviceClassType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__DeviceClassType(soap, this, tag, type);
}

SOAP_FMAC3 ns3__DeviceClassType * SOAP_FMAC4 soap_get_ns3__DeviceClassType(struct soap *soap, ns3__DeviceClassType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__DeviceClassType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__DeviceClassType * SOAP_FMAC2 soap_instantiate_ns3__DeviceClassType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__DeviceClassType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__DeviceClassType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__DeviceClassType);
		if (size)
			*size = sizeof(ns3__DeviceClassType);
		((ns3__DeviceClassType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__DeviceClassType, n);
		if (size)
			*size = n * sizeof(ns3__DeviceClassType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns3__DeviceClassType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__DeviceClassType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__DeviceClassType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__DeviceClassType %p -> %p\n", q, p));
	*(ns3__DeviceClassType*)p = *(ns3__DeviceClassType*)q;
}

void ns3__ArrayValuesType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns3__ArrayValuesType::ArrayCode);
	soap_default_std__vectorTemplateOfPointerTons3__DeviceClassType(soap, &this->ns3__ArrayValuesType::DeviceClasses);
	/* transient soap skipped */
}

void ns3__ArrayValuesType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns3__ArrayValuesType::ArrayCode, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns3__ArrayValuesType::ArrayCode);
	soap_serialize_std__vectorTemplateOfPointerTons3__DeviceClassType(soap, &this->ns3__ArrayValuesType::DeviceClasses);
	/* transient soap skipped */
#endif
}

int ns3__ArrayValuesType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__ArrayValuesType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__ArrayValuesType(struct soap *soap, const char *tag, int id, const ns3__ArrayValuesType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__ArrayValuesType), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns3:ArrayCode", -1, &(a->ns3__ArrayValuesType::ArrayCode), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons3__DeviceClassType(soap, "ns3:DeviceClasses", -1, &(a->ns3__ArrayValuesType::DeviceClasses), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__ArrayValuesType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__ArrayValuesType(soap, tag, this, type);
}

SOAP_FMAC3 ns3__ArrayValuesType * SOAP_FMAC4 soap_in_ns3__ArrayValuesType(struct soap *soap, const char *tag, ns3__ArrayValuesType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__ArrayValuesType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__ArrayValuesType, sizeof(ns3__ArrayValuesType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__ArrayValuesType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__ArrayValuesType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ArrayCode1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ArrayCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns3:ArrayCode", &(a->ns3__ArrayValuesType::ArrayCode), "xsd:string"))
				{	soap_flag_ArrayCode1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons3__DeviceClassType(soap, "ns3:DeviceClasses", &(a->ns3__ArrayValuesType::DeviceClasses), "ns3:DeviceClassType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__ArrayValuesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__ArrayValuesType, 0, sizeof(ns3__ArrayValuesType), 0, soap_copy_ns3__ArrayValuesType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ArrayCode1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns3__ArrayValuesType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__ArrayValuesType);
	if (this->soap_out(soap, tag?tag:"ns3:ArrayValuesType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__ArrayValuesType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__ArrayValuesType(soap, this, tag, type);
}

SOAP_FMAC3 ns3__ArrayValuesType * SOAP_FMAC4 soap_get_ns3__ArrayValuesType(struct soap *soap, ns3__ArrayValuesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__ArrayValuesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__ArrayValuesType * SOAP_FMAC2 soap_instantiate_ns3__ArrayValuesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__ArrayValuesType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__ArrayValuesType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__ArrayValuesType);
		if (size)
			*size = sizeof(ns3__ArrayValuesType);
		((ns3__ArrayValuesType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__ArrayValuesType, n);
		if (size)
			*size = n * sizeof(ns3__ArrayValuesType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns3__ArrayValuesType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__ArrayValuesType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__ArrayValuesType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__ArrayValuesType %p -> %p\n", q, p));
	*(ns3__ArrayValuesType*)p = *(ns3__ArrayValuesType*)q;
}

void ns2__NameTypeAuthority::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns2__NameTypeAuthority::name);
	this->ns2__NameTypeAuthority::description = NULL;
	/* transient soap skipped */
}

void ns2__NameTypeAuthority::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns2__NameTypeAuthority::name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__NameTypeAuthority::name);
	soap_serialize_PointerTostd__string(soap, &this->ns2__NameTypeAuthority::description);
	/* transient soap skipped */
#endif
}

int ns2__NameTypeAuthority::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__NameTypeAuthority(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__NameTypeAuthority(struct soap *soap, const char *tag, int id, const ns2__NameTypeAuthority *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__NameTypeAuthority), type))
		return soap->error;
	if (soap_out_std__string(soap, "name", -1, &(a->ns2__NameTypeAuthority::name), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "description", -1, &(a->ns2__NameTypeAuthority::description), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__NameTypeAuthority::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__NameTypeAuthority(soap, tag, this, type);
}

SOAP_FMAC3 ns2__NameTypeAuthority * SOAP_FMAC4 soap_in_ns2__NameTypeAuthority(struct soap *soap, const char *tag, ns2__NameTypeAuthority *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__NameTypeAuthority *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__NameTypeAuthority, sizeof(ns2__NameTypeAuthority), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__NameTypeAuthority)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__NameTypeAuthority *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_name1 = 1;
	size_t soap_flag_description1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "name", &(a->ns2__NameTypeAuthority::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "description", &(a->ns2__NameTypeAuthority::description), "xsd:string"))
				{	soap_flag_description1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__NameTypeAuthority *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__NameTypeAuthority, 0, sizeof(ns2__NameTypeAuthority), 0, soap_copy_ns2__NameTypeAuthority);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_name1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__NameTypeAuthority::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__NameTypeAuthority);
	if (this->soap_out(soap, tag?tag:"ns2:NameTypeAuthority", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__NameTypeAuthority::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__NameTypeAuthority(soap, this, tag, type);
}

SOAP_FMAC3 ns2__NameTypeAuthority * SOAP_FMAC4 soap_get_ns2__NameTypeAuthority(struct soap *soap, ns2__NameTypeAuthority *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__NameTypeAuthority(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__NameTypeAuthority * SOAP_FMAC2 soap_instantiate_ns2__NameTypeAuthority(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__NameTypeAuthority(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__NameTypeAuthority, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__NameTypeAuthority);
		if (size)
			*size = sizeof(ns2__NameTypeAuthority);
		((ns2__NameTypeAuthority*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__NameTypeAuthority, n);
		if (size)
			*size = n * sizeof(ns2__NameTypeAuthority);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__NameTypeAuthority*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__NameTypeAuthority*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__NameTypeAuthority(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__NameTypeAuthority %p -> %p\n", q, p));
	*(ns2__NameTypeAuthority*)p = *(ns2__NameTypeAuthority*)q;
}

void ns2__Name::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns2__Name::name);
	this->ns2__Name::NameType = NULL;
	/* transient soap skipped */
}

void ns2__Name::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns2__Name::name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__Name::name);
	soap_serialize_PointerTons2__NameType(soap, &this->ns2__Name::NameType);
	/* transient soap skipped */
#endif
}

int ns2__Name::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__Name(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Name(struct soap *soap, const char *tag, int id, const ns2__Name *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Name), type))
		return soap->error;
	if (soap_out_std__string(soap, "name", -1, &(a->ns2__Name::name), ""))
		return soap->error;
	if (soap_out_PointerTons2__NameType(soap, "NameType", -1, &(a->ns2__Name::NameType), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__Name::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__Name(soap, tag, this, type);
}

SOAP_FMAC3 ns2__Name * SOAP_FMAC4 soap_in_ns2__Name(struct soap *soap, const char *tag, ns2__Name *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__Name *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Name, sizeof(ns2__Name), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__Name)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__Name *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_name1 = 1;
	size_t soap_flag_NameType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "name", &(a->ns2__Name::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_NameType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__NameType(soap, "NameType", &(a->ns2__Name::NameType), "ns2:NameType"))
				{	soap_flag_NameType1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__Name *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Name, 0, sizeof(ns2__Name), 0, soap_copy_ns2__Name);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_name1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__Name::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__Name);
	if (this->soap_out(soap, tag?tag:"ns2:Name", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__Name::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__Name(soap, this, tag, type);
}

SOAP_FMAC3 ns2__Name * SOAP_FMAC4 soap_get_ns2__Name(struct soap *soap, ns2__Name *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Name(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__Name * SOAP_FMAC2 soap_instantiate_ns2__Name(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__Name(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__Name, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__Name);
		if (size)
			*size = sizeof(ns2__Name);
		((ns2__Name*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__Name, n);
		if (size)
			*size = n * sizeof(ns2__Name);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__Name*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__Name*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__Name(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__Name %p -> %p\n", q, p));
	*(ns2__Name*)p = *(ns2__Name*)q;
}

void ns2__NameType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns2__NameType::name);
	this->ns2__NameType::description = NULL;
	this->ns2__NameType::NameTypeAuthority = NULL;
	/* transient soap skipped */
}

void ns2__NameType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns2__NameType::name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__NameType::name);
	soap_serialize_PointerTostd__string(soap, &this->ns2__NameType::description);
	soap_serialize_PointerTons2__NameTypeAuthority(soap, &this->ns2__NameType::NameTypeAuthority);
	/* transient soap skipped */
#endif
}

int ns2__NameType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__NameType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__NameType(struct soap *soap, const char *tag, int id, const ns2__NameType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__NameType), type))
		return soap->error;
	if (soap_out_std__string(soap, "name", -1, &(a->ns2__NameType::name), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "description", -1, &(a->ns2__NameType::description), ""))
		return soap->error;
	if (soap_out_PointerTons2__NameTypeAuthority(soap, "NameTypeAuthority", -1, &(a->ns2__NameType::NameTypeAuthority), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__NameType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__NameType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__NameType * SOAP_FMAC4 soap_in_ns2__NameType(struct soap *soap, const char *tag, ns2__NameType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__NameType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__NameType, sizeof(ns2__NameType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__NameType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__NameType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_name1 = 1;
	size_t soap_flag_description1 = 1;
	size_t soap_flag_NameTypeAuthority1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "name", &(a->ns2__NameType::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "description", &(a->ns2__NameType::description), "xsd:string"))
				{	soap_flag_description1--;
					continue;
				}
			if (soap_flag_NameTypeAuthority1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__NameTypeAuthority(soap, "NameTypeAuthority", &(a->ns2__NameType::NameTypeAuthority), "ns2:NameTypeAuthority"))
				{	soap_flag_NameTypeAuthority1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__NameType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__NameType, 0, sizeof(ns2__NameType), 0, soap_copy_ns2__NameType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_name1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__NameType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__NameType);
	if (this->soap_out(soap, tag?tag:"ns2:NameType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__NameType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__NameType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__NameType * SOAP_FMAC4 soap_get_ns2__NameType(struct soap *soap, ns2__NameType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__NameType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__NameType * SOAP_FMAC2 soap_instantiate_ns2__NameType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__NameType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__NameType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__NameType);
		if (size)
			*size = sizeof(ns2__NameType);
		((ns2__NameType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__NameType, n);
		if (size)
			*size = n * sizeof(ns2__NameType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__NameType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__NameType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__NameType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__NameType %p -> %p\n", q, p));
	*(ns2__NameType*)p = *(ns2__NameType*)q;
}

void ns2__ObjectType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__ObjectType::mRID = NULL;
	soap_default_std__vectorTemplateOfPointerTons2__Name(soap, &this->ns2__ObjectType::Name);
	this->ns2__ObjectType::objectType = NULL;
	/* transient soap skipped */
}

void ns2__ObjectType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__ObjectType::mRID);
	soap_serialize_std__vectorTemplateOfPointerTons2__Name(soap, &this->ns2__ObjectType::Name);
	soap_serialize_PointerTostd__string(soap, &this->ns2__ObjectType::objectType);
	/* transient soap skipped */
#endif
}

int ns2__ObjectType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ObjectType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ObjectType(struct soap *soap, const char *tag, int id, const ns2__ObjectType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ObjectType), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "mRID", -1, &(a->ns2__ObjectType::mRID), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__Name(soap, "Name", -1, &(a->ns2__ObjectType::Name), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "objectType", -1, &(a->ns2__ObjectType::objectType), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__ObjectType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ObjectType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ObjectType * SOAP_FMAC4 soap_in_ns2__ObjectType(struct soap *soap, const char *tag, ns2__ObjectType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ObjectType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ObjectType, sizeof(ns2__ObjectType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ObjectType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ObjectType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_mRID1 = 1;
	size_t soap_flag_objectType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_mRID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "mRID", &(a->ns2__ObjectType::mRID), "xsd:string"))
				{	soap_flag_mRID1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__Name(soap, "Name", &(a->ns2__ObjectType::Name), "ns2:Name"))
					continue;
			if (soap_flag_objectType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "objectType", &(a->ns2__ObjectType::objectType), "xsd:string"))
				{	soap_flag_objectType1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ObjectType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ObjectType, 0, sizeof(ns2__ObjectType), 0, soap_copy_ns2__ObjectType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__ObjectType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ObjectType);
	if (this->soap_out(soap, tag?tag:"ns2:ObjectType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ObjectType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ObjectType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ObjectType * SOAP_FMAC4 soap_get_ns2__ObjectType(struct soap *soap, ns2__ObjectType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ObjectType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ObjectType * SOAP_FMAC2 soap_instantiate_ns2__ObjectType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ObjectType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ObjectType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ObjectType);
		if (size)
			*size = sizeof(ns2__ObjectType);
		((ns2__ObjectType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__ObjectType, n);
		if (size)
			*size = n * sizeof(ns2__ObjectType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__ObjectType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__ObjectType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ObjectType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ObjectType %p -> %p\n", q, p));
	*(ns2__ObjectType*)p = *(ns2__ObjectType*)q;
}

void ns2__LocationType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__LocationType::node = NULL;
	this->ns2__LocationType::pipeline = NULL;
	this->ns2__LocationType::stage = NULL;
	/* transient soap skipped */
}

void ns2__LocationType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__LocationType::node);
	soap_serialize_PointerTostd__string(soap, &this->ns2__LocationType::pipeline);
	soap_serialize_PointerTostd__string(soap, &this->ns2__LocationType::stage);
	/* transient soap skipped */
#endif
}

int ns2__LocationType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__LocationType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__LocationType(struct soap *soap, const char *tag, int id, const ns2__LocationType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__LocationType), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "node", -1, &(a->ns2__LocationType::node), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "pipeline", -1, &(a->ns2__LocationType::pipeline), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "stage", -1, &(a->ns2__LocationType::stage), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__LocationType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__LocationType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__LocationType * SOAP_FMAC4 soap_in_ns2__LocationType(struct soap *soap, const char *tag, ns2__LocationType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__LocationType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__LocationType, sizeof(ns2__LocationType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__LocationType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__LocationType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_node1 = 1;
	size_t soap_flag_pipeline1 = 1;
	size_t soap_flag_stage1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_node1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "node", &(a->ns2__LocationType::node), "xsd:string"))
				{	soap_flag_node1--;
					continue;
				}
			if (soap_flag_pipeline1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "pipeline", &(a->ns2__LocationType::pipeline), "xsd:string"))
				{	soap_flag_pipeline1--;
					continue;
				}
			if (soap_flag_stage1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "stage", &(a->ns2__LocationType::stage), "xsd:string"))
				{	soap_flag_stage1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__LocationType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__LocationType, 0, sizeof(ns2__LocationType), 0, soap_copy_ns2__LocationType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__LocationType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__LocationType);
	if (this->soap_out(soap, tag?tag:"ns2:LocationType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__LocationType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__LocationType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__LocationType * SOAP_FMAC4 soap_get_ns2__LocationType(struct soap *soap, ns2__LocationType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__LocationType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__LocationType * SOAP_FMAC2 soap_instantiate_ns2__LocationType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__LocationType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__LocationType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__LocationType);
		if (size)
			*size = sizeof(ns2__LocationType);
		((ns2__LocationType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__LocationType, n);
		if (size)
			*size = n * sizeof(ns2__LocationType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__LocationType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__LocationType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__LocationType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__LocationType %p -> %p\n", q, p));
	*(ns2__LocationType*)p = *(ns2__LocationType*)q;
}

void ns2__OptionType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns2__OptionType::name);
	this->ns2__OptionType::value = NULL;
	/* transient soap skipped */
}

void ns2__OptionType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns2__OptionType::name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__OptionType::name);
	soap_serialize_PointerTostd__string(soap, &this->ns2__OptionType::value);
	/* transient soap skipped */
#endif
}

int ns2__OptionType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__OptionType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__OptionType(struct soap *soap, const char *tag, int id, const ns2__OptionType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__OptionType), type))
		return soap->error;
	if (soap_out_std__string(soap, "name", -1, &(a->ns2__OptionType::name), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "value", -1, &(a->ns2__OptionType::value), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__OptionType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__OptionType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__OptionType * SOAP_FMAC4 soap_in_ns2__OptionType(struct soap *soap, const char *tag, ns2__OptionType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__OptionType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__OptionType, sizeof(ns2__OptionType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__OptionType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__OptionType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_name1 = 1;
	size_t soap_flag_value1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "name", &(a->ns2__OptionType::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_value1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "value", &(a->ns2__OptionType::value), "xsd:string"))
				{	soap_flag_value1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__OptionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__OptionType, 0, sizeof(ns2__OptionType), 0, soap_copy_ns2__OptionType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_name1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__OptionType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__OptionType);
	if (this->soap_out(soap, tag?tag:"ns2:OptionType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__OptionType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__OptionType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__OptionType * SOAP_FMAC4 soap_get_ns2__OptionType(struct soap *soap, ns2__OptionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__OptionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__OptionType * SOAP_FMAC2 soap_instantiate_ns2__OptionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__OptionType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__OptionType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__OptionType);
		if (size)
			*size = sizeof(ns2__OptionType);
		((ns2__OptionType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__OptionType, n);
		if (size)
			*size = n * sizeof(ns2__OptionType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__OptionType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__OptionType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__OptionType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__OptionType %p -> %p\n", q, p));
	*(ns2__OptionType*)p = *(ns2__OptionType*)q;
}

void ns2__ErrorType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns2__ErrorType::code);
	this->ns2__ErrorType::level = NULL;
	this->ns2__ErrorType::reason = NULL;
	this->ns2__ErrorType::details = NULL;
	this->ns2__ErrorType::xpath = NULL;
	this->ns2__ErrorType::stackTrace = NULL;
	this->ns2__ErrorType::Location = NULL;
	this->ns2__ErrorType::ID = NULL;
	this->ns2__ErrorType::relatedID = NULL;
	this->ns2__ErrorType::object = NULL;
	this->ns2__ErrorType::operationId = NULL;
	/* transient soap skipped */
}

void ns2__ErrorType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns2__ErrorType::code, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__ErrorType::code);
	soap_serialize_PointerTo_ns2__ErrorType_level(soap, &this->ns2__ErrorType::level);
	soap_serialize_PointerTostd__string(soap, &this->ns2__ErrorType::reason);
	soap_serialize_PointerTostd__string(soap, &this->ns2__ErrorType::details);
	soap_serialize_PointerToxsd__QName(soap, &this->ns2__ErrorType::xpath);
	soap_serialize_PointerTostd__string(soap, &this->ns2__ErrorType::stackTrace);
	soap_serialize_PointerTons2__LocationType(soap, &this->ns2__ErrorType::Location);
	soap_serialize_PointerTo_ns2__ErrorType_ID(soap, &this->ns2__ErrorType::ID);
	soap_serialize_PointerTo_ns2__ErrorType_relatedID(soap, &this->ns2__ErrorType::relatedID);
	soap_serialize_PointerTons2__ObjectType(soap, &this->ns2__ErrorType::object);
	soap_serialize_PointerToxsd__integer(soap, &this->ns2__ErrorType::operationId);
	/* transient soap skipped */
#endif
}

int ns2__ErrorType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ErrorType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ErrorType(struct soap *soap, const char *tag, int id, const ns2__ErrorType *a, const char *type)
{
	std::string soap_temp_xpath(a->xpath ? soap_QName2s(soap, a->xpath->c_str()) : ""), *soap_tmp_xpath = a->xpath ? &soap_temp_xpath : NULL;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ErrorType), type))
		return soap->error;
	if (soap_out_std__string(soap, "code", -1, &(a->ns2__ErrorType::code), ""))
		return soap->error;
	if (soap_out_PointerTo_ns2__ErrorType_level(soap, "level", -1, &(a->ns2__ErrorType::level), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "reason", -1, &(a->ns2__ErrorType::reason), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "details", -1, &(a->ns2__ErrorType::details), ""))
		return soap->error;
	if (soap_out_PointerToxsd__QName(soap, "xpath", -1, &soap_tmp_xpath, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "stackTrace", -1, &(a->ns2__ErrorType::stackTrace), ""))
		return soap->error;
	if (soap_out_PointerTons2__LocationType(soap, "Location", -1, &(a->ns2__ErrorType::Location), ""))
		return soap->error;
	if (soap_out_PointerTo_ns2__ErrorType_ID(soap, "ID", -1, &(a->ns2__ErrorType::ID), ""))
		return soap->error;
	if (soap_out_PointerTo_ns2__ErrorType_relatedID(soap, "relatedID", -1, &(a->ns2__ErrorType::relatedID), ""))
		return soap->error;
	if (soap_out_PointerTons2__ObjectType(soap, "object", -1, &(a->ns2__ErrorType::object), ""))
		return soap->error;
	if (soap_out_PointerToxsd__integer(soap, "operationId", -1, &(a->ns2__ErrorType::operationId), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__ErrorType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ErrorType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ErrorType * SOAP_FMAC4 soap_in_ns2__ErrorType(struct soap *soap, const char *tag, ns2__ErrorType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ErrorType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ErrorType, sizeof(ns2__ErrorType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ErrorType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ErrorType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_code1 = 1;
	size_t soap_flag_level1 = 1;
	size_t soap_flag_reason1 = 1;
	size_t soap_flag_details1 = 1;
	size_t soap_flag_xpath1 = 1;
	size_t soap_flag_stackTrace1 = 1;
	size_t soap_flag_Location1 = 1;
	size_t soap_flag_ID1 = 1;
	size_t soap_flag_relatedID1 = 1;
	size_t soap_flag_object1 = 1;
	size_t soap_flag_operationId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_code1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "code", &(a->ns2__ErrorType::code), "xsd:string"))
				{	soap_flag_code1--;
					continue;
				}
			if (soap_flag_level1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns2__ErrorType_level(soap, "level", &(a->ns2__ErrorType::level), "ns2:ErrorType-level"))
				{	soap_flag_level1--;
					continue;
				}
			if (soap_flag_reason1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "reason", &(a->ns2__ErrorType::reason), "xsd:string"))
				{	soap_flag_reason1--;
					continue;
				}
			if (soap_flag_details1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "details", &(a->ns2__ErrorType::details), "xsd:string"))
				{	soap_flag_details1--;
					continue;
				}
			if (soap_flag_xpath1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__QName(soap, "xpath", &(a->ns2__ErrorType::xpath), "xsd:QName"))
				{	soap_flag_xpath1--;
					continue;
				}
			if (soap_flag_stackTrace1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "stackTrace", &(a->ns2__ErrorType::stackTrace), "xsd:string"))
				{	soap_flag_stackTrace1--;
					continue;
				}
			if (soap_flag_Location1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__LocationType(soap, "Location", &(a->ns2__ErrorType::Location), "ns2:LocationType"))
				{	soap_flag_Location1--;
					continue;
				}
			if (soap_flag_ID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns2__ErrorType_ID(soap, "ID", &(a->ns2__ErrorType::ID), ""))
				{	soap_flag_ID1--;
					continue;
				}
			if (soap_flag_relatedID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns2__ErrorType_relatedID(soap, "relatedID", &(a->ns2__ErrorType::relatedID), ""))
				{	soap_flag_relatedID1--;
					continue;
				}
			if (soap_flag_object1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ObjectType(soap, "object", &(a->ns2__ErrorType::object), "ns2:ObjectType"))
				{	soap_flag_object1--;
					continue;
				}
			if (soap_flag_operationId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__integer(soap, "operationId", &(a->ns2__ErrorType::operationId), "xsd:integer"))
				{	soap_flag_operationId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ErrorType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ErrorType, 0, sizeof(ns2__ErrorType), 0, soap_copy_ns2__ErrorType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_code1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__ErrorType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ErrorType);
	if (this->soap_out(soap, tag?tag:"ns2:ErrorType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ErrorType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ErrorType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ErrorType * SOAP_FMAC4 soap_get_ns2__ErrorType(struct soap *soap, ns2__ErrorType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ErrorType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ErrorType * SOAP_FMAC2 soap_instantiate_ns2__ErrorType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ErrorType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ErrorType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ErrorType);
		if (size)
			*size = sizeof(ns2__ErrorType);
		((ns2__ErrorType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__ErrorType, n);
		if (size)
			*size = n * sizeof(ns2__ErrorType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__ErrorType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__ErrorType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ErrorType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ErrorType %p -> %p\n", q, p));
	*(ns2__ErrorType*)p = *(ns2__ErrorType*)q;
}

void ns2__EventMessageType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__EventMessageType::Header = NULL;
	this->ns2__EventMessageType::Payload = NULL;
	/* transient soap skipped */
}

void ns2__EventMessageType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__HeaderType(soap, &this->ns2__EventMessageType::Header);
	soap_serialize_PointerTons2__PayloadType(soap, &this->ns2__EventMessageType::Payload);
	/* transient soap skipped */
#endif
}

int ns2__EventMessageType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__EventMessageType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__EventMessageType(struct soap *soap, const char *tag, int id, const ns2__EventMessageType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__EventMessageType), type))
		return soap->error;
	if (a->ns2__EventMessageType::Header)
	{	if (soap_out_PointerTons2__HeaderType(soap, "Header", -1, &a->ns2__EventMessageType::Header, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "Header"))
		return soap->error;
	if (soap_out_PointerTons2__PayloadType(soap, "Payload", -1, &(a->ns2__EventMessageType::Payload), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__EventMessageType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__EventMessageType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__EventMessageType * SOAP_FMAC4 soap_in_ns2__EventMessageType(struct soap *soap, const char *tag, ns2__EventMessageType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__EventMessageType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__EventMessageType, sizeof(ns2__EventMessageType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__EventMessageType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__EventMessageType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Header1 = 1;
	size_t soap_flag_Payload1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Header1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__HeaderType(soap, "Header", &(a->ns2__EventMessageType::Header), "ns2:HeaderType"))
				{	soap_flag_Header1--;
					continue;
				}
			if (soap_flag_Payload1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PayloadType(soap, "Payload", &(a->ns2__EventMessageType::Payload), "ns2:PayloadType"))
				{	soap_flag_Payload1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__EventMessageType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__EventMessageType, 0, sizeof(ns2__EventMessageType), 0, soap_copy_ns2__EventMessageType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Header1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__EventMessageType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__EventMessageType);
	if (this->soap_out(soap, tag?tag:"ns2:EventMessageType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__EventMessageType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__EventMessageType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__EventMessageType * SOAP_FMAC4 soap_get_ns2__EventMessageType(struct soap *soap, ns2__EventMessageType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__EventMessageType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__EventMessageType * SOAP_FMAC2 soap_instantiate_ns2__EventMessageType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__EventMessageType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__EventMessageType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__EventMessageType);
		if (size)
			*size = sizeof(ns2__EventMessageType);
		((ns2__EventMessageType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__EventMessageType, n);
		if (size)
			*size = n * sizeof(ns2__EventMessageType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__EventMessageType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__EventMessageType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__EventMessageType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__EventMessageType %p -> %p\n", q, p));
	*(ns2__EventMessageType*)p = *(ns2__EventMessageType*)q;
}

void ns2__FaultMessageType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__FaultMessageType::Reply = NULL;
	/* transient soap skipped */
}

void ns2__FaultMessageType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__ReplyType(soap, &this->ns2__FaultMessageType::Reply);
	/* transient soap skipped */
#endif
}

int ns2__FaultMessageType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__FaultMessageType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__FaultMessageType(struct soap *soap, const char *tag, int id, const ns2__FaultMessageType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__FaultMessageType), type))
		return soap->error;
	if (a->ns2__FaultMessageType::Reply)
	{	if (soap_out_PointerTons2__ReplyType(soap, "Reply", -1, &a->ns2__FaultMessageType::Reply, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "Reply"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__FaultMessageType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__FaultMessageType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__FaultMessageType * SOAP_FMAC4 soap_in_ns2__FaultMessageType(struct soap *soap, const char *tag, ns2__FaultMessageType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__FaultMessageType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__FaultMessageType, sizeof(ns2__FaultMessageType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__FaultMessageType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__FaultMessageType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Reply1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Reply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ReplyType(soap, "Reply", &(a->ns2__FaultMessageType::Reply), "ns2:ReplyType"))
				{	soap_flag_Reply1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__FaultMessageType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__FaultMessageType, 0, sizeof(ns2__FaultMessageType), 0, soap_copy_ns2__FaultMessageType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Reply1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__FaultMessageType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__FaultMessageType);
	if (this->soap_out(soap, tag?tag:"ns2:FaultMessageType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__FaultMessageType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__FaultMessageType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__FaultMessageType * SOAP_FMAC4 soap_get_ns2__FaultMessageType(struct soap *soap, ns2__FaultMessageType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__FaultMessageType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__FaultMessageType * SOAP_FMAC2 soap_instantiate_ns2__FaultMessageType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__FaultMessageType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__FaultMessageType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__FaultMessageType);
		if (size)
			*size = sizeof(ns2__FaultMessageType);
		((ns2__FaultMessageType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__FaultMessageType, n);
		if (size)
			*size = n * sizeof(ns2__FaultMessageType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__FaultMessageType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__FaultMessageType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__FaultMessageType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__FaultMessageType %p -> %p\n", q, p));
	*(ns2__FaultMessageType*)p = *(ns2__FaultMessageType*)q;
}

void ns2__ResponseMessageType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__ResponseMessageType::Header = NULL;
	this->ns2__ResponseMessageType::Reply = NULL;
	this->ns2__ResponseMessageType::Payload = NULL;
	/* transient soap skipped */
}

void ns2__ResponseMessageType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__HeaderType(soap, &this->ns2__ResponseMessageType::Header);
	soap_serialize_PointerTons2__ReplyType(soap, &this->ns2__ResponseMessageType::Reply);
	soap_serialize_PointerTons2__PayloadType(soap, &this->ns2__ResponseMessageType::Payload);
	/* transient soap skipped */
#endif
}

int ns2__ResponseMessageType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ResponseMessageType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ResponseMessageType(struct soap *soap, const char *tag, int id, const ns2__ResponseMessageType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ResponseMessageType), type))
		return soap->error;
	if (a->ns2__ResponseMessageType::Header)
	{	if (soap_out_PointerTons2__HeaderType(soap, "Header", -1, &a->ns2__ResponseMessageType::Header, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "Header"))
		return soap->error;
	if (a->ns2__ResponseMessageType::Reply)
	{	if (soap_out_PointerTons2__ReplyType(soap, "Reply", -1, &a->ns2__ResponseMessageType::Reply, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "Reply"))
		return soap->error;
	if (soap_out_PointerTons2__PayloadType(soap, "Payload", -1, &(a->ns2__ResponseMessageType::Payload), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__ResponseMessageType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ResponseMessageType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ResponseMessageType * SOAP_FMAC4 soap_in_ns2__ResponseMessageType(struct soap *soap, const char *tag, ns2__ResponseMessageType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ResponseMessageType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ResponseMessageType, sizeof(ns2__ResponseMessageType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ResponseMessageType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ResponseMessageType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Header1 = 1;
	size_t soap_flag_Reply1 = 1;
	size_t soap_flag_Payload1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Header1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__HeaderType(soap, "Header", &(a->ns2__ResponseMessageType::Header), "ns2:HeaderType"))
				{	soap_flag_Header1--;
					continue;
				}
			if (soap_flag_Reply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ReplyType(soap, "Reply", &(a->ns2__ResponseMessageType::Reply), "ns2:ReplyType"))
				{	soap_flag_Reply1--;
					continue;
				}
			if (soap_flag_Payload1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PayloadType(soap, "Payload", &(a->ns2__ResponseMessageType::Payload), "ns2:PayloadType"))
				{	soap_flag_Payload1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ResponseMessageType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ResponseMessageType, 0, sizeof(ns2__ResponseMessageType), 0, soap_copy_ns2__ResponseMessageType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Header1 > 0 || soap_flag_Reply1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__ResponseMessageType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ResponseMessageType);
	if (this->soap_out(soap, tag?tag:"ns2:ResponseMessageType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ResponseMessageType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ResponseMessageType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ResponseMessageType * SOAP_FMAC4 soap_get_ns2__ResponseMessageType(struct soap *soap, ns2__ResponseMessageType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ResponseMessageType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ResponseMessageType * SOAP_FMAC2 soap_instantiate_ns2__ResponseMessageType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ResponseMessageType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ResponseMessageType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ResponseMessageType);
		if (size)
			*size = sizeof(ns2__ResponseMessageType);
		((ns2__ResponseMessageType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__ResponseMessageType, n);
		if (size)
			*size = n * sizeof(ns2__ResponseMessageType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__ResponseMessageType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__ResponseMessageType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ResponseMessageType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ResponseMessageType %p -> %p\n", q, p));
	*(ns2__ResponseMessageType*)p = *(ns2__ResponseMessageType*)q;
}

void ns2__RequestMessageType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__RequestMessageType::Header = NULL;
	this->ns2__RequestMessageType::Request = NULL;
	this->ns2__RequestMessageType::Payload = NULL;
	/* transient soap skipped */
}

void ns2__RequestMessageType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__HeaderType(soap, &this->ns2__RequestMessageType::Header);
	soap_serialize_PointerTons2__RequestType(soap, &this->ns2__RequestMessageType::Request);
	soap_serialize_PointerTons2__PayloadType(soap, &this->ns2__RequestMessageType::Payload);
	/* transient soap skipped */
#endif
}

int ns2__RequestMessageType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__RequestMessageType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__RequestMessageType(struct soap *soap, const char *tag, int id, const ns2__RequestMessageType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__RequestMessageType), type))
		return soap->error;
	if (a->ns2__RequestMessageType::Header)
	{	if (soap_out_PointerTons2__HeaderType(soap, "Header", -1, &a->ns2__RequestMessageType::Header, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "Header"))
		return soap->error;
	if (soap_out_PointerTons2__RequestType(soap, "Request", -1, &(a->ns2__RequestMessageType::Request), ""))
		return soap->error;
	if (soap_out_PointerTons2__PayloadType(soap, "Payload", -1, &(a->ns2__RequestMessageType::Payload), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__RequestMessageType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__RequestMessageType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__RequestMessageType * SOAP_FMAC4 soap_in_ns2__RequestMessageType(struct soap *soap, const char *tag, ns2__RequestMessageType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__RequestMessageType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__RequestMessageType, sizeof(ns2__RequestMessageType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__RequestMessageType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__RequestMessageType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Header1 = 1;
	size_t soap_flag_Request1 = 1;
	size_t soap_flag_Payload1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Header1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__HeaderType(soap, "Header", &(a->ns2__RequestMessageType::Header), "ns2:HeaderType"))
				{	soap_flag_Header1--;
					continue;
				}
			if (soap_flag_Request1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__RequestType(soap, "Request", &(a->ns2__RequestMessageType::Request), "ns2:RequestType"))
				{	soap_flag_Request1--;
					continue;
				}
			if (soap_flag_Payload1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PayloadType(soap, "Payload", &(a->ns2__RequestMessageType::Payload), "ns2:PayloadType"))
				{	soap_flag_Payload1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__RequestMessageType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__RequestMessageType, 0, sizeof(ns2__RequestMessageType), 0, soap_copy_ns2__RequestMessageType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Header1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__RequestMessageType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__RequestMessageType);
	if (this->soap_out(soap, tag?tag:"ns2:RequestMessageType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__RequestMessageType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__RequestMessageType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__RequestMessageType * SOAP_FMAC4 soap_get_ns2__RequestMessageType(struct soap *soap, ns2__RequestMessageType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__RequestMessageType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__RequestMessageType * SOAP_FMAC2 soap_instantiate_ns2__RequestMessageType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__RequestMessageType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__RequestMessageType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__RequestMessageType);
		if (size)
			*size = sizeof(ns2__RequestMessageType);
		((ns2__RequestMessageType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__RequestMessageType, n);
		if (size)
			*size = n * sizeof(ns2__RequestMessageType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__RequestMessageType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__RequestMessageType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__RequestMessageType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__RequestMessageType %p -> %p\n", q, p));
	*(ns2__RequestMessageType*)p = *(ns2__RequestMessageType*)q;
}

void ns2__MessageType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__MessageType::Header = NULL;
	this->ns2__MessageType::Request = NULL;
	this->ns2__MessageType::Reply = NULL;
	this->ns2__MessageType::Payload = NULL;
	/* transient soap skipped */
}

void ns2__MessageType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__HeaderType(soap, &this->ns2__MessageType::Header);
	soap_serialize_PointerTons2__RequestType(soap, &this->ns2__MessageType::Request);
	soap_serialize_PointerTons2__ReplyType(soap, &this->ns2__MessageType::Reply);
	soap_serialize_PointerTons2__PayloadType(soap, &this->ns2__MessageType::Payload);
	/* transient soap skipped */
#endif
}

int ns2__MessageType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__MessageType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__MessageType(struct soap *soap, const char *tag, int id, const ns2__MessageType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__MessageType), type))
		return soap->error;
	if (a->ns2__MessageType::Header)
	{	if (soap_out_PointerTons2__HeaderType(soap, "Header", -1, &a->ns2__MessageType::Header, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "Header"))
		return soap->error;
	if (soap_out_PointerTons2__RequestType(soap, "Request", -1, &(a->ns2__MessageType::Request), ""))
		return soap->error;
	if (soap_out_PointerTons2__ReplyType(soap, "Reply", -1, &(a->ns2__MessageType::Reply), ""))
		return soap->error;
	if (soap_out_PointerTons2__PayloadType(soap, "Payload", -1, &(a->ns2__MessageType::Payload), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__MessageType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__MessageType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__MessageType * SOAP_FMAC4 soap_in_ns2__MessageType(struct soap *soap, const char *tag, ns2__MessageType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__MessageType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__MessageType, sizeof(ns2__MessageType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__MessageType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__MessageType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Header1 = 1;
	size_t soap_flag_Request1 = 1;
	size_t soap_flag_Reply1 = 1;
	size_t soap_flag_Payload1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Header1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__HeaderType(soap, "Header", &(a->ns2__MessageType::Header), "ns2:HeaderType"))
				{	soap_flag_Header1--;
					continue;
				}
			if (soap_flag_Request1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__RequestType(soap, "Request", &(a->ns2__MessageType::Request), "ns2:RequestType"))
				{	soap_flag_Request1--;
					continue;
				}
			if (soap_flag_Reply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ReplyType(soap, "Reply", &(a->ns2__MessageType::Reply), "ns2:ReplyType"))
				{	soap_flag_Reply1--;
					continue;
				}
			if (soap_flag_Payload1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PayloadType(soap, "Payload", &(a->ns2__MessageType::Payload), "ns2:PayloadType"))
				{	soap_flag_Payload1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__MessageType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__MessageType, 0, sizeof(ns2__MessageType), 0, soap_copy_ns2__MessageType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Header1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__MessageType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__MessageType);
	if (this->soap_out(soap, tag?tag:"ns2:MessageType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__MessageType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__MessageType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__MessageType * SOAP_FMAC4 soap_get_ns2__MessageType(struct soap *soap, ns2__MessageType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__MessageType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__MessageType * SOAP_FMAC2 soap_instantiate_ns2__MessageType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__MessageType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__MessageType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__MessageType);
		if (size)
			*size = sizeof(ns2__MessageType);
		((ns2__MessageType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__MessageType, n);
		if (size)
			*size = n * sizeof(ns2__MessageType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__MessageType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__MessageType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__MessageType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__MessageType %p -> %p\n", q, p));
	*(ns2__MessageType*)p = *(ns2__MessageType*)q;
}

void ns2__MessageProperty::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns2__MessageProperty::Name);
	this->ns2__MessageProperty::Value = NULL;
	/* transient soap skipped */
}

void ns2__MessageProperty::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns2__MessageProperty::Name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__MessageProperty::Name);
	soap_serialize_PointerTostd__string(soap, &this->ns2__MessageProperty::Value);
	/* transient soap skipped */
#endif
}

int ns2__MessageProperty::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__MessageProperty(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__MessageProperty(struct soap *soap, const char *tag, int id, const ns2__MessageProperty *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__MessageProperty), type))
		return soap->error;
	if (soap_out_std__string(soap, "Name", -1, &(a->ns2__MessageProperty::Name), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Value", -1, &(a->ns2__MessageProperty::Value), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__MessageProperty::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__MessageProperty(soap, tag, this, type);
}

SOAP_FMAC3 ns2__MessageProperty * SOAP_FMAC4 soap_in_ns2__MessageProperty(struct soap *soap, const char *tag, ns2__MessageProperty *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__MessageProperty *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__MessageProperty, sizeof(ns2__MessageProperty), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__MessageProperty)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__MessageProperty *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_Value1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "Name", &(a->ns2__MessageProperty::Name), "xsd:string"))
				{	soap_flag_Name1--;
					continue;
				}
			if (soap_flag_Value1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Value", &(a->ns2__MessageProperty::Value), "xsd:string"))
				{	soap_flag_Value1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__MessageProperty *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__MessageProperty, 0, sizeof(ns2__MessageProperty), 0, soap_copy_ns2__MessageProperty);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__MessageProperty::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__MessageProperty);
	if (this->soap_out(soap, tag?tag:"ns2:MessageProperty", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__MessageProperty::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__MessageProperty(soap, this, tag, type);
}

SOAP_FMAC3 ns2__MessageProperty * SOAP_FMAC4 soap_get_ns2__MessageProperty(struct soap *soap, ns2__MessageProperty *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__MessageProperty(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__MessageProperty * SOAP_FMAC2 soap_instantiate_ns2__MessageProperty(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__MessageProperty(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__MessageProperty, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__MessageProperty);
		if (size)
			*size = sizeof(ns2__MessageProperty);
		((ns2__MessageProperty*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__MessageProperty, n);
		if (size)
			*size = n * sizeof(ns2__MessageProperty);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__MessageProperty*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__MessageProperty*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__MessageProperty(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__MessageProperty %p -> %p\n", q, p));
	*(ns2__MessageProperty*)p = *(ns2__MessageProperty*)q;
}

void ns2__HeaderType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default__ns2__HeaderType_Verb(soap, &this->ns2__HeaderType::Verb);
	soap_default_std__string(soap, &this->ns2__HeaderType::Noun);
	this->ns2__HeaderType::Revision = NULL;
	this->ns2__HeaderType::ReplayDetection = NULL;
	this->ns2__HeaderType::Context = NULL;
	this->ns2__HeaderType::Timestamp = NULL;
	this->ns2__HeaderType::Source = NULL;
	this->ns2__HeaderType::AsyncReplyFlag = NULL;
	this->ns2__HeaderType::ReplyAddress = NULL;
	this->ns2__HeaderType::AckRequired = NULL;
	this->ns2__HeaderType::User = NULL;
	this->ns2__HeaderType::MessageID = NULL;
	this->ns2__HeaderType::CorrelationID = NULL;
	this->ns2__HeaderType::Comment = NULL;
	soap_default_std__vectorTemplateOfPointerTons2__MessageProperty(soap, &this->ns2__HeaderType::Property);
	soap_default_std__vectorTemplateOf_XML(soap, &this->ns2__HeaderType::__any);
	/* transient soap skipped */
}

void ns2__HeaderType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns2__HeaderType::Noun, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__HeaderType::Noun);
	soap_serialize_PointerTostd__string(soap, &this->ns2__HeaderType::Revision);
	soap_serialize_PointerTons2__ReplayDetectionType(soap, &this->ns2__HeaderType::ReplayDetection);
	soap_serialize_PointerTostd__string(soap, &this->ns2__HeaderType::Context);
	soap_serialize_PointerTotime(soap, &this->ns2__HeaderType::Timestamp);
	soap_serialize_PointerTostd__string(soap, &this->ns2__HeaderType::Source);
	soap_serialize_PointerTobool(soap, &this->ns2__HeaderType::AsyncReplyFlag);
	soap_serialize_PointerTostd__string(soap, &this->ns2__HeaderType::ReplyAddress);
	soap_serialize_PointerTobool(soap, &this->ns2__HeaderType::AckRequired);
	soap_serialize_PointerTons2__UserType(soap, &this->ns2__HeaderType::User);
	soap_serialize_PointerTostd__string(soap, &this->ns2__HeaderType::MessageID);
	soap_serialize_PointerTostd__string(soap, &this->ns2__HeaderType::CorrelationID);
	soap_serialize_PointerTostd__string(soap, &this->ns2__HeaderType::Comment);
	soap_serialize_std__vectorTemplateOfPointerTons2__MessageProperty(soap, &this->ns2__HeaderType::Property);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->ns2__HeaderType::__any);
	/* transient soap skipped */
#endif
}

int ns2__HeaderType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__HeaderType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__HeaderType(struct soap *soap, const char *tag, int id, const ns2__HeaderType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__HeaderType), type))
		return soap->error;
	if (soap_out__ns2__HeaderType_Verb(soap, "Verb", -1, &(a->ns2__HeaderType::Verb), ""))
		return soap->error;
	if (soap_out_std__string(soap, "Noun", -1, &(a->ns2__HeaderType::Noun), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Revision", -1, &(a->ns2__HeaderType::Revision), ""))
		return soap->error;
	if (soap_out_PointerTons2__ReplayDetectionType(soap, "ReplayDetection", -1, &(a->ns2__HeaderType::ReplayDetection), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Context", -1, &(a->ns2__HeaderType::Context), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "Timestamp", -1, &(a->ns2__HeaderType::Timestamp), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Source", -1, &(a->ns2__HeaderType::Source), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "AsyncReplyFlag", -1, &(a->ns2__HeaderType::AsyncReplyFlag), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ReplyAddress", -1, &(a->ns2__HeaderType::ReplyAddress), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "AckRequired", -1, &(a->ns2__HeaderType::AckRequired), ""))
		return soap->error;
	if (soap_out_PointerTons2__UserType(soap, "User", -1, &(a->ns2__HeaderType::User), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "MessageID", -1, &(a->ns2__HeaderType::MessageID), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "CorrelationID", -1, &(a->ns2__HeaderType::CorrelationID), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Comment", -1, &(a->ns2__HeaderType::Comment), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__MessageProperty(soap, "Property", -1, &(a->ns2__HeaderType::Property), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->ns2__HeaderType::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__HeaderType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__HeaderType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__HeaderType * SOAP_FMAC4 soap_in_ns2__HeaderType(struct soap *soap, const char *tag, ns2__HeaderType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__HeaderType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__HeaderType, sizeof(ns2__HeaderType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__HeaderType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__HeaderType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Verb1 = 1;
	size_t soap_flag_Noun1 = 1;
	size_t soap_flag_Revision1 = 1;
	size_t soap_flag_ReplayDetection1 = 1;
	size_t soap_flag_Context1 = 1;
	size_t soap_flag_Timestamp1 = 1;
	size_t soap_flag_Source1 = 1;
	size_t soap_flag_AsyncReplyFlag1 = 1;
	size_t soap_flag_ReplyAddress1 = 1;
	size_t soap_flag_AckRequired1 = 1;
	size_t soap_flag_User1 = 1;
	size_t soap_flag_MessageID1 = 1;
	size_t soap_flag_CorrelationID1 = 1;
	size_t soap_flag_Comment1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Verb1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns2__HeaderType_Verb(soap, "Verb", &(a->ns2__HeaderType::Verb), "ns2:HeaderType-Verb"))
				{	soap_flag_Verb1--;
					continue;
				}
			if (soap_flag_Noun1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "Noun", &(a->ns2__HeaderType::Noun), "xsd:string"))
				{	soap_flag_Noun1--;
					continue;
				}
			if (soap_flag_Revision1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Revision", &(a->ns2__HeaderType::Revision), "xsd:string"))
				{	soap_flag_Revision1--;
					continue;
				}
			if (soap_flag_ReplayDetection1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ReplayDetectionType(soap, "ReplayDetection", &(a->ns2__HeaderType::ReplayDetection), "ns2:ReplayDetectionType"))
				{	soap_flag_ReplayDetection1--;
					continue;
				}
			if (soap_flag_Context1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Context", &(a->ns2__HeaderType::Context), "xsd:string"))
				{	soap_flag_Context1--;
					continue;
				}
			if (soap_flag_Timestamp1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "Timestamp", &(a->ns2__HeaderType::Timestamp), "xsd:dateTime"))
				{	soap_flag_Timestamp1--;
					continue;
				}
			if (soap_flag_Source1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Source", &(a->ns2__HeaderType::Source), "xsd:string"))
				{	soap_flag_Source1--;
					continue;
				}
			if (soap_flag_AsyncReplyFlag1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "AsyncReplyFlag", &(a->ns2__HeaderType::AsyncReplyFlag), "xsd:boolean"))
				{	soap_flag_AsyncReplyFlag1--;
					continue;
				}
			if (soap_flag_ReplyAddress1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ReplyAddress", &(a->ns2__HeaderType::ReplyAddress), "xsd:string"))
				{	soap_flag_ReplyAddress1--;
					continue;
				}
			if (soap_flag_AckRequired1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "AckRequired", &(a->ns2__HeaderType::AckRequired), "xsd:boolean"))
				{	soap_flag_AckRequired1--;
					continue;
				}
			if (soap_flag_User1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__UserType(soap, "User", &(a->ns2__HeaderType::User), "ns2:UserType"))
				{	soap_flag_User1--;
					continue;
				}
			if (soap_flag_MessageID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "MessageID", &(a->ns2__HeaderType::MessageID), "xsd:string"))
				{	soap_flag_MessageID1--;
					continue;
				}
			if (soap_flag_CorrelationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "CorrelationID", &(a->ns2__HeaderType::CorrelationID), "xsd:string"))
				{	soap_flag_CorrelationID1--;
					continue;
				}
			if (soap_flag_Comment1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Comment", &(a->ns2__HeaderType::Comment), "xsd:string"))
				{	soap_flag_Comment1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__MessageProperty(soap, "Property", &(a->ns2__HeaderType::Property), "ns2:MessageProperty"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->ns2__HeaderType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__HeaderType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__HeaderType, 0, sizeof(ns2__HeaderType), 0, soap_copy_ns2__HeaderType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Verb1 > 0 || soap_flag_Noun1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__HeaderType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__HeaderType);
	if (this->soap_out(soap, tag?tag:"ns2:HeaderType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__HeaderType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__HeaderType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__HeaderType * SOAP_FMAC4 soap_get_ns2__HeaderType(struct soap *soap, ns2__HeaderType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__HeaderType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__HeaderType * SOAP_FMAC2 soap_instantiate_ns2__HeaderType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__HeaderType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__HeaderType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__HeaderType);
		if (size)
			*size = sizeof(ns2__HeaderType);
		((ns2__HeaderType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__HeaderType, n);
		if (size)
			*size = n * sizeof(ns2__HeaderType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__HeaderType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__HeaderType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__HeaderType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__HeaderType %p -> %p\n", q, p));
	*(ns2__HeaderType*)p = *(ns2__HeaderType*)q;
}

void ns2__UserType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns2__UserType::UserID);
	this->ns2__UserType::Organization = NULL;
	/* transient soap skipped */
}

void ns2__UserType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns2__UserType::UserID, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__UserType::UserID);
	soap_serialize_PointerTostd__string(soap, &this->ns2__UserType::Organization);
	/* transient soap skipped */
#endif
}

int ns2__UserType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__UserType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__UserType(struct soap *soap, const char *tag, int id, const ns2__UserType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__UserType), type))
		return soap->error;
	if (soap_out_std__string(soap, "UserID", -1, &(a->ns2__UserType::UserID), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Organization", -1, &(a->ns2__UserType::Organization), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__UserType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__UserType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__UserType * SOAP_FMAC4 soap_in_ns2__UserType(struct soap *soap, const char *tag, ns2__UserType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__UserType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__UserType, sizeof(ns2__UserType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__UserType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__UserType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_UserID1 = 1;
	size_t soap_flag_Organization1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UserID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "UserID", &(a->ns2__UserType::UserID), "xsd:string"))
				{	soap_flag_UserID1--;
					continue;
				}
			if (soap_flag_Organization1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Organization", &(a->ns2__UserType::Organization), "xsd:string"))
				{	soap_flag_Organization1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__UserType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__UserType, 0, sizeof(ns2__UserType), 0, soap_copy_ns2__UserType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_UserID1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__UserType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__UserType);
	if (this->soap_out(soap, tag?tag:"ns2:UserType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__UserType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__UserType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__UserType * SOAP_FMAC4 soap_get_ns2__UserType(struct soap *soap, ns2__UserType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__UserType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__UserType * SOAP_FMAC2 soap_instantiate_ns2__UserType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__UserType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__UserType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__UserType);
		if (size)
			*size = sizeof(ns2__UserType);
		((ns2__UserType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__UserType, n);
		if (size)
			*size = n * sizeof(ns2__UserType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__UserType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__UserType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__UserType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__UserType %p -> %p\n", q, p));
	*(ns2__UserType*)p = *(ns2__UserType*)q;
}

void ns2__ReplayDetectionType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns2__ReplayDetectionType::Nonce);
	soap_default_time(soap, &this->ns2__ReplayDetectionType::Created);
	/* transient soap skipped */
}

void ns2__ReplayDetectionType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns2__ReplayDetectionType::Nonce, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__ReplayDetectionType::Nonce);
	soap_embedded(soap, &this->ns2__ReplayDetectionType::Created, SOAP_TYPE_time);
	/* transient soap skipped */
#endif
}

int ns2__ReplayDetectionType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ReplayDetectionType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ReplayDetectionType(struct soap *soap, const char *tag, int id, const ns2__ReplayDetectionType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ReplayDetectionType), type))
		return soap->error;
	if (soap_out_std__string(soap, "Nonce", -1, &(a->ns2__ReplayDetectionType::Nonce), ""))
		return soap->error;
	if (soap_out_time(soap, "Created", -1, &(a->ns2__ReplayDetectionType::Created), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__ReplayDetectionType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ReplayDetectionType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ReplayDetectionType * SOAP_FMAC4 soap_in_ns2__ReplayDetectionType(struct soap *soap, const char *tag, ns2__ReplayDetectionType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ReplayDetectionType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ReplayDetectionType, sizeof(ns2__ReplayDetectionType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ReplayDetectionType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ReplayDetectionType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Nonce1 = 1;
	size_t soap_flag_Created1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Nonce1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "Nonce", &(a->ns2__ReplayDetectionType::Nonce), "xsd:string"))
				{	soap_flag_Nonce1--;
					continue;
				}
			if (soap_flag_Created1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "Created", &(a->ns2__ReplayDetectionType::Created), "xsd:dateTime"))
				{	soap_flag_Created1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ReplayDetectionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ReplayDetectionType, 0, sizeof(ns2__ReplayDetectionType), 0, soap_copy_ns2__ReplayDetectionType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Nonce1 > 0 || soap_flag_Created1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__ReplayDetectionType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ReplayDetectionType);
	if (this->soap_out(soap, tag?tag:"ns2:ReplayDetectionType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ReplayDetectionType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ReplayDetectionType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ReplayDetectionType * SOAP_FMAC4 soap_get_ns2__ReplayDetectionType(struct soap *soap, ns2__ReplayDetectionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ReplayDetectionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ReplayDetectionType * SOAP_FMAC2 soap_instantiate_ns2__ReplayDetectionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ReplayDetectionType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ReplayDetectionType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ReplayDetectionType);
		if (size)
			*size = sizeof(ns2__ReplayDetectionType);
		((ns2__ReplayDetectionType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__ReplayDetectionType, n);
		if (size)
			*size = n * sizeof(ns2__ReplayDetectionType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__ReplayDetectionType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__ReplayDetectionType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ReplayDetectionType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ReplayDetectionType %p -> %p\n", q, p));
	*(ns2__ReplayDetectionType*)p = *(ns2__ReplayDetectionType*)q;
}

void ns2__OperationSet::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__OperationSet::enforceMsgSequence = NULL;
	this->ns2__OperationSet::enforceTransactionalIntegrity = NULL;
	soap_default_std__vectorTemplateOfPointerTons2__OperationType(soap, &this->ns2__OperationSet::Operation);
	/* transient soap skipped */
}

void ns2__OperationSet::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTobool(soap, &this->ns2__OperationSet::enforceMsgSequence);
	soap_serialize_PointerTobool(soap, &this->ns2__OperationSet::enforceTransactionalIntegrity);
	soap_serialize_std__vectorTemplateOfPointerTons2__OperationType(soap, &this->ns2__OperationSet::Operation);
	/* transient soap skipped */
#endif
}

int ns2__OperationSet::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__OperationSet(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__OperationSet(struct soap *soap, const char *tag, int id, const ns2__OperationSet *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__OperationSet), type))
		return soap->error;
	if (soap_out_PointerTobool(soap, "enforceMsgSequence", -1, &(a->ns2__OperationSet::enforceMsgSequence), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "enforceTransactionalIntegrity", -1, &(a->ns2__OperationSet::enforceTransactionalIntegrity), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__OperationType(soap, "Operation", -1, &(a->ns2__OperationSet::Operation), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__OperationSet::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__OperationSet(soap, tag, this, type);
}

SOAP_FMAC3 ns2__OperationSet * SOAP_FMAC4 soap_in_ns2__OperationSet(struct soap *soap, const char *tag, ns2__OperationSet *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__OperationSet *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__OperationSet, sizeof(ns2__OperationSet), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__OperationSet)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__OperationSet *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_enforceMsgSequence1 = 1;
	size_t soap_flag_enforceTransactionalIntegrity1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_enforceMsgSequence1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "enforceMsgSequence", &(a->ns2__OperationSet::enforceMsgSequence), "xsd:boolean"))
				{	soap_flag_enforceMsgSequence1--;
					continue;
				}
			if (soap_flag_enforceTransactionalIntegrity1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "enforceTransactionalIntegrity", &(a->ns2__OperationSet::enforceTransactionalIntegrity), "xsd:boolean"))
				{	soap_flag_enforceTransactionalIntegrity1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__OperationType(soap, "Operation", &(a->ns2__OperationSet::Operation), "ns2:OperationType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__OperationSet *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__OperationSet, 0, sizeof(ns2__OperationSet), 0, soap_copy_ns2__OperationSet);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__OperationSet::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__OperationSet);
	if (this->soap_out(soap, tag?tag:"ns2:OperationSet", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__OperationSet::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__OperationSet(soap, this, tag, type);
}

SOAP_FMAC3 ns2__OperationSet * SOAP_FMAC4 soap_get_ns2__OperationSet(struct soap *soap, ns2__OperationSet *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__OperationSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__OperationSet * SOAP_FMAC2 soap_instantiate_ns2__OperationSet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__OperationSet(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__OperationSet, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__OperationSet);
		if (size)
			*size = sizeof(ns2__OperationSet);
		((ns2__OperationSet*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__OperationSet, n);
		if (size)
			*size = n * sizeof(ns2__OperationSet);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__OperationSet*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__OperationSet*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__OperationSet(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__OperationSet %p -> %p\n", q, p));
	*(ns2__OperationSet*)p = *(ns2__OperationSet*)q;
}

void ns2__OperationType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__integer(soap, &this->ns2__OperationType::operationId);
	this->ns2__OperationType::noun = NULL;
	this->ns2__OperationType::verb = NULL;
	this->ns2__OperationType::elementOperation = (bool)0;
	this->ns2__OperationType::__any = NULL;
	/* transient soap skipped */
}

void ns2__OperationType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns2__OperationType::operationId, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &this->ns2__OperationType::operationId);
	soap_serialize_PointerTostd__string(soap, &this->ns2__OperationType::noun);
	soap_serialize_PointerTostd__string(soap, &this->ns2__OperationType::verb);
	soap_embedded(soap, &this->ns2__OperationType::elementOperation, SOAP_TYPE_bool);
	/* transient soap skipped */
#endif
}

int ns2__OperationType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__OperationType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__OperationType(struct soap *soap, const char *tag, int id, const ns2__OperationType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__OperationType), type))
		return soap->error;
	if (soap_out_xsd__integer(soap, "operationId", -1, &(a->ns2__OperationType::operationId), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "noun", -1, &(a->ns2__OperationType::noun), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "verb", -1, &(a->ns2__OperationType::verb), ""))
		return soap->error;
	if (soap_out_bool(soap, "elementOperation", -1, &(a->ns2__OperationType::elementOperation), ""))
		return soap->error;
	soap_outliteral(soap, "-any", &(a->ns2__OperationType::__any), NULL);
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__OperationType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__OperationType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__OperationType * SOAP_FMAC4 soap_in_ns2__OperationType(struct soap *soap, const char *tag, ns2__OperationType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__OperationType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__OperationType, sizeof(ns2__OperationType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__OperationType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__OperationType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_operationId1 = 1;
	size_t soap_flag_noun1 = 1;
	size_t soap_flag_verb1 = 1;
	size_t soap_flag_elementOperation1 = 1;
	size_t soap_flag___any1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_operationId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "operationId", &(a->ns2__OperationType::operationId), "xsd:integer"))
				{	soap_flag_operationId1--;
					continue;
				}
			if (soap_flag_noun1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "noun", &(a->ns2__OperationType::noun), "xsd:string"))
				{	soap_flag_noun1--;
					continue;
				}
			if (soap_flag_verb1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "verb", &(a->ns2__OperationType::verb), "xsd:string"))
				{	soap_flag_verb1--;
					continue;
				}
			if (soap_flag_elementOperation1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "elementOperation", &(a->ns2__OperationType::elementOperation), "xsd:boolean"))
				{	soap_flag_elementOperation1--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag___any1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &(a->ns2__OperationType::__any)))
				{	soap_flag___any1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__OperationType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__OperationType, 0, sizeof(ns2__OperationType), 0, soap_copy_ns2__OperationType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_operationId1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__OperationType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__OperationType);
	if (this->soap_out(soap, tag?tag:"ns2:OperationType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__OperationType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__OperationType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__OperationType * SOAP_FMAC4 soap_get_ns2__OperationType(struct soap *soap, ns2__OperationType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__OperationType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__OperationType * SOAP_FMAC2 soap_instantiate_ns2__OperationType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__OperationType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__OperationType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__OperationType);
		if (size)
			*size = sizeof(ns2__OperationType);
		((ns2__OperationType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__OperationType, n);
		if (size)
			*size = n * sizeof(ns2__OperationType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__OperationType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__OperationType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__OperationType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__OperationType %p -> %p\n", q, p));
	*(ns2__OperationType*)p = *(ns2__OperationType*)q;
}

void ns2__PayloadType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__PayloadType::__union_PayloadType = 0;
	this->ns2__PayloadType::Format = NULL;
	/* transient soap skipped */
}

void ns2__PayloadType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize__ns2__union_PayloadType(soap, this->ns2__PayloadType::__union_PayloadType, &this->ns2__PayloadType::union_PayloadType);
	soap_serialize_PointerTostd__string(soap, &this->ns2__PayloadType::Format);
	/* transient soap skipped */
#endif
}

int ns2__PayloadType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PayloadType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PayloadType(struct soap *soap, const char *tag, int id, const ns2__PayloadType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PayloadType), type))
		return soap->error;
	if (soap_out__ns2__union_PayloadType(soap, a->ns2__PayloadType::__union_PayloadType, &a->ns2__PayloadType::union_PayloadType))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Format", -1, &(a->ns2__PayloadType::Format), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__PayloadType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PayloadType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PayloadType * SOAP_FMAC4 soap_in_ns2__PayloadType(struct soap *soap, const char *tag, ns2__PayloadType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PayloadType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PayloadType, sizeof(ns2__PayloadType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__PayloadType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__PayloadType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_union_PayloadType1 = 1;
	size_t soap_flag_Format1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_union_PayloadType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns2__union_PayloadType(soap, &a->ns2__PayloadType::__union_PayloadType, &a->ns2__PayloadType::union_PayloadType))
				{	soap_flag_union_PayloadType1 = 0;
					continue;
				}
			if (soap_flag_Format1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Format", &(a->ns2__PayloadType::Format), "xsd:string"))
				{	soap_flag_Format1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__PayloadType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PayloadType, 0, sizeof(ns2__PayloadType), 0, soap_copy_ns2__PayloadType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_union_PayloadType1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__PayloadType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__PayloadType);
	if (this->soap_out(soap, tag?tag:"ns2:PayloadType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PayloadType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PayloadType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PayloadType * SOAP_FMAC4 soap_get_ns2__PayloadType(struct soap *soap, ns2__PayloadType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PayloadType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__PayloadType * SOAP_FMAC2 soap_instantiate_ns2__PayloadType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PayloadType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__PayloadType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__PayloadType);
		if (size)
			*size = sizeof(ns2__PayloadType);
		((ns2__PayloadType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__PayloadType, n);
		if (size)
			*size = n * sizeof(ns2__PayloadType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__PayloadType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__PayloadType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__PayloadType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__PayloadType %p -> %p\n", q, p));
	*(ns2__PayloadType*)p = *(ns2__PayloadType*)q;
}

void ns2__ReplyType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default__ns2__ReplyType_Result(soap, &this->ns2__ReplyType::Result);
	soap_default_std__vectorTemplateOfPointerTons2__ErrorType(soap, &this->ns2__ReplyType::Error);
	this->ns2__ReplyType::ID = NULL;
	soap_default_std__vectorTemplateOf_XML(soap, &this->ns2__ReplyType::__any);
	this->ns2__ReplyType::operationId = NULL;
	/* transient soap skipped */
}

void ns2__ReplyType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons2__ErrorType(soap, &this->ns2__ReplyType::Error);
	soap_serialize_PointerTostd__vectorTemplateOf_ns2__ReplyType_ID(soap, &this->ns2__ReplyType::ID);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->ns2__ReplyType::__any);
	soap_serialize_PointerToxsd__integer(soap, &this->ns2__ReplyType::operationId);
	/* transient soap skipped */
#endif
}

int ns2__ReplyType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ReplyType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ReplyType(struct soap *soap, const char *tag, int id, const ns2__ReplyType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ReplyType), type))
		return soap->error;
	if (soap_out__ns2__ReplyType_Result(soap, "Result", -1, &(a->ns2__ReplyType::Result), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__ErrorType(soap, "Error", -1, &(a->ns2__ReplyType::Error), ""))
		return soap->error;
	if (soap_out_PointerTostd__vectorTemplateOf_ns2__ReplyType_ID(soap, "ID", -1, &(a->ns2__ReplyType::ID), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->ns2__ReplyType::__any), ""))
		return soap->error;
	if (soap_out_PointerToxsd__integer(soap, "operationId", -1, &(a->ns2__ReplyType::operationId), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__ReplyType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ReplyType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ReplyType * SOAP_FMAC4 soap_in_ns2__ReplyType(struct soap *soap, const char *tag, ns2__ReplyType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ReplyType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ReplyType, sizeof(ns2__ReplyType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ReplyType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ReplyType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Result1 = 1;
	size_t soap_flag_operationId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns2__ReplyType_Result(soap, "Result", &(a->ns2__ReplyType::Result), "ns2:ReplyType-Result"))
				{	soap_flag_Result1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__ErrorType(soap, "Error", &(a->ns2__ReplyType::Error), "ns2:ErrorType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__vectorTemplateOf_ns2__ReplyType_ID(soap, "ID", &(a->ns2__ReplyType::ID), ""))
					continue;
			if (soap_flag_operationId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__integer(soap, "operationId", &(a->ns2__ReplyType::operationId), "xsd:integer"))
				{	soap_flag_operationId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->ns2__ReplyType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ReplyType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ReplyType, 0, sizeof(ns2__ReplyType), 0, soap_copy_ns2__ReplyType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Result1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__ReplyType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ReplyType);
	if (this->soap_out(soap, tag?tag:"ns2:ReplyType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ReplyType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ReplyType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ReplyType * SOAP_FMAC4 soap_get_ns2__ReplyType(struct soap *soap, ns2__ReplyType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ReplyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ReplyType * SOAP_FMAC2 soap_instantiate_ns2__ReplyType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ReplyType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ReplyType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ReplyType);
		if (size)
			*size = sizeof(ns2__ReplyType);
		((ns2__ReplyType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__ReplyType, n);
		if (size)
			*size = n * sizeof(ns2__ReplyType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__ReplyType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__ReplyType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ReplyType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ReplyType %p -> %p\n", q, p));
	*(ns2__ReplyType*)p = *(ns2__ReplyType*)q;
}

void ns2__RequestType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__RequestType::StartTime = NULL;
	this->ns2__RequestType::EndTime = NULL;
	soap_default_std__vectorTemplateOfPointerTons2__OptionType(soap, &this->ns2__RequestType::Option);
	this->ns2__RequestType::ID = NULL;
	soap_default_std__vectorTemplateOf_XML(soap, &this->ns2__RequestType::__any);
	/* transient soap skipped */
}

void ns2__RequestType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTotime(soap, &this->ns2__RequestType::StartTime);
	soap_serialize_PointerTotime(soap, &this->ns2__RequestType::EndTime);
	soap_serialize_std__vectorTemplateOfPointerTons2__OptionType(soap, &this->ns2__RequestType::Option);
	soap_serialize_PointerTostd__vectorTemplateOf_ns2__RequestType_ID(soap, &this->ns2__RequestType::ID);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->ns2__RequestType::__any);
	/* transient soap skipped */
#endif
}

int ns2__RequestType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__RequestType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__RequestType(struct soap *soap, const char *tag, int id, const ns2__RequestType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__RequestType), type))
		return soap->error;
	if (soap_out_PointerTotime(soap, "StartTime", -1, &(a->ns2__RequestType::StartTime), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "EndTime", -1, &(a->ns2__RequestType::EndTime), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__OptionType(soap, "Option", -1, &(a->ns2__RequestType::Option), ""))
		return soap->error;
	if (soap_out_PointerTostd__vectorTemplateOf_ns2__RequestType_ID(soap, "ID", -1, &(a->ns2__RequestType::ID), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->ns2__RequestType::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__RequestType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__RequestType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__RequestType * SOAP_FMAC4 soap_in_ns2__RequestType(struct soap *soap, const char *tag, ns2__RequestType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__RequestType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__RequestType, sizeof(ns2__RequestType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__RequestType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__RequestType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_StartTime1 = 1;
	size_t soap_flag_EndTime1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_StartTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "StartTime", &(a->ns2__RequestType::StartTime), "xsd:dateTime"))
				{	soap_flag_StartTime1--;
					continue;
				}
			if (soap_flag_EndTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "EndTime", &(a->ns2__RequestType::EndTime), "xsd:dateTime"))
				{	soap_flag_EndTime1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__OptionType(soap, "Option", &(a->ns2__RequestType::Option), "ns2:OptionType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__vectorTemplateOf_ns2__RequestType_ID(soap, "ID", &(a->ns2__RequestType::ID), ""))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->ns2__RequestType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__RequestType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__RequestType, 0, sizeof(ns2__RequestType), 0, soap_copy_ns2__RequestType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__RequestType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__RequestType);
	if (this->soap_out(soap, tag?tag:"ns2:RequestType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__RequestType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__RequestType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__RequestType * SOAP_FMAC4 soap_get_ns2__RequestType(struct soap *soap, ns2__RequestType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__RequestType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__RequestType * SOAP_FMAC2 soap_instantiate_ns2__RequestType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__RequestType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__RequestType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__RequestType);
		if (size)
			*size = sizeof(ns2__RequestType);
		((ns2__RequestType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__RequestType, n);
		if (size)
			*size = n * sizeof(ns2__RequestType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__RequestType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__RequestType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__RequestType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__RequestType %p -> %p\n", q, p));
	*(ns2__RequestType*)p = *(ns2__RequestType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__integer(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__integer(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__integer), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__integer(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__integer, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__integer, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__integer, 0, sizeof(std::string), 0, soap_copy_xsd__integer);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__integer(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__integer);
	if (soap_out_xsd__integer(soap, tag?tag:"xsd:integer", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__integer(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__integer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__QName(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__QName(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__QName(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__QName), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_xsd__QName(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, type))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__QName, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 2, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__QName, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__QName, 0, sizeof(std::string), 0, soap_copy_xsd__QName);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__QName(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__QName);
	if (soap_out_xsd__QName(soap, tag?tag:"xsd:QName", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__QName(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_xsd__QName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__QName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__QName, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::string);
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::string, n);
		if (size)
			*size = n * sizeof(std::string);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::string*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__QName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_std__string, 0, sizeof(std::string), 0, soap_copy_std__string);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__string);
	if (soap_out_std__string(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::string);
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::string, n);
		if (size)
			*size = n * sizeof(std::string);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::string*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault);
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Fault, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason);
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Reason, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail);
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Detail, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code);
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Code, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Code*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header);
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Header, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Header*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__Response(struct soap *soap, struct __ns1__Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__ResponseMessage = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__Response(struct soap *soap, const struct __ns1__Response *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__ResponseMessageType(soap, &a->ns2__ResponseMessage);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__Response(struct soap *soap, const char *tag, int id, const struct __ns1__Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons2__ResponseMessageType(soap, "ns2:ResponseMessage", -1, &a->ns2__ResponseMessage, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Response * SOAP_FMAC4 soap_in___ns1__Response(struct soap *soap, const char *tag, struct __ns1__Response *a, const char *type)
{
	size_t soap_flag_ns2__ResponseMessage = 1;
	short soap_flag;
	a = (struct __ns1__Response *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__Response, sizeof(struct __ns1__Response), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__Response(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__ResponseMessage && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ResponseMessageType(soap, "ns2:ResponseMessage", &a->ns2__ResponseMessage, "ns2:ResponseMessageType"))
				{	soap_flag_ns2__ResponseMessage--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__Response(struct soap *soap, const struct __ns1__Response *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__Response(soap, tag?tag:"-ns1:Response", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Response * SOAP_FMAC4 soap_get___ns1__Response(struct soap *soap, struct __ns1__Response *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__Response * SOAP_FMAC2 soap_instantiate___ns1__Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__Response);
		if (size)
			*size = sizeof(struct __ns1__Response);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__Response, n);
		if (size)
			*size = n * sizeof(struct __ns1__Response);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__Response %p -> %p\n", q, p));
	*(struct __ns1__Response*)p = *(struct __ns1__Response*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ResponseResponse(struct soap *soap, struct __ns1__ResponseResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__ResponseMessage = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ResponseResponse(struct soap *soap, const struct __ns1__ResponseResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__ResponseMessageType(soap, &a->ns2__ResponseMessage);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ResponseResponse(struct soap *soap, const char *tag, int id, const struct __ns1__ResponseResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (a->ns2__ResponseMessage)
		soap_element_result(soap, "ns2:ResponseMessage");
	if (soap_out_PointerTons2__ResponseMessageType(soap, "ns2:ResponseMessage", -1, &a->ns2__ResponseMessage, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ResponseResponse * SOAP_FMAC4 soap_in___ns1__ResponseResponse(struct soap *soap, const char *tag, struct __ns1__ResponseResponse *a, const char *type)
{
	size_t soap_flag_ns2__ResponseMessage = 1;
	short soap_flag;
	a = (struct __ns1__ResponseResponse *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__ResponseResponse, sizeof(struct __ns1__ResponseResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ResponseResponse(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__ResponseMessage && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ResponseMessageType(soap, "ns2:ResponseMessage", &a->ns2__ResponseMessage, "ns2:ResponseMessageType"))
				{	soap_flag_ns2__ResponseMessage--;
					continue;
				}
			soap_check_result(soap, "ns2:ResponseMessage");
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ResponseResponse(struct soap *soap, const struct __ns1__ResponseResponse *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__ResponseResponse(soap, tag?tag:"-ns1:ResponseResponse", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ResponseResponse * SOAP_FMAC4 soap_get___ns1__ResponseResponse(struct soap *soap, struct __ns1__ResponseResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ResponseResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__ResponseResponse * SOAP_FMAC2 soap_instantiate___ns1__ResponseResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__ResponseResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__ResponseResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__ResponseResponse);
		if (size)
			*size = sizeof(struct __ns1__ResponseResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__ResponseResponse, n);
		if (size)
			*size = n * sizeof(struct __ns1__ResponseResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__ResponseResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__ResponseResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__ResponseResponse %p -> %p\n", q, p));
	*(struct __ns1__ResponseResponse*)p = *(struct __ns1__ResponseResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__Request(struct soap *soap, struct __ns1__Request *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__RequestMessage = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__Request(struct soap *soap, const struct __ns1__Request *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__RequestMessageType(soap, &a->ns2__RequestMessage);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__Request(struct soap *soap, const char *tag, int id, const struct __ns1__Request *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons2__RequestMessageType(soap, "ns2:RequestMessage", -1, &a->ns2__RequestMessage, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Request * SOAP_FMAC4 soap_in___ns1__Request(struct soap *soap, const char *tag, struct __ns1__Request *a, const char *type)
{
	size_t soap_flag_ns2__RequestMessage = 1;
	short soap_flag;
	a = (struct __ns1__Request *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__Request, sizeof(struct __ns1__Request), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__Request(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__RequestMessage && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__RequestMessageType(soap, "ns2:RequestMessage", &a->ns2__RequestMessage, "ns2:RequestMessageType"))
				{	soap_flag_ns2__RequestMessage--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__Request(struct soap *soap, const struct __ns1__Request *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__Request(soap, tag?tag:"-ns1:Request", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Request * SOAP_FMAC4 soap_get___ns1__Request(struct soap *soap, struct __ns1__Request *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__Request(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__Request * SOAP_FMAC2 soap_instantiate___ns1__Request(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__Request(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__Request, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__Request);
		if (size)
			*size = sizeof(struct __ns1__Request);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__Request, n);
		if (size)
			*size = n * sizeof(struct __ns1__Request);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__Request*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__Request(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__Request %p -> %p\n", q, p));
	*(struct __ns1__Request*)p = *(struct __ns1__Request*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__PublishEvent(struct soap *soap, struct __ns1__PublishEvent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__EventMessage = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__PublishEvent(struct soap *soap, const struct __ns1__PublishEvent *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__EventMessageType(soap, &a->ns2__EventMessage);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__PublishEvent(struct soap *soap, const char *tag, int id, const struct __ns1__PublishEvent *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons2__EventMessageType(soap, "ns2:EventMessage", -1, &a->ns2__EventMessage, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__PublishEvent * SOAP_FMAC4 soap_in___ns1__PublishEvent(struct soap *soap, const char *tag, struct __ns1__PublishEvent *a, const char *type)
{
	size_t soap_flag_ns2__EventMessage = 1;
	short soap_flag;
	a = (struct __ns1__PublishEvent *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__PublishEvent, sizeof(struct __ns1__PublishEvent), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__PublishEvent(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__EventMessage && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__EventMessageType(soap, "ns2:EventMessage", &a->ns2__EventMessage, "ns2:EventMessageType"))
				{	soap_flag_ns2__EventMessage--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__PublishEvent(struct soap *soap, const struct __ns1__PublishEvent *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__PublishEvent(soap, tag?tag:"-ns1:PublishEvent", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__PublishEvent * SOAP_FMAC4 soap_get___ns1__PublishEvent(struct soap *soap, struct __ns1__PublishEvent *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__PublishEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__PublishEvent * SOAP_FMAC2 soap_instantiate___ns1__PublishEvent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__PublishEvent(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__PublishEvent, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__PublishEvent);
		if (size)
			*size = sizeof(struct __ns1__PublishEvent);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__PublishEvent, n);
		if (size)
			*size = n * sizeof(struct __ns1__PublishEvent);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__PublishEvent*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__PublishEvent(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__PublishEvent %p -> %p\n", q, p));
	*(struct __ns1__PublishEvent*)p = *(struct __ns1__PublishEvent*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns2__union_PayloadType(struct soap *soap, int choice, const union _ns2__union_PayloadType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__ns2__union_PayloadType_CommonValues:
		soap_serialize_PointerTostd__vectorTemplateOfPointerTons3__CommonValuesType(soap, &a->CommonValues);
		break;
	case SOAP_UNION__ns2__union_PayloadType_DeviceValues:
		soap_serialize_PointerTostd__vectorTemplateOfPointerTons3__DeviceValuesType(soap, &a->DeviceValues);
		break;
	case SOAP_UNION__ns2__union_PayloadType_ArrayValues:
		soap_serialize_PointerTostd__vectorTemplateOfPointerTons3__ArrayValuesType(soap, &a->ArrayValues);
		break;
	case SOAP_UNION__ns2__union_PayloadType_OperationSet:
		soap_serialize_PointerTons2__OperationSet(soap, &a->OperationSet);
		break;
	case SOAP_UNION__ns2__union_PayloadType_Compressed:
		soap_serialize_PointerTostd__string(soap, &a->Compressed);
		break;
	case SOAP_UNION__ns2__union_PayloadType_ID:
		soap_serialize_PointerTostd__vectorTemplateOf_ns2__PayloadType_ID(soap, &a->ID);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__union_PayloadType(struct soap *soap, int choice, const union _ns2__union_PayloadType *a)
{
	switch (choice)
	{
	case SOAP_UNION__ns2__union_PayloadType_CommonValues:
		return soap_out_PointerTostd__vectorTemplateOfPointerTons3__CommonValuesType(soap, "CommonValues", -1, &a->CommonValues, "");
	case SOAP_UNION__ns2__union_PayloadType_DeviceValues:
		return soap_out_PointerTostd__vectorTemplateOfPointerTons3__DeviceValuesType(soap, "DeviceValues", -1, &a->DeviceValues, "");
	case SOAP_UNION__ns2__union_PayloadType_ArrayValues:
		return soap_out_PointerTostd__vectorTemplateOfPointerTons3__ArrayValuesType(soap, "ArrayValues", -1, &a->ArrayValues, "");
	case SOAP_UNION__ns2__union_PayloadType_OperationSet:
		return soap_out_PointerTons2__OperationSet(soap, "OperationSet", -1, &a->OperationSet, "");
	case SOAP_UNION__ns2__union_PayloadType_Compressed:
		return soap_out_PointerTostd__string(soap, "Compressed", -1, &a->Compressed, "");
	case SOAP_UNION__ns2__union_PayloadType_ID:
		return soap_out_PointerTostd__vectorTemplateOf_ns2__PayloadType_ID(soap, "ID", -1, &a->ID, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns2__union_PayloadType * SOAP_FMAC4 soap_in__ns2__union_PayloadType(struct soap *soap, int *choice, union _ns2__union_PayloadType *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->CommonValues = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTostd__vectorTemplateOfPointerTons3__CommonValuesType(soap, "CommonValues", &a->CommonValues, "ns3:CommonValuesType"))
	{	*choice = SOAP_UNION__ns2__union_PayloadType_CommonValues;
		return a;
	}
	a->DeviceValues = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTostd__vectorTemplateOfPointerTons3__DeviceValuesType(soap, "DeviceValues", &a->DeviceValues, "ns3:DeviceValuesType"))
	{	*choice = SOAP_UNION__ns2__union_PayloadType_DeviceValues;
		return a;
	}
	a->ArrayValues = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTostd__vectorTemplateOfPointerTons3__ArrayValuesType(soap, "ArrayValues", &a->ArrayValues, "ns3:ArrayValuesType"))
	{	*choice = SOAP_UNION__ns2__union_PayloadType_ArrayValues;
		return a;
	}
	a->OperationSet = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__OperationSet(soap, "OperationSet", &a->OperationSet, "ns2:OperationSet"))
	{	*choice = SOAP_UNION__ns2__union_PayloadType_OperationSet;
		return a;
	}
	a->Compressed = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTostd__string(soap, "Compressed", &a->Compressed, "xsd:string"))
	{	*choice = SOAP_UNION__ns2__union_PayloadType_Compressed;
		return a;
	}
	a->ID = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTostd__vectorTemplateOf_ns2__PayloadType_ID(soap, "ID", &a->ID, ""))
	{	*choice = SOAP_UNION__ns2__union_PayloadType_ID;
		return a;
	}
	*choice = -1;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__RequestMessageType(struct soap *soap, ns2__RequestMessageType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__RequestMessageType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__RequestMessageType(struct soap *soap, const char *tag, int id, ns2__RequestMessageType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__RequestMessageType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__RequestMessageType ** SOAP_FMAC4 soap_in_PointerTons2__RequestMessageType(struct soap *soap, const char *tag, ns2__RequestMessageType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__RequestMessageType **)soap_malloc(soap, sizeof(ns2__RequestMessageType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__RequestMessageType *)soap_instantiate_ns2__RequestMessageType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__RequestMessageType ** p = (ns2__RequestMessageType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__RequestMessageType, sizeof(ns2__RequestMessageType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__RequestMessageType(struct soap *soap, ns2__RequestMessageType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__RequestMessageType);
	if (soap_out_PointerTons2__RequestMessageType(soap, tag?tag:"ns2:RequestMessageType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__RequestMessageType ** SOAP_FMAC4 soap_get_PointerTons2__RequestMessageType(struct soap *soap, ns2__RequestMessageType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__RequestMessageType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ResponseMessageType(struct soap *soap, ns2__ResponseMessageType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ResponseMessageType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ResponseMessageType(struct soap *soap, const char *tag, int id, ns2__ResponseMessageType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ResponseMessageType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ResponseMessageType ** SOAP_FMAC4 soap_in_PointerTons2__ResponseMessageType(struct soap *soap, const char *tag, ns2__ResponseMessageType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ResponseMessageType **)soap_malloc(soap, sizeof(ns2__ResponseMessageType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ResponseMessageType *)soap_instantiate_ns2__ResponseMessageType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ResponseMessageType ** p = (ns2__ResponseMessageType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ResponseMessageType, sizeof(ns2__ResponseMessageType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ResponseMessageType(struct soap *soap, ns2__ResponseMessageType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ResponseMessageType);
	if (soap_out_PointerTons2__ResponseMessageType(soap, tag?tag:"ns2:ResponseMessageType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ResponseMessageType ** SOAP_FMAC4 soap_get_PointerTons2__ResponseMessageType(struct soap *soap, ns2__ResponseMessageType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ResponseMessageType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__EventMessageType(struct soap *soap, ns2__EventMessageType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__EventMessageType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__EventMessageType(struct soap *soap, const char *tag, int id, ns2__EventMessageType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__EventMessageType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__EventMessageType ** SOAP_FMAC4 soap_in_PointerTons2__EventMessageType(struct soap *soap, const char *tag, ns2__EventMessageType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__EventMessageType **)soap_malloc(soap, sizeof(ns2__EventMessageType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__EventMessageType *)soap_instantiate_ns2__EventMessageType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__EventMessageType ** p = (ns2__EventMessageType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__EventMessageType, sizeof(ns2__EventMessageType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__EventMessageType(struct soap *soap, ns2__EventMessageType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__EventMessageType);
	if (soap_out_PointerTons2__EventMessageType(soap, tag?tag:"ns2:EventMessageType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__EventMessageType ** SOAP_FMAC4 soap_get_PointerTons2__EventMessageType(struct soap *soap, ns2__EventMessageType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__EventMessageType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__DeviceClassType(struct soap *soap, ns3__DeviceClassType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__DeviceClassType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__DeviceClassType(struct soap *soap, const char *tag, int id, ns3__DeviceClassType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__DeviceClassType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__DeviceClassType ** SOAP_FMAC4 soap_in_PointerTons3__DeviceClassType(struct soap *soap, const char *tag, ns3__DeviceClassType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__DeviceClassType **)soap_malloc(soap, sizeof(ns3__DeviceClassType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__DeviceClassType *)soap_instantiate_ns3__DeviceClassType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns3__DeviceClassType ** p = (ns3__DeviceClassType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__DeviceClassType, sizeof(ns3__DeviceClassType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__DeviceClassType(struct soap *soap, ns3__DeviceClassType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__DeviceClassType);
	if (soap_out_PointerTons3__DeviceClassType(soap, tag?tag:"ns3:DeviceClassType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__DeviceClassType ** SOAP_FMAC4 soap_get_PointerTons3__DeviceClassType(struct soap *soap, ns3__DeviceClassType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__DeviceClassType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__NameType(struct soap *soap, ns2__NameType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__NameType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__NameType(struct soap *soap, const char *tag, int id, ns2__NameType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__NameType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__NameType ** SOAP_FMAC4 soap_in_PointerTons2__NameType(struct soap *soap, const char *tag, ns2__NameType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__NameType **)soap_malloc(soap, sizeof(ns2__NameType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__NameType *)soap_instantiate_ns2__NameType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__NameType ** p = (ns2__NameType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__NameType, sizeof(ns2__NameType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__NameType(struct soap *soap, ns2__NameType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__NameType);
	if (soap_out_PointerTons2__NameType(soap, tag?tag:"ns2:NameType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__NameType ** SOAP_FMAC4 soap_get_PointerTons2__NameType(struct soap *soap, ns2__NameType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__NameType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__NameTypeAuthority(struct soap *soap, ns2__NameTypeAuthority *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__NameTypeAuthority))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__NameTypeAuthority(struct soap *soap, const char *tag, int id, ns2__NameTypeAuthority *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__NameTypeAuthority);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__NameTypeAuthority ** SOAP_FMAC4 soap_in_PointerTons2__NameTypeAuthority(struct soap *soap, const char *tag, ns2__NameTypeAuthority **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__NameTypeAuthority **)soap_malloc(soap, sizeof(ns2__NameTypeAuthority *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__NameTypeAuthority *)soap_instantiate_ns2__NameTypeAuthority(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__NameTypeAuthority ** p = (ns2__NameTypeAuthority **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__NameTypeAuthority, sizeof(ns2__NameTypeAuthority), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__NameTypeAuthority(struct soap *soap, ns2__NameTypeAuthority *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__NameTypeAuthority);
	if (soap_out_PointerTons2__NameTypeAuthority(soap, tag?tag:"ns2:NameTypeAuthority", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__NameTypeAuthority ** SOAP_FMAC4 soap_get_PointerTons2__NameTypeAuthority(struct soap *soap, ns2__NameTypeAuthority **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__NameTypeAuthority(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Name(struct soap *soap, ns2__Name *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__Name))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Name(struct soap *soap, const char *tag, int id, ns2__Name *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Name);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__Name ** SOAP_FMAC4 soap_in_PointerTons2__Name(struct soap *soap, const char *tag, ns2__Name **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__Name **)soap_malloc(soap, sizeof(ns2__Name *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__Name *)soap_instantiate_ns2__Name(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__Name ** p = (ns2__Name **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Name, sizeof(ns2__Name), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Name(struct soap *soap, ns2__Name *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__Name);
	if (soap_out_PointerTons2__Name(soap, tag?tag:"ns2:Name", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__Name ** SOAP_FMAC4 soap_get_PointerTons2__Name(struct soap *soap, ns2__Name **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Name(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ObjectType(struct soap *soap, ns2__ObjectType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ObjectType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ObjectType(struct soap *soap, const char *tag, int id, ns2__ObjectType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ObjectType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ObjectType ** SOAP_FMAC4 soap_in_PointerTons2__ObjectType(struct soap *soap, const char *tag, ns2__ObjectType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ObjectType **)soap_malloc(soap, sizeof(ns2__ObjectType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ObjectType *)soap_instantiate_ns2__ObjectType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ObjectType ** p = (ns2__ObjectType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ObjectType, sizeof(ns2__ObjectType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ObjectType(struct soap *soap, ns2__ObjectType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ObjectType);
	if (soap_out_PointerTons2__ObjectType(soap, tag?tag:"ns2:ObjectType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ObjectType ** SOAP_FMAC4 soap_get_PointerTons2__ObjectType(struct soap *soap, ns2__ObjectType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ObjectType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__ErrorType_relatedID(struct soap *soap, _ns2__ErrorType_relatedID *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__ErrorType_relatedID))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__ErrorType_relatedID(struct soap *soap, const char *tag, int id, _ns2__ErrorType_relatedID *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__ErrorType_relatedID);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns2__ErrorType_relatedID ** SOAP_FMAC4 soap_in_PointerTo_ns2__ErrorType_relatedID(struct soap *soap, const char *tag, _ns2__ErrorType_relatedID **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns2__ErrorType_relatedID **)soap_malloc(soap, sizeof(_ns2__ErrorType_relatedID *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns2__ErrorType_relatedID *)soap_instantiate__ns2__ErrorType_relatedID(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns2__ErrorType_relatedID ** p = (_ns2__ErrorType_relatedID **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__ErrorType_relatedID, sizeof(_ns2__ErrorType_relatedID), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__ErrorType_relatedID(struct soap *soap, _ns2__ErrorType_relatedID *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns2__ErrorType_relatedID);
	if (soap_out_PointerTo_ns2__ErrorType_relatedID(soap, tag?tag:"ns2:ErrorType-relatedID", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns2__ErrorType_relatedID ** SOAP_FMAC4 soap_get_PointerTo_ns2__ErrorType_relatedID(struct soap *soap, _ns2__ErrorType_relatedID **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__ErrorType_relatedID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__ErrorType_ID(struct soap *soap, _ns2__ErrorType_ID *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__ErrorType_ID))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__ErrorType_ID(struct soap *soap, const char *tag, int id, _ns2__ErrorType_ID *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__ErrorType_ID);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns2__ErrorType_ID ** SOAP_FMAC4 soap_in_PointerTo_ns2__ErrorType_ID(struct soap *soap, const char *tag, _ns2__ErrorType_ID **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns2__ErrorType_ID **)soap_malloc(soap, sizeof(_ns2__ErrorType_ID *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns2__ErrorType_ID *)soap_instantiate__ns2__ErrorType_ID(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns2__ErrorType_ID ** p = (_ns2__ErrorType_ID **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__ErrorType_ID, sizeof(_ns2__ErrorType_ID), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__ErrorType_ID(struct soap *soap, _ns2__ErrorType_ID *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns2__ErrorType_ID);
	if (soap_out_PointerTo_ns2__ErrorType_ID(soap, tag?tag:"ns2:ErrorType-ID", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns2__ErrorType_ID ** SOAP_FMAC4 soap_get_PointerTo_ns2__ErrorType_ID(struct soap *soap, _ns2__ErrorType_ID **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__ErrorType_ID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__LocationType(struct soap *soap, ns2__LocationType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__LocationType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__LocationType(struct soap *soap, const char *tag, int id, ns2__LocationType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__LocationType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__LocationType ** SOAP_FMAC4 soap_in_PointerTons2__LocationType(struct soap *soap, const char *tag, ns2__LocationType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__LocationType **)soap_malloc(soap, sizeof(ns2__LocationType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__LocationType *)soap_instantiate_ns2__LocationType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__LocationType ** p = (ns2__LocationType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__LocationType, sizeof(ns2__LocationType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__LocationType(struct soap *soap, ns2__LocationType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__LocationType);
	if (soap_out_PointerTons2__LocationType(soap, tag?tag:"ns2:LocationType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__LocationType ** SOAP_FMAC4 soap_get_PointerTons2__LocationType(struct soap *soap, ns2__LocationType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__LocationType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__QName(struct soap *soap, std::string *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__QName))
		soap_serialize_xsd__QName(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__QName(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__QName);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__QName(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__QName(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__QName(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__QName, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__QName(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__QName);
	if (soap_out_PointerToxsd__QName(soap, tag?tag:"xsd:QName", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__QName(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__ErrorType_level(struct soap *soap, enum _ns2__ErrorType_level *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE__ns2__ErrorType_level);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__ErrorType_level(struct soap *soap, const char *tag, int id, enum _ns2__ErrorType_level *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__ErrorType_level);
	if (id < 0)
		return soap->error;
	return soap_out__ns2__ErrorType_level(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum _ns2__ErrorType_level ** SOAP_FMAC4 soap_in_PointerTo_ns2__ErrorType_level(struct soap *soap, const char *tag, enum _ns2__ErrorType_level **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum _ns2__ErrorType_level **)soap_malloc(soap, sizeof(enum _ns2__ErrorType_level *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns2__ErrorType_level(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum _ns2__ErrorType_level **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__ErrorType_level, sizeof(enum _ns2__ErrorType_level), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__ErrorType_level(struct soap *soap, enum _ns2__ErrorType_level *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns2__ErrorType_level);
	if (soap_out_PointerTo_ns2__ErrorType_level(soap, tag?tag:"ns2:ErrorType-level", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum _ns2__ErrorType_level ** SOAP_FMAC4 soap_get_PointerTo_ns2__ErrorType_level(struct soap *soap, enum _ns2__ErrorType_level **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__ErrorType_level(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PayloadType(struct soap *soap, ns2__PayloadType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PayloadType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PayloadType(struct soap *soap, const char *tag, int id, ns2__PayloadType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PayloadType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PayloadType ** SOAP_FMAC4 soap_in_PointerTons2__PayloadType(struct soap *soap, const char *tag, ns2__PayloadType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PayloadType **)soap_malloc(soap, sizeof(ns2__PayloadType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PayloadType *)soap_instantiate_ns2__PayloadType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__PayloadType ** p = (ns2__PayloadType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PayloadType, sizeof(ns2__PayloadType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PayloadType(struct soap *soap, ns2__PayloadType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__PayloadType);
	if (soap_out_PointerTons2__PayloadType(soap, tag?tag:"ns2:PayloadType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__PayloadType ** SOAP_FMAC4 soap_get_PointerTons2__PayloadType(struct soap *soap, ns2__PayloadType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PayloadType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ReplyType(struct soap *soap, ns2__ReplyType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ReplyType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ReplyType(struct soap *soap, const char *tag, int id, ns2__ReplyType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ReplyType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ReplyType ** SOAP_FMAC4 soap_in_PointerTons2__ReplyType(struct soap *soap, const char *tag, ns2__ReplyType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ReplyType **)soap_malloc(soap, sizeof(ns2__ReplyType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ReplyType *)soap_instantiate_ns2__ReplyType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ReplyType ** p = (ns2__ReplyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ReplyType, sizeof(ns2__ReplyType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ReplyType(struct soap *soap, ns2__ReplyType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ReplyType);
	if (soap_out_PointerTons2__ReplyType(soap, tag?tag:"ns2:ReplyType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ReplyType ** SOAP_FMAC4 soap_get_PointerTons2__ReplyType(struct soap *soap, ns2__ReplyType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ReplyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__RequestType(struct soap *soap, ns2__RequestType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__RequestType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__RequestType(struct soap *soap, const char *tag, int id, ns2__RequestType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__RequestType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__RequestType ** SOAP_FMAC4 soap_in_PointerTons2__RequestType(struct soap *soap, const char *tag, ns2__RequestType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__RequestType **)soap_malloc(soap, sizeof(ns2__RequestType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__RequestType *)soap_instantiate_ns2__RequestType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__RequestType ** p = (ns2__RequestType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__RequestType, sizeof(ns2__RequestType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__RequestType(struct soap *soap, ns2__RequestType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__RequestType);
	if (soap_out_PointerTons2__RequestType(soap, tag?tag:"ns2:RequestType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__RequestType ** SOAP_FMAC4 soap_get_PointerTons2__RequestType(struct soap *soap, ns2__RequestType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__RequestType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__HeaderType(struct soap *soap, ns2__HeaderType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__HeaderType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__HeaderType(struct soap *soap, const char *tag, int id, ns2__HeaderType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__HeaderType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__HeaderType ** SOAP_FMAC4 soap_in_PointerTons2__HeaderType(struct soap *soap, const char *tag, ns2__HeaderType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__HeaderType **)soap_malloc(soap, sizeof(ns2__HeaderType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__HeaderType *)soap_instantiate_ns2__HeaderType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__HeaderType ** p = (ns2__HeaderType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__HeaderType, sizeof(ns2__HeaderType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__HeaderType(struct soap *soap, ns2__HeaderType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__HeaderType);
	if (soap_out_PointerTons2__HeaderType(soap, tag?tag:"ns2:HeaderType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__HeaderType ** SOAP_FMAC4 soap_get_PointerTons2__HeaderType(struct soap *soap, ns2__HeaderType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__HeaderType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__MessageProperty(struct soap *soap, ns2__MessageProperty *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__MessageProperty))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__MessageProperty(struct soap *soap, const char *tag, int id, ns2__MessageProperty *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__MessageProperty);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__MessageProperty ** SOAP_FMAC4 soap_in_PointerTons2__MessageProperty(struct soap *soap, const char *tag, ns2__MessageProperty **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__MessageProperty **)soap_malloc(soap, sizeof(ns2__MessageProperty *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__MessageProperty *)soap_instantiate_ns2__MessageProperty(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__MessageProperty ** p = (ns2__MessageProperty **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__MessageProperty, sizeof(ns2__MessageProperty), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__MessageProperty(struct soap *soap, ns2__MessageProperty *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__MessageProperty);
	if (soap_out_PointerTons2__MessageProperty(soap, tag?tag:"ns2:MessageProperty", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__MessageProperty ** SOAP_FMAC4 soap_get_PointerTons2__MessageProperty(struct soap *soap, ns2__MessageProperty **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__MessageProperty(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__UserType(struct soap *soap, ns2__UserType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__UserType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__UserType(struct soap *soap, const char *tag, int id, ns2__UserType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__UserType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__UserType ** SOAP_FMAC4 soap_in_PointerTons2__UserType(struct soap *soap, const char *tag, ns2__UserType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__UserType **)soap_malloc(soap, sizeof(ns2__UserType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__UserType *)soap_instantiate_ns2__UserType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__UserType ** p = (ns2__UserType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__UserType, sizeof(ns2__UserType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__UserType(struct soap *soap, ns2__UserType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__UserType);
	if (soap_out_PointerTons2__UserType(soap, tag?tag:"ns2:UserType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__UserType ** SOAP_FMAC4 soap_get_PointerTons2__UserType(struct soap *soap, ns2__UserType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__UserType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ReplayDetectionType(struct soap *soap, ns2__ReplayDetectionType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ReplayDetectionType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ReplayDetectionType(struct soap *soap, const char *tag, int id, ns2__ReplayDetectionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ReplayDetectionType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ReplayDetectionType ** SOAP_FMAC4 soap_in_PointerTons2__ReplayDetectionType(struct soap *soap, const char *tag, ns2__ReplayDetectionType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ReplayDetectionType **)soap_malloc(soap, sizeof(ns2__ReplayDetectionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ReplayDetectionType *)soap_instantiate_ns2__ReplayDetectionType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ReplayDetectionType ** p = (ns2__ReplayDetectionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ReplayDetectionType, sizeof(ns2__ReplayDetectionType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ReplayDetectionType(struct soap *soap, ns2__ReplayDetectionType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ReplayDetectionType);
	if (soap_out_PointerTons2__ReplayDetectionType(soap, tag?tag:"ns2:ReplayDetectionType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ReplayDetectionType ** SOAP_FMAC4 soap_get_PointerTons2__ReplayDetectionType(struct soap *soap, ns2__ReplayDetectionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ReplayDetectionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__OperationType(struct soap *soap, ns2__OperationType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__OperationType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__OperationType(struct soap *soap, const char *tag, int id, ns2__OperationType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__OperationType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__OperationType ** SOAP_FMAC4 soap_in_PointerTons2__OperationType(struct soap *soap, const char *tag, ns2__OperationType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__OperationType **)soap_malloc(soap, sizeof(ns2__OperationType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__OperationType *)soap_instantiate_ns2__OperationType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__OperationType ** p = (ns2__OperationType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__OperationType, sizeof(ns2__OperationType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__OperationType(struct soap *soap, ns2__OperationType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__OperationType);
	if (soap_out_PointerTons2__OperationType(soap, tag?tag:"ns2:OperationType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__OperationType ** SOAP_FMAC4 soap_get_PointerTons2__OperationType(struct soap *soap, ns2__OperationType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__OperationType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobool(struct soap *soap, bool *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_bool);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobool(struct soap *soap, const char *tag, int id, bool *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bool);
	if (id < 0)
		return soap->error;
	return soap_out_bool(soap, tag, id, *a, type);
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_in_PointerTobool(struct soap *soap, const char *tag, bool **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (bool **)soap_malloc(soap, sizeof(bool *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bool(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (bool **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bool, sizeof(bool), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobool(struct soap *soap, bool *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobool);
	if (soap_out_PointerTobool(soap, tag?tag:"boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_get_PointerTobool(struct soap *soap, bool **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__vectorTemplateOf_ns2__PayloadType_ID(struct soap *soap, std::vector<_ns2__PayloadType_ID >*const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_std__vectorTemplateOf_ns2__PayloadType_ID))
		soap_serialize_std__vectorTemplateOf_ns2__PayloadType_ID(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__vectorTemplateOf_ns2__PayloadType_ID(struct soap *soap, const char *tag, int id, std::vector<_ns2__PayloadType_ID >*const*a, const char *type)
{
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	return soap_out_std__vectorTemplateOf_ns2__PayloadType_ID(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::vector<_ns2__PayloadType_ID >** SOAP_FMAC4 soap_in_PointerTostd__vectorTemplateOf_ns2__PayloadType_ID(struct soap *soap, const char *tag, std::vector<_ns2__PayloadType_ID >**a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	soap_revert(soap);
	if (!a)
	{	if (!(a = (std::vector<_ns2__PayloadType_ID >**)soap_malloc(soap, sizeof(std::vector<_ns2__PayloadType_ID >*))))
			return NULL;
		*a = NULL;
	}
	if (!(*a = soap_in_std__vectorTemplateOf_ns2__PayloadType_ID(soap, tag, *a, type)))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__vectorTemplateOf_ns2__PayloadType_ID(struct soap *soap, std::vector<_ns2__PayloadType_ID >*const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__vectorTemplateOf_ns2__PayloadType_ID);
	if (soap_out_PointerTostd__vectorTemplateOf_ns2__PayloadType_ID(soap, tag?tag:"", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::vector<_ns2__PayloadType_ID >** SOAP_FMAC4 soap_get_PointerTostd__vectorTemplateOf_ns2__PayloadType_ID(struct soap *soap, std::vector<_ns2__PayloadType_ID >**p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__vectorTemplateOf_ns2__PayloadType_ID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__OperationSet(struct soap *soap, ns2__OperationSet *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__OperationSet))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__OperationSet(struct soap *soap, const char *tag, int id, ns2__OperationSet *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__OperationSet);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__OperationSet ** SOAP_FMAC4 soap_in_PointerTons2__OperationSet(struct soap *soap, const char *tag, ns2__OperationSet **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__OperationSet **)soap_malloc(soap, sizeof(ns2__OperationSet *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__OperationSet *)soap_instantiate_ns2__OperationSet(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__OperationSet ** p = (ns2__OperationSet **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__OperationSet, sizeof(ns2__OperationSet), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__OperationSet(struct soap *soap, ns2__OperationSet *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__OperationSet);
	if (soap_out_PointerTons2__OperationSet(soap, tag?tag:"ns2:OperationSet", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__OperationSet ** SOAP_FMAC4 soap_get_PointerTons2__OperationSet(struct soap *soap, ns2__OperationSet **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__OperationSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__vectorTemplateOfPointerTons3__ArrayValuesType(struct soap *soap, std::vector<ns3__ArrayValuesType * >*const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons3__ArrayValuesType))
		soap_serialize_std__vectorTemplateOfPointerTons3__ArrayValuesType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__vectorTemplateOfPointerTons3__ArrayValuesType(struct soap *soap, const char *tag, int id, std::vector<ns3__ArrayValuesType * >*const*a, const char *type)
{
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	return soap_out_std__vectorTemplateOfPointerTons3__ArrayValuesType(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::vector<ns3__ArrayValuesType * >** SOAP_FMAC4 soap_in_PointerTostd__vectorTemplateOfPointerTons3__ArrayValuesType(struct soap *soap, const char *tag, std::vector<ns3__ArrayValuesType * >**a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	soap_revert(soap);
	if (!a)
	{	if (!(a = (std::vector<ns3__ArrayValuesType * >**)soap_malloc(soap, sizeof(std::vector<ns3__ArrayValuesType * >*))))
			return NULL;
		*a = NULL;
	}
	if (!(*a = soap_in_std__vectorTemplateOfPointerTons3__ArrayValuesType(soap, tag, *a, type)))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__vectorTemplateOfPointerTons3__ArrayValuesType(struct soap *soap, std::vector<ns3__ArrayValuesType * >*const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons3__ArrayValuesType);
	if (soap_out_PointerTostd__vectorTemplateOfPointerTons3__ArrayValuesType(soap, tag?tag:"", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::vector<ns3__ArrayValuesType * >** SOAP_FMAC4 soap_get_PointerTostd__vectorTemplateOfPointerTons3__ArrayValuesType(struct soap *soap, std::vector<ns3__ArrayValuesType * >**p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__vectorTemplateOfPointerTons3__ArrayValuesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__ArrayValuesType(struct soap *soap, ns3__ArrayValuesType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__ArrayValuesType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__ArrayValuesType(struct soap *soap, const char *tag, int id, ns3__ArrayValuesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__ArrayValuesType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__ArrayValuesType ** SOAP_FMAC4 soap_in_PointerTons3__ArrayValuesType(struct soap *soap, const char *tag, ns3__ArrayValuesType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__ArrayValuesType **)soap_malloc(soap, sizeof(ns3__ArrayValuesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__ArrayValuesType *)soap_instantiate_ns3__ArrayValuesType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns3__ArrayValuesType ** p = (ns3__ArrayValuesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__ArrayValuesType, sizeof(ns3__ArrayValuesType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__ArrayValuesType(struct soap *soap, ns3__ArrayValuesType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__ArrayValuesType);
	if (soap_out_PointerTons3__ArrayValuesType(soap, tag?tag:"ns3:ArrayValuesType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__ArrayValuesType ** SOAP_FMAC4 soap_get_PointerTons3__ArrayValuesType(struct soap *soap, ns3__ArrayValuesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__ArrayValuesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__vectorTemplateOfPointerTons3__DeviceValuesType(struct soap *soap, std::vector<ns3__DeviceValuesType * >*const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons3__DeviceValuesType))
		soap_serialize_std__vectorTemplateOfPointerTons3__DeviceValuesType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__vectorTemplateOfPointerTons3__DeviceValuesType(struct soap *soap, const char *tag, int id, std::vector<ns3__DeviceValuesType * >*const*a, const char *type)
{
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	return soap_out_std__vectorTemplateOfPointerTons3__DeviceValuesType(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::vector<ns3__DeviceValuesType * >** SOAP_FMAC4 soap_in_PointerTostd__vectorTemplateOfPointerTons3__DeviceValuesType(struct soap *soap, const char *tag, std::vector<ns3__DeviceValuesType * >**a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	soap_revert(soap);
	if (!a)
	{	if (!(a = (std::vector<ns3__DeviceValuesType * >**)soap_malloc(soap, sizeof(std::vector<ns3__DeviceValuesType * >*))))
			return NULL;
		*a = NULL;
	}
	if (!(*a = soap_in_std__vectorTemplateOfPointerTons3__DeviceValuesType(soap, tag, *a, type)))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__vectorTemplateOfPointerTons3__DeviceValuesType(struct soap *soap, std::vector<ns3__DeviceValuesType * >*const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons3__DeviceValuesType);
	if (soap_out_PointerTostd__vectorTemplateOfPointerTons3__DeviceValuesType(soap, tag?tag:"", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::vector<ns3__DeviceValuesType * >** SOAP_FMAC4 soap_get_PointerTostd__vectorTemplateOfPointerTons3__DeviceValuesType(struct soap *soap, std::vector<ns3__DeviceValuesType * >**p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__vectorTemplateOfPointerTons3__DeviceValuesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__DeviceValuesType(struct soap *soap, ns3__DeviceValuesType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__DeviceValuesType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__DeviceValuesType(struct soap *soap, const char *tag, int id, ns3__DeviceValuesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__DeviceValuesType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__DeviceValuesType ** SOAP_FMAC4 soap_in_PointerTons3__DeviceValuesType(struct soap *soap, const char *tag, ns3__DeviceValuesType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__DeviceValuesType **)soap_malloc(soap, sizeof(ns3__DeviceValuesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__DeviceValuesType *)soap_instantiate_ns3__DeviceValuesType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns3__DeviceValuesType ** p = (ns3__DeviceValuesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__DeviceValuesType, sizeof(ns3__DeviceValuesType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__DeviceValuesType(struct soap *soap, ns3__DeviceValuesType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__DeviceValuesType);
	if (soap_out_PointerTons3__DeviceValuesType(soap, tag?tag:"ns3:DeviceValuesType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__DeviceValuesType ** SOAP_FMAC4 soap_get_PointerTons3__DeviceValuesType(struct soap *soap, ns3__DeviceValuesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__DeviceValuesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__vectorTemplateOfPointerTons3__CommonValuesType(struct soap *soap, std::vector<ns3__CommonValuesType * >*const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons3__CommonValuesType))
		soap_serialize_std__vectorTemplateOfPointerTons3__CommonValuesType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__vectorTemplateOfPointerTons3__CommonValuesType(struct soap *soap, const char *tag, int id, std::vector<ns3__CommonValuesType * >*const*a, const char *type)
{
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	return soap_out_std__vectorTemplateOfPointerTons3__CommonValuesType(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::vector<ns3__CommonValuesType * >** SOAP_FMAC4 soap_in_PointerTostd__vectorTemplateOfPointerTons3__CommonValuesType(struct soap *soap, const char *tag, std::vector<ns3__CommonValuesType * >**a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	soap_revert(soap);
	if (!a)
	{	if (!(a = (std::vector<ns3__CommonValuesType * >**)soap_malloc(soap, sizeof(std::vector<ns3__CommonValuesType * >*))))
			return NULL;
		*a = NULL;
	}
	if (!(*a = soap_in_std__vectorTemplateOfPointerTons3__CommonValuesType(soap, tag, *a, type)))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__vectorTemplateOfPointerTons3__CommonValuesType(struct soap *soap, std::vector<ns3__CommonValuesType * >*const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons3__CommonValuesType);
	if (soap_out_PointerTostd__vectorTemplateOfPointerTons3__CommonValuesType(soap, tag?tag:"", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::vector<ns3__CommonValuesType * >** SOAP_FMAC4 soap_get_PointerTostd__vectorTemplateOfPointerTons3__CommonValuesType(struct soap *soap, std::vector<ns3__CommonValuesType * >**p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__vectorTemplateOfPointerTons3__CommonValuesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__CommonValuesType(struct soap *soap, ns3__CommonValuesType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__CommonValuesType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__CommonValuesType(struct soap *soap, const char *tag, int id, ns3__CommonValuesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__CommonValuesType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__CommonValuesType ** SOAP_FMAC4 soap_in_PointerTons3__CommonValuesType(struct soap *soap, const char *tag, ns3__CommonValuesType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__CommonValuesType **)soap_malloc(soap, sizeof(ns3__CommonValuesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__CommonValuesType *)soap_instantiate_ns3__CommonValuesType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns3__CommonValuesType ** p = (ns3__CommonValuesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__CommonValuesType, sizeof(ns3__CommonValuesType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__CommonValuesType(struct soap *soap, ns3__CommonValuesType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__CommonValuesType);
	if (soap_out_PointerTons3__CommonValuesType(soap, tag?tag:"ns3:CommonValuesType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__CommonValuesType ** SOAP_FMAC4 soap_get_PointerTons3__CommonValuesType(struct soap *soap, ns3__CommonValuesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__CommonValuesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__integer(struct soap *soap, std::string *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__integer))
		soap_serialize_xsd__integer(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__integer(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__integer);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__integer(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__integer(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__integer(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__integer, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__integer(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__integer);
	if (soap_out_PointerToxsd__integer(soap, tag?tag:"xsd:integer", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__integer(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__integer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__vectorTemplateOf_ns2__ReplyType_ID(struct soap *soap, std::vector<_ns2__ReplyType_ID >*const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_std__vectorTemplateOf_ns2__ReplyType_ID))
		soap_serialize_std__vectorTemplateOf_ns2__ReplyType_ID(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__vectorTemplateOf_ns2__ReplyType_ID(struct soap *soap, const char *tag, int id, std::vector<_ns2__ReplyType_ID >*const*a, const char *type)
{
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	return soap_out_std__vectorTemplateOf_ns2__ReplyType_ID(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::vector<_ns2__ReplyType_ID >** SOAP_FMAC4 soap_in_PointerTostd__vectorTemplateOf_ns2__ReplyType_ID(struct soap *soap, const char *tag, std::vector<_ns2__ReplyType_ID >**a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	soap_revert(soap);
	if (!a)
	{	if (!(a = (std::vector<_ns2__ReplyType_ID >**)soap_malloc(soap, sizeof(std::vector<_ns2__ReplyType_ID >*))))
			return NULL;
		*a = NULL;
	}
	if (!(*a = soap_in_std__vectorTemplateOf_ns2__ReplyType_ID(soap, tag, *a, type)))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__vectorTemplateOf_ns2__ReplyType_ID(struct soap *soap, std::vector<_ns2__ReplyType_ID >*const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__vectorTemplateOf_ns2__ReplyType_ID);
	if (soap_out_PointerTostd__vectorTemplateOf_ns2__ReplyType_ID(soap, tag?tag:"", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::vector<_ns2__ReplyType_ID >** SOAP_FMAC4 soap_get_PointerTostd__vectorTemplateOf_ns2__ReplyType_ID(struct soap *soap, std::vector<_ns2__ReplyType_ID >**p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__vectorTemplateOf_ns2__ReplyType_ID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ErrorType(struct soap *soap, ns2__ErrorType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ErrorType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ErrorType(struct soap *soap, const char *tag, int id, ns2__ErrorType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ErrorType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ErrorType ** SOAP_FMAC4 soap_in_PointerTons2__ErrorType(struct soap *soap, const char *tag, ns2__ErrorType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ErrorType **)soap_malloc(soap, sizeof(ns2__ErrorType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ErrorType *)soap_instantiate_ns2__ErrorType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ErrorType ** p = (ns2__ErrorType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ErrorType, sizeof(ns2__ErrorType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ErrorType(struct soap *soap, ns2__ErrorType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ErrorType);
	if (soap_out_PointerTons2__ErrorType(soap, tag?tag:"ns2:ErrorType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ErrorType ** SOAP_FMAC4 soap_get_PointerTons2__ErrorType(struct soap *soap, ns2__ErrorType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ErrorType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__vectorTemplateOf_ns2__RequestType_ID(struct soap *soap, std::vector<_ns2__RequestType_ID >*const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_std__vectorTemplateOf_ns2__RequestType_ID))
		soap_serialize_std__vectorTemplateOf_ns2__RequestType_ID(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__vectorTemplateOf_ns2__RequestType_ID(struct soap *soap, const char *tag, int id, std::vector<_ns2__RequestType_ID >*const*a, const char *type)
{
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	return soap_out_std__vectorTemplateOf_ns2__RequestType_ID(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::vector<_ns2__RequestType_ID >** SOAP_FMAC4 soap_in_PointerTostd__vectorTemplateOf_ns2__RequestType_ID(struct soap *soap, const char *tag, std::vector<_ns2__RequestType_ID >**a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	soap_revert(soap);
	if (!a)
	{	if (!(a = (std::vector<_ns2__RequestType_ID >**)soap_malloc(soap, sizeof(std::vector<_ns2__RequestType_ID >*))))
			return NULL;
		*a = NULL;
	}
	if (!(*a = soap_in_std__vectorTemplateOf_ns2__RequestType_ID(soap, tag, *a, type)))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__vectorTemplateOf_ns2__RequestType_ID(struct soap *soap, std::vector<_ns2__RequestType_ID >*const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__vectorTemplateOf_ns2__RequestType_ID);
	if (soap_out_PointerTostd__vectorTemplateOf_ns2__RequestType_ID(soap, tag?tag:"", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::vector<_ns2__RequestType_ID >** SOAP_FMAC4 soap_get_PointerTostd__vectorTemplateOf_ns2__RequestType_ID(struct soap *soap, std::vector<_ns2__RequestType_ID >**p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__vectorTemplateOf_ns2__RequestType_ID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__IDKindType(struct soap *soap, enum ns2__IDKindType *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_ns2__IDKindType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__IDKindType(struct soap *soap, const char *tag, int id, enum ns2__IDKindType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__IDKindType);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__IDKindType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns2__IDKindType ** SOAP_FMAC4 soap_in_PointerTons2__IDKindType(struct soap *soap, const char *tag, enum ns2__IDKindType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns2__IDKindType **)soap_malloc(soap, sizeof(enum ns2__IDKindType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__IDKindType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns2__IDKindType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__IDKindType, sizeof(enum ns2__IDKindType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__IDKindType(struct soap *soap, enum ns2__IDKindType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__IDKindType);
	if (soap_out_PointerTons2__IDKindType(soap, tag?tag:"ns2:IDKindType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__IDKindType ** SOAP_FMAC4 soap_get_PointerTons2__IDKindType(struct soap *soap, enum ns2__IDKindType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__IDKindType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_std__string))
		soap_serialize_std__string(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__string);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__string, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__string);
	if (soap_out_PointerTostd__string(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__OptionType(struct soap *soap, ns2__OptionType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__OptionType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__OptionType(struct soap *soap, const char *tag, int id, ns2__OptionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__OptionType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__OptionType ** SOAP_FMAC4 soap_in_PointerTons2__OptionType(struct soap *soap, const char *tag, ns2__OptionType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__OptionType **)soap_malloc(soap, sizeof(ns2__OptionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__OptionType *)soap_instantiate_ns2__OptionType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__OptionType ** p = (ns2__OptionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__OptionType, sizeof(ns2__OptionType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__OptionType(struct soap *soap, ns2__OptionType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__OptionType);
	if (soap_out_PointerTons2__OptionType(soap, tag?tag:"ns2:OptionType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__OptionType ** SOAP_FMAC4 soap_get_PointerTons2__OptionType(struct soap *soap, ns2__OptionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__OptionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotime(struct soap *soap, time_t *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_time);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotime(struct soap *soap, const char *tag, int id, time_t *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_time);
	if (id < 0)
		return soap->error;
	return soap_out_time(soap, tag, id, *a, type);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_in_PointerTotime(struct soap *soap, const char *tag, time_t **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (time_t **)soap_malloc(soap, sizeof(time_t *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_time(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (time_t **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_time, sizeof(time_t), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotime(struct soap *soap, time_t *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotime);
	if (soap_out_PointerTotime(soap, tag?tag:"dateTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_get_PointerTotime(struct soap *soap, time_t **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons3__DeviceClassType(struct soap *soap, std::vector<ns3__DeviceClassType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons3__DeviceClassType(struct soap *soap, const std::vector<ns3__DeviceClassType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns3__DeviceClassType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons3__DeviceClassType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons3__DeviceClassType(struct soap *soap, const char *tag, int id, const std::vector<ns3__DeviceClassType * >*a, const char *type)
{
	for (std::vector<ns3__DeviceClassType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons3__DeviceClassType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns3__DeviceClassType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons3__DeviceClassType(struct soap *soap, const char *tag, std::vector<ns3__DeviceClassType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns3__DeviceClassType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns3__DeviceClassType, SOAP_TYPE_std__vectorTemplateOfPointerTons3__DeviceClassType, sizeof(ns3__DeviceClassType), 1))
				break;
			if (!soap_in_PointerTons3__DeviceClassType(soap, tag, NULL, "ns3:DeviceClassType"))
				break;
		}
		else if (!soap_in_PointerTons3__DeviceClassType(soap, tag, &n, "ns3:DeviceClassType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons3__DeviceClassType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns3__DeviceClassType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons3__DeviceClassType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons3__DeviceClassType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons3__DeviceClassType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns3__DeviceClassType * >);
		if (size)
			*size = sizeof(std::vector<ns3__DeviceClassType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns3__DeviceClassType * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns3__DeviceClassType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns3__DeviceClassType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons3__DeviceClassType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns3__DeviceClassType * > %p -> %p\n", q, p));
	*(std::vector<ns3__DeviceClassType * >*)p = *(std::vector<ns3__DeviceClassType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__Name(struct soap *soap, std::vector<ns2__Name * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__Name(struct soap *soap, const std::vector<ns2__Name * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns2__Name * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__Name(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__Name(struct soap *soap, const char *tag, int id, const std::vector<ns2__Name * >*a, const char *type)
{
	for (std::vector<ns2__Name * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__Name(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__Name * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__Name(struct soap *soap, const char *tag, std::vector<ns2__Name * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns2__Name *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__Name, SOAP_TYPE_std__vectorTemplateOfPointerTons2__Name, sizeof(ns2__Name), 1))
				break;
			if (!soap_in_PointerTons2__Name(soap, tag, NULL, "ns2:Name"))
				break;
		}
		else if (!soap_in_PointerTons2__Name(soap, tag, &n, "ns2:Name"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__Name(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__Name * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__Name(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__Name(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__Name, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__Name * >);
		if (size)
			*size = sizeof(std::vector<ns2__Name * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns2__Name * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns2__Name * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns2__Name * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__Name(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__Name * > %p -> %p\n", q, p));
	*(std::vector<ns2__Name * >*)p = *(std::vector<ns2__Name * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__MessageProperty(struct soap *soap, std::vector<ns2__MessageProperty * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__MessageProperty(struct soap *soap, const std::vector<ns2__MessageProperty * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns2__MessageProperty * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__MessageProperty(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__MessageProperty(struct soap *soap, const char *tag, int id, const std::vector<ns2__MessageProperty * >*a, const char *type)
{
	for (std::vector<ns2__MessageProperty * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__MessageProperty(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__MessageProperty * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__MessageProperty(struct soap *soap, const char *tag, std::vector<ns2__MessageProperty * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns2__MessageProperty *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__MessageProperty, SOAP_TYPE_std__vectorTemplateOfPointerTons2__MessageProperty, sizeof(ns2__MessageProperty), 1))
				break;
			if (!soap_in_PointerTons2__MessageProperty(soap, tag, NULL, "ns2:MessageProperty"))
				break;
		}
		else if (!soap_in_PointerTons2__MessageProperty(soap, tag, &n, "ns2:MessageProperty"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__MessageProperty(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__MessageProperty * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__MessageProperty(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__MessageProperty(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__MessageProperty, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__MessageProperty * >);
		if (size)
			*size = sizeof(std::vector<ns2__MessageProperty * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns2__MessageProperty * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns2__MessageProperty * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns2__MessageProperty * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__MessageProperty(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__MessageProperty * > %p -> %p\n", q, p));
	*(std::vector<ns2__MessageProperty * >*)p = *(std::vector<ns2__MessageProperty * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__OperationType(struct soap *soap, std::vector<ns2__OperationType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__OperationType(struct soap *soap, const std::vector<ns2__OperationType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns2__OperationType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__OperationType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__OperationType(struct soap *soap, const char *tag, int id, const std::vector<ns2__OperationType * >*a, const char *type)
{
	for (std::vector<ns2__OperationType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__OperationType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__OperationType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__OperationType(struct soap *soap, const char *tag, std::vector<ns2__OperationType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns2__OperationType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__OperationType, SOAP_TYPE_std__vectorTemplateOfPointerTons2__OperationType, sizeof(ns2__OperationType), 1))
				break;
			if (!soap_in_PointerTons2__OperationType(soap, tag, NULL, "ns2:OperationType"))
				break;
		}
		else if (!soap_in_PointerTons2__OperationType(soap, tag, &n, "ns2:OperationType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__OperationType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__OperationType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__OperationType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__OperationType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__OperationType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__OperationType * >);
		if (size)
			*size = sizeof(std::vector<ns2__OperationType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns2__OperationType * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns2__OperationType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns2__OperationType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__OperationType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__OperationType * > %p -> %p\n", q, p));
	*(std::vector<ns2__OperationType * >*)p = *(std::vector<ns2__OperationType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_ns2__PayloadType_ID(struct soap *soap, std::vector<_ns2__PayloadType_ID >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_ns2__PayloadType_ID(struct soap *soap, const std::vector<_ns2__PayloadType_ID >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<_ns2__PayloadType_ID >::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_ns2__PayloadType_ID(struct soap *soap, const char *tag, int id, const std::vector<_ns2__PayloadType_ID >*a, const char *type)
{
	for (std::vector<_ns2__PayloadType_ID >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_ns2__PayloadType_ID >* SOAP_FMAC4 soap_in_std__vectorTemplateOf_ns2__PayloadType_ID(struct soap *soap, const char *tag, std::vector<_ns2__PayloadType_ID >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	_ns2__PayloadType_ID n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n.soap_default(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE__ns2__PayloadType_ID, SOAP_TYPE_std__vectorTemplateOf_ns2__PayloadType_ID, sizeof(_ns2__PayloadType_ID), 0))
				break;
			if (!soap_in__ns2__PayloadType_ID(soap, tag, NULL, ""))
				break;
		}
		else if (!soap_in__ns2__PayloadType_ID(soap, tag, &n, ""))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOf_ns2__PayloadType_ID(soap, -1)))
			return NULL;
		soap_update_pointers(soap, (char*)&n, (char*)&n + sizeof(n), (char*)&(*a->insert(a->end(), n)), (char*)&n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<_ns2__PayloadType_ID > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf_ns2__PayloadType_ID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_ns2__PayloadType_ID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOf_ns2__PayloadType_ID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<_ns2__PayloadType_ID >);
		if (size)
			*size = sizeof(std::vector<_ns2__PayloadType_ID >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<_ns2__PayloadType_ID >, n);
		if (size)
			*size = n * sizeof(std::vector<_ns2__PayloadType_ID >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<_ns2__PayloadType_ID >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOf_ns2__PayloadType_ID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<_ns2__PayloadType_ID > %p -> %p\n", q, p));
	*(std::vector<_ns2__PayloadType_ID >*)p = *(std::vector<_ns2__PayloadType_ID >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons3__ArrayValuesType(struct soap *soap, std::vector<ns3__ArrayValuesType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons3__ArrayValuesType(struct soap *soap, const std::vector<ns3__ArrayValuesType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns3__ArrayValuesType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons3__ArrayValuesType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons3__ArrayValuesType(struct soap *soap, const char *tag, int id, const std::vector<ns3__ArrayValuesType * >*a, const char *type)
{
	for (std::vector<ns3__ArrayValuesType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons3__ArrayValuesType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns3__ArrayValuesType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons3__ArrayValuesType(struct soap *soap, const char *tag, std::vector<ns3__ArrayValuesType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns3__ArrayValuesType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns3__ArrayValuesType, SOAP_TYPE_std__vectorTemplateOfPointerTons3__ArrayValuesType, sizeof(ns3__ArrayValuesType), 1))
				break;
			if (!soap_in_PointerTons3__ArrayValuesType(soap, tag, NULL, "ns3:ArrayValuesType"))
				break;
		}
		else if (!soap_in_PointerTons3__ArrayValuesType(soap, tag, &n, "ns3:ArrayValuesType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons3__ArrayValuesType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns3__ArrayValuesType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons3__ArrayValuesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons3__ArrayValuesType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons3__ArrayValuesType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns3__ArrayValuesType * >);
		if (size)
			*size = sizeof(std::vector<ns3__ArrayValuesType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns3__ArrayValuesType * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns3__ArrayValuesType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns3__ArrayValuesType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons3__ArrayValuesType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns3__ArrayValuesType * > %p -> %p\n", q, p));
	*(std::vector<ns3__ArrayValuesType * >*)p = *(std::vector<ns3__ArrayValuesType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons3__DeviceValuesType(struct soap *soap, std::vector<ns3__DeviceValuesType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons3__DeviceValuesType(struct soap *soap, const std::vector<ns3__DeviceValuesType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns3__DeviceValuesType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons3__DeviceValuesType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons3__DeviceValuesType(struct soap *soap, const char *tag, int id, const std::vector<ns3__DeviceValuesType * >*a, const char *type)
{
	for (std::vector<ns3__DeviceValuesType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons3__DeviceValuesType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns3__DeviceValuesType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons3__DeviceValuesType(struct soap *soap, const char *tag, std::vector<ns3__DeviceValuesType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns3__DeviceValuesType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns3__DeviceValuesType, SOAP_TYPE_std__vectorTemplateOfPointerTons3__DeviceValuesType, sizeof(ns3__DeviceValuesType), 1))
				break;
			if (!soap_in_PointerTons3__DeviceValuesType(soap, tag, NULL, "ns3:DeviceValuesType"))
				break;
		}
		else if (!soap_in_PointerTons3__DeviceValuesType(soap, tag, &n, "ns3:DeviceValuesType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons3__DeviceValuesType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns3__DeviceValuesType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons3__DeviceValuesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons3__DeviceValuesType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons3__DeviceValuesType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns3__DeviceValuesType * >);
		if (size)
			*size = sizeof(std::vector<ns3__DeviceValuesType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns3__DeviceValuesType * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns3__DeviceValuesType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns3__DeviceValuesType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons3__DeviceValuesType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns3__DeviceValuesType * > %p -> %p\n", q, p));
	*(std::vector<ns3__DeviceValuesType * >*)p = *(std::vector<ns3__DeviceValuesType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons3__CommonValuesType(struct soap *soap, std::vector<ns3__CommonValuesType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons3__CommonValuesType(struct soap *soap, const std::vector<ns3__CommonValuesType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns3__CommonValuesType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons3__CommonValuesType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons3__CommonValuesType(struct soap *soap, const char *tag, int id, const std::vector<ns3__CommonValuesType * >*a, const char *type)
{
	for (std::vector<ns3__CommonValuesType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons3__CommonValuesType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns3__CommonValuesType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons3__CommonValuesType(struct soap *soap, const char *tag, std::vector<ns3__CommonValuesType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns3__CommonValuesType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns3__CommonValuesType, SOAP_TYPE_std__vectorTemplateOfPointerTons3__CommonValuesType, sizeof(ns3__CommonValuesType), 1))
				break;
			if (!soap_in_PointerTons3__CommonValuesType(soap, tag, NULL, "ns3:CommonValuesType"))
				break;
		}
		else if (!soap_in_PointerTons3__CommonValuesType(soap, tag, &n, "ns3:CommonValuesType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons3__CommonValuesType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns3__CommonValuesType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons3__CommonValuesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons3__CommonValuesType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons3__CommonValuesType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns3__CommonValuesType * >);
		if (size)
			*size = sizeof(std::vector<ns3__CommonValuesType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns3__CommonValuesType * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns3__CommonValuesType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns3__CommonValuesType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons3__CommonValuesType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns3__CommonValuesType * > %p -> %p\n", q, p));
	*(std::vector<ns3__CommonValuesType * >*)p = *(std::vector<ns3__CommonValuesType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_ns2__ReplyType_ID(struct soap *soap, std::vector<_ns2__ReplyType_ID >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_ns2__ReplyType_ID(struct soap *soap, const std::vector<_ns2__ReplyType_ID >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<_ns2__ReplyType_ID >::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_ns2__ReplyType_ID(struct soap *soap, const char *tag, int id, const std::vector<_ns2__ReplyType_ID >*a, const char *type)
{
	for (std::vector<_ns2__ReplyType_ID >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_ns2__ReplyType_ID >* SOAP_FMAC4 soap_in_std__vectorTemplateOf_ns2__ReplyType_ID(struct soap *soap, const char *tag, std::vector<_ns2__ReplyType_ID >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	_ns2__ReplyType_ID n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n.soap_default(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE__ns2__ReplyType_ID, SOAP_TYPE_std__vectorTemplateOf_ns2__ReplyType_ID, sizeof(_ns2__ReplyType_ID), 0))
				break;
			if (!soap_in__ns2__ReplyType_ID(soap, tag, NULL, ""))
				break;
		}
		else if (!soap_in__ns2__ReplyType_ID(soap, tag, &n, ""))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOf_ns2__ReplyType_ID(soap, -1)))
			return NULL;
		soap_update_pointers(soap, (char*)&n, (char*)&n + sizeof(n), (char*)&(*a->insert(a->end(), n)), (char*)&n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<_ns2__ReplyType_ID > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf_ns2__ReplyType_ID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_ns2__ReplyType_ID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOf_ns2__ReplyType_ID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<_ns2__ReplyType_ID >);
		if (size)
			*size = sizeof(std::vector<_ns2__ReplyType_ID >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<_ns2__ReplyType_ID >, n);
		if (size)
			*size = n * sizeof(std::vector<_ns2__ReplyType_ID >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<_ns2__ReplyType_ID >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOf_ns2__ReplyType_ID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<_ns2__ReplyType_ID > %p -> %p\n", q, p));
	*(std::vector<_ns2__ReplyType_ID >*)p = *(std::vector<_ns2__ReplyType_ID >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__ErrorType(struct soap *soap, std::vector<ns2__ErrorType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__ErrorType(struct soap *soap, const std::vector<ns2__ErrorType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns2__ErrorType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__ErrorType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__ErrorType(struct soap *soap, const char *tag, int id, const std::vector<ns2__ErrorType * >*a, const char *type)
{
	for (std::vector<ns2__ErrorType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__ErrorType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__ErrorType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__ErrorType(struct soap *soap, const char *tag, std::vector<ns2__ErrorType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns2__ErrorType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__ErrorType, SOAP_TYPE_std__vectorTemplateOfPointerTons2__ErrorType, sizeof(ns2__ErrorType), 1))
				break;
			if (!soap_in_PointerTons2__ErrorType(soap, tag, NULL, "ns2:ErrorType"))
				break;
		}
		else if (!soap_in_PointerTons2__ErrorType(soap, tag, &n, "ns2:ErrorType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__ErrorType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__ErrorType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__ErrorType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__ErrorType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__ErrorType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__ErrorType * >);
		if (size)
			*size = sizeof(std::vector<ns2__ErrorType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns2__ErrorType * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns2__ErrorType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns2__ErrorType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__ErrorType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__ErrorType * > %p -> %p\n", q, p));
	*(std::vector<ns2__ErrorType * >*)p = *(std::vector<ns2__ErrorType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_XML(struct soap *soap, std::vector<char * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_XML(struct soap *soap, const std::vector<char * >*a)
{
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_XML(struct soap *soap, const char *tag, int id, const std::vector<char * >*a, const char *type)
{
	for (std::vector<char * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_outliteral(soap, tag, &(*i), NULL))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<char * >* SOAP_FMAC4 soap_in_std__vectorTemplateOf_XML(struct soap *soap, const char *tag, std::vector<char * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	char *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE__XML, SOAP_TYPE_std__vectorTemplateOf_XML, sizeof(char *), 1))
				break;
			if (!soap_inliteral(soap, tag, NULL))
				break;
		}
		else if (!soap_inliteral(soap, tag, &n))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOf_XML(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<char * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf_XML(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_XML(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOf_XML, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<char * >);
		if (size)
			*size = sizeof(std::vector<char * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<char * >, n);
		if (size)
			*size = n * sizeof(std::vector<char * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<char * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOf_XML(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<char * > %p -> %p\n", q, p));
	*(std::vector<char * >*)p = *(std::vector<char * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_ns2__RequestType_ID(struct soap *soap, std::vector<_ns2__RequestType_ID >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_ns2__RequestType_ID(struct soap *soap, const std::vector<_ns2__RequestType_ID >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<_ns2__RequestType_ID >::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_ns2__RequestType_ID(struct soap *soap, const char *tag, int id, const std::vector<_ns2__RequestType_ID >*a, const char *type)
{
	for (std::vector<_ns2__RequestType_ID >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_ns2__RequestType_ID >* SOAP_FMAC4 soap_in_std__vectorTemplateOf_ns2__RequestType_ID(struct soap *soap, const char *tag, std::vector<_ns2__RequestType_ID >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	_ns2__RequestType_ID n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n.soap_default(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE__ns2__RequestType_ID, SOAP_TYPE_std__vectorTemplateOf_ns2__RequestType_ID, sizeof(_ns2__RequestType_ID), 0))
				break;
			if (!soap_in__ns2__RequestType_ID(soap, tag, NULL, ""))
				break;
		}
		else if (!soap_in__ns2__RequestType_ID(soap, tag, &n, ""))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOf_ns2__RequestType_ID(soap, -1)))
			return NULL;
		soap_update_pointers(soap, (char*)&n, (char*)&n + sizeof(n), (char*)&(*a->insert(a->end(), n)), (char*)&n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<_ns2__RequestType_ID > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf_ns2__RequestType_ID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_ns2__RequestType_ID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOf_ns2__RequestType_ID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<_ns2__RequestType_ID >);
		if (size)
			*size = sizeof(std::vector<_ns2__RequestType_ID >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<_ns2__RequestType_ID >, n);
		if (size)
			*size = n * sizeof(std::vector<_ns2__RequestType_ID >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<_ns2__RequestType_ID >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOf_ns2__RequestType_ID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<_ns2__RequestType_ID > %p -> %p\n", q, p));
	*(std::vector<_ns2__RequestType_ID >*)p = *(std::vector<_ns2__RequestType_ID >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__OptionType(struct soap *soap, std::vector<ns2__OptionType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__OptionType(struct soap *soap, const std::vector<ns2__OptionType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns2__OptionType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__OptionType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__OptionType(struct soap *soap, const char *tag, int id, const std::vector<ns2__OptionType * >*a, const char *type)
{
	for (std::vector<ns2__OptionType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__OptionType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__OptionType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__OptionType(struct soap *soap, const char *tag, std::vector<ns2__OptionType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns2__OptionType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__OptionType, SOAP_TYPE_std__vectorTemplateOfPointerTons2__OptionType, sizeof(ns2__OptionType), 1))
				break;
			if (!soap_in_PointerTons2__OptionType(soap, tag, NULL, "ns2:OptionType"))
				break;
		}
		else if (!soap_in_PointerTons2__OptionType(soap, tag, &n, "ns2:OptionType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__OptionType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__OptionType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__OptionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__OptionType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__OptionType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__OptionType * >);
		if (size)
			*size = sizeof(std::vector<ns2__OptionType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns2__OptionType * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns2__OptionType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns2__OptionType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__OptionType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__OptionType * > %p -> %p\n", q, p));
	*(std::vector<ns2__OptionType * >*)p = *(std::vector<ns2__OptionType * >*)q;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
